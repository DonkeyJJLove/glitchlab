From 2c8f5b1449177c7678a505739359b28ddde50d31 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 02:11:39 +0200
Subject: [PATCH 1/9] commit 55: Benchmark 2

---
 MAIL_SMOKE.txt | 1 +
 VERSION.json   | 1 +
 2 files changed, 2 insertions(+)
 create mode 100644 MAIL_SMOKE.txt
 create mode 100644 VERSION.json

diff --git a/MAIL_SMOKE.txt b/MAIL_SMOKE.txt
new file mode 100644
index 0000000..ce01362
--- /dev/null
+++ b/MAIL_SMOKE.txt
@@ -0,0 +1 @@
+hello
diff --git a/VERSION.json b/VERSION.json
new file mode 100644
index 0000000..da9d96a
--- /dev/null
+++ b/VERSION.json
@@ -0,0 +1 @@
+{"app": "glitchlab", "version": "2025.09.28-0011", "sha": "74beff39093cf521ab878c6c5c0dd0ef6ba018be", "updated_at": "2025-09-28T00:11:39Z"}
-- 
2.45.1.windows.1


From 3cc2f1b814c7aaff36b1833e2b88d90e6a9275b2 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 02:22:10 +0200
Subject: [PATCH 2/9] diag: path auto-detect for hooks

---
 .env                                          |   8 +
 .githooks/post-commit.cmd                     |   5 +
 .gitignore                                    |   5 +
 VERSION.json                                  |   2 +-
 __pycache__/__init__.cpython-39.pyc           | Bin 216 -> 161 bytes
 analysis/__pycache__/__init__.cpython-39.pyc  | Bin 0 -> 170 bytes
 core/__pycache__/__init__.cpython-39.pyc      | Bin 0 -> 166 bytes
 filters/__pycache__/__init__.cpython-39.pyc   | Bin 2600 -> 2600 bytes
 .../block_mosh_grid.cpython-39.pyc            | Bin 9377 -> 9377 bytes
 .../spectral_shaper.cpython-39.pyc            | Bin 6406 -> 6406 bytes
 google/credentials.json                       |   0
 gui/__pycache__/app.cpython-39.pyc            | Bin 21838 -> 25791 bytes
 gui/__pycache__/docking.cpython-39.pyc        | Bin 2010 -> 2010 bytes
 gui/__pycache__/event_bus.cpython-39.pyc      | Bin 4167 -> 4046 bytes
 gui/__pycache__/panel_base.cpython-39.pyc     | Bin 7187 -> 7187 bytes
 gui/__pycache__/panel_loader.cpython-39.pyc   | Bin 2539 -> 7111 bytes
 gui/bench/__pycache__/__init__.cpython-39.pyc | Bin 0 -> 171 bytes
 .../__pycache__/ab_runner.cpython-39.pyc      | Bin 0 -> 1964 bytes
 gui/bench/__pycache__/judge.cpython-39.pyc    | Bin 0 -> 2593 bytes
 gui/bench/__pycache__/metrics.cpython-39.pyc  | Bin 0 -> 2253 bytes
 gui/bench/__pycache__/stats.cpython-39.pyc    | Bin 0 -> 2677 bytes
 .../__pycache__/templates.cpython-39.pyc      | Bin 0 -> 2408 bytes
 .../__pycache__/agent_mozaika.cpython-39.pyc  | Bin 0 -> 8493 bytes
 .../__pycache__/agent_ms_like.cpython-39.pyc  | Bin 0 -> 3024 bytes
 .../tests/__pycache__/__init__.cpython-39.pyc | Bin 0 -> 177 bytes
 .../e2e/__pycache__/__init__.cpython-39.pyc   | Bin 0 -> 181 bytes
 ...test_ab_runner.cpython-39-pytest-8.4.2.pyc | Bin 0 -> 5058 bytes
 ...t_plot_results.cpython-39-pytest-8.4.2.pyc | Bin 0 -> 1360 bytes
 .../fuzz/__pycache__/__init__.cpython-39.pyc  | Bin 0 -> 182 bytes
 ...est_fuzz_tasks.cpython-39-pytest-8.4.2.pyc | Bin 0 -> 1392 bytes
 .../perf/__pycache__/__init__.cpython-39.pyc  | Bin 0 -> 182 bytes
 ...t_perf_timings.cpython-39-pytest-8.4.2.pyc | Bin 0 -> 996 bytes
 .../__pycache__/__init__.cpython-39.pyc       | Bin 0 -> 186 bytes
 ...tasks_property.cpython-39-pytest-8.4.2.pyc | Bin 0 -> 911 bytes
 .../unit/__pycache__/__init__.cpython-39.pyc  | Bin 0 -> 182 bytes
 .../test_stats.cpython-39-pytest-8.4.2.pyc    | Bin 0 -> 1909 bytes
 ...test_templates.cpython-39-pytest-8.4.2.pyc | Bin 0 -> 1084 bytes
 .../utils/__pycache__/__init__.cpython-39.pyc | Bin 0 -> 177 bytes
 .../__pycache__/plot_results.cpython-39.pyc   | Bin 0 -> 4731 bytes
 .../__pycache__/__init__.cpython-39.pyc       | Bin 172 -> 711 bytes
 .../hybrid_ast_mosaic.cpython-39.pyc          | Bin 0 -> 22885 bytes
 .../__pycache__/__init__.cpython-39.pyc       | Bin 4869 -> 4869 bytes
 .../panel_spectral_shaper.cpython-39.pyc      | Bin 10154 -> 10154 bytes
 .../__pycache__/compositor.cpython-39.pyc     | Bin 0 -> 4407 bytes
 .../__pycache__/layer_manager.cpython-39.pyc  | Bin 0 -> 10008 bytes
 .../pipeline_runner.cpython-39.pyc            | Bin 4574 -> 4574 bytes
 .../__pycache__/bottom_area.cpython-39.pyc    | Bin 1986 -> 1986 bytes
 .../__pycache__/bottom_panel.cpython-39.pyc   | Bin 6244 -> 6244 bytes
 gui/views/__pycache__/hud.cpython-39.pyc      | Bin 11758 -> 11758 bytes
 .../__pycache__/layer_panel.cpython-39.pyc    | Bin 0 -> 14075 bytes
 .../__pycache__/left_dummy.cpython-39.pyc     | Bin 2688 -> 2688 bytes
 gui/views/__pycache__/menu.cpython-39.pyc     | Bin 9560 -> 9560 bytes
 .../__pycache__/statusbar.cpython-39.pyc      | Bin 6862 -> 6862 bytes
 .../__pycache__/tab_filter.cpython-39.pyc     | Bin 16630 -> 17199 bytes
 .../__pycache__/tab_general.cpython-39.pyc    | Bin 13746 -> 13746 bytes
 .../__pycache__/tab_preset.cpython-39.pyc     | Bin 14788 -> 14788 bytes
 .../canvas_container.cpython-39.pyc           | Bin 12116 -> 14113 bytes
 .../__pycache__/image_canvas.cpython-39.pyc   | Bin 15658 -> 8945 bytes
 .../__pycache__/image_layers.cpython-39.pyc   | Bin 0 -> 6829 bytes
 .../__pycache__/layer_canvas.cpython-39.pyc   | Bin 0 -> 13563 bytes
 .../overlay_renderer.cpython-39.pyc           | Bin 0 -> 7876 bytes
 .../__pycache__/preset_manager.cpython-39.pyc | Bin 16045 -> 16045 bytes
 .../tools/__pycache__/__init__.cpython-39.pyc | Bin 0 -> 5091 bytes
 .../tools/__pycache__/base.cpython-39.pyc     | Bin 0 -> 6002 bytes
 .../__pycache__/tool_brush.cpython-39.pyc     | Bin 0 -> 6721 bytes
 .../tool_ellipse_select.cpython-39.pyc        | Bin 0 -> 7336 bytes
 .../__pycache__/tool_eraser.cpython-39.pyc    | Bin 0 -> 6715 bytes
 .../__pycache__/tool_measure.cpython-39.pyc   | Bin 0 -> 4706 bytes
 .../tool_move_layer.cpython-39.pyc            | Bin 0 -> 5527 bytes
 .../__pycache__/tool_pipette.cpython-39.pyc   | Bin 0 -> 5634 bytes
 .../tool_rect_select.cpython-39.pyc           | Bin 0 -> 6694 bytes
 .../__pycache__/tool_view.cpython-39.pyc      | Bin 0 -> 4028 bytes
 scripts/gmail_send_patch.py                   | 109 +++
 ...id_mosaic_algo.cpython-39-pytest-8.4.2.pyc | Bin 0 -> 11098 bytes
 tests/ast_mosaic_coupled.py                   | 731 ++++++++++++++++++
 tests/ast_mosaic_protocol_experiment.py       | 349 +++++++++
 tests/ast_mosaic_to_lattice_experiment.py     | 353 +++++++++
 tests/demo_hybrid_mosaic_eval.py              | 178 +++++
 tests/hybrid_mosaic_test_report.py            | 261 +++++++
 tests/metarelation_scaling_test.py            | 590 ++++++++++++++
 tests/mini_mosaic_ast.py                      | 241 ++++++
 tests/mosaic_ast_3d_demo.py                   | 293 +++++++
 tests/mosaic_ast_metalegend_demo.py           | 313 ++++++++
 tests/mosaic_ast_to3d_point0.py               | 467 +++++++++++
 tests/raport.md                               | 117 +++
 tests/scratch.py                              |  45 ++
 tests/scratch2.py                             | 357 +++++++++
 tests/scratch3.py                             | 431 +++++++++++
 tests/test1.py                                | 461 +++++++++++
 tests/test_hybrid_mosaic_algo.py              | 169 ++++
 tests/test_layer_viewer_manual.py             | 255 ++++++
 tests/test_tools_registry.py                  |  82 ++
 92 files changed, 5821 insertions(+), 1 deletion(-)
 create mode 100644 .env
 create mode 100644 .githooks/post-commit.cmd
 create mode 100644 analysis/__pycache__/__init__.cpython-39.pyc
 create mode 100644 core/__pycache__/__init__.cpython-39.pyc
 create mode 100644 google/credentials.json
 create mode 100644 gui/bench/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/__pycache__/ab_runner.cpython-39.pyc
 create mode 100644 gui/bench/__pycache__/judge.cpython-39.pyc
 create mode 100644 gui/bench/__pycache__/metrics.cpython-39.pyc
 create mode 100644 gui/bench/__pycache__/stats.cpython-39.pyc
 create mode 100644 gui/bench/__pycache__/templates.cpython-39.pyc
 create mode 100644 gui/bench/agents/__pycache__/agent_mozaika.cpython-39.pyc
 create mode 100644 gui/bench/agents/__pycache__/agent_ms_like.cpython-39.pyc
 create mode 100644 gui/bench/tests/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/tests/e2e/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/tests/e2e/__pycache__/test_ab_runner.cpython-39-pytest-8.4.2.pyc
 create mode 100644 gui/bench/tests/e2e/__pycache__/test_plot_results.cpython-39-pytest-8.4.2.pyc
 create mode 100644 gui/bench/tests/fuzz/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/tests/fuzz/__pycache__/test_fuzz_tasks.cpython-39-pytest-8.4.2.pyc
 create mode 100644 gui/bench/tests/perf/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/tests/perf/__pycache__/test_perf_timings.cpython-39-pytest-8.4.2.pyc
 create mode 100644 gui/bench/tests/property/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/tests/property/__pycache__/test_tasks_property.cpython-39-pytest-8.4.2.pyc
 create mode 100644 gui/bench/tests/unit/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/tests/unit/__pycache__/test_stats.cpython-39-pytest-8.4.2.pyc
 create mode 100644 gui/bench/tests/unit/__pycache__/test_templates.cpython-39-pytest-8.4.2.pyc
 create mode 100644 gui/bench/utils/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/bench/utils/__pycache__/plot_results.cpython-39.pyc
 create mode 100644 gui/mosaic/__pycache__/hybrid_ast_mosaic.cpython-39.pyc
 create mode 100644 gui/services/__pycache__/compositor.cpython-39.pyc
 create mode 100644 gui/services/__pycache__/layer_manager.cpython-39.pyc
 create mode 100644 gui/views/__pycache__/layer_panel.cpython-39.pyc
 create mode 100644 gui/widgets/__pycache__/image_layers.cpython-39.pyc
 create mode 100644 gui/widgets/__pycache__/layer_canvas.cpython-39.pyc
 create mode 100644 gui/widgets/__pycache__/overlay_renderer.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/__init__.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/base.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_brush.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_ellipse_select.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_eraser.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_measure.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_move_layer.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_pipette.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_rect_select.cpython-39.pyc
 create mode 100644 gui/widgets/tools/__pycache__/tool_view.cpython-39.pyc
 create mode 100644 scripts/gmail_send_patch.py
 create mode 100644 tests/__pycache__/test_hybrid_mosaic_algo.cpython-39-pytest-8.4.2.pyc
 create mode 100644 tests/ast_mosaic_coupled.py
 create mode 100644 tests/ast_mosaic_protocol_experiment.py
 create mode 100644 tests/ast_mosaic_to_lattice_experiment.py
 create mode 100644 tests/demo_hybrid_mosaic_eval.py
 create mode 100644 tests/hybrid_mosaic_test_report.py
 create mode 100644 tests/metarelation_scaling_test.py
 create mode 100644 tests/mini_mosaic_ast.py
 create mode 100644 tests/mosaic_ast_3d_demo.py
 create mode 100644 tests/mosaic_ast_metalegend_demo.py
 create mode 100644 tests/mosaic_ast_to3d_point0.py
 create mode 100644 tests/raport.md
 create mode 100644 tests/scratch.py
 create mode 100644 tests/scratch2.py
 create mode 100644 tests/scratch3.py
 create mode 100644 tests/test1.py
 create mode 100644 tests/test_hybrid_mosaic_algo.py
 create mode 100644 tests/test_layer_viewer_manual.py
 create mode 100644 tests/test_tools_registry.py

diff --git a/.env b/.env
new file mode 100644
index 0000000..3d13a2c
--- /dev/null
+++ b/.env
@@ -0,0 +1,8 @@
+GLX_SMTP_HOST=smtp.gmail.com
+GLX_SMTP_PORT=587
+GLX_SMTP_USER=ghglitchla@gmail.com
+GLX_SMTP_PASS=19A6C38024FC838884172E7AB7EE14E8
+GLX_MAIL_TO=ghglitchla@gmail.com
+
+GLX_PROJECT=glitchlab
+GLX_BRANCH=main
diff --git a/.githooks/post-commit.cmd b/.githooks/post-commit.cmd
new file mode 100644
index 0000000..cc2052c
--- /dev/null
+++ b/.githooks/post-commit.cmd
@@ -0,0 +1,5 @@
+@echo off
+for /f "usebackq delims=" %%R in (`git rev-parse --show-toplevel`) do set REPO_ROOT=%%R
+pushd "%REPO_ROOT%"
+python scripts\send_patch.py
+popd
diff --git a/.gitignore b/.gitignore
index ebe2f69..a54fb89 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,3 +20,8 @@
 /filters/backup/wave_distort.py
 /backup/
 /filters/backup/
+/scripts/
+.env
+.githooks
+.gitignore
+/.glx/
diff --git a/VERSION.json b/VERSION.json
index da9d96a..7e6c325 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0011", "sha": "74beff39093cf521ab878c6c5c0dd0ef6ba018be", "updated_at": "2025-09-28T00:11:39Z"}
+{"app": "glitchlab", "version": "2025.09.28-0022", "sha": "2c8f5b1449177c7678a505739359b28ddde50d31", "updated_at": "2025-09-28T00:22:10Z"}
diff --git a/__pycache__/__init__.cpython-39.pyc b/__pycache__/__init__.cpython-39.pyc
index 10e48da727dc9c456fdb2614ab3c83676621ec51..00bfd134deb598f778a72468f5ddbca571bb7f6a 100644
GIT binary patch
delta 81
zcmcb?xRB8~k(ZZ?0SNwlyqv)Zq#uJg$N(hh0K~;CKq7@9m_d`#ZzV$!NEk{?tcYa&
I4CFEZ04gI4lK=n!

delta 143
zcmZ3;c!RM%k(ZZ?0SJ1^4`&zy>Bk@rGGGF79Dul307#@Tq%fv4MKPo>MKPu@2Qz50
z++s=2FG{_|o|c(Yl3G+;#cH5usAu4($#jc7K0YxgCqDibcYJ&qP%1M&FFt-HLlG;`
U95C_A&Dm<AR}gzK$O;Zd02Qnt1^@s6

diff --git a/analysis/__pycache__/__init__.cpython-39.pyc b/analysis/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..3dafa3cf6639cf0e243d5f5dda233f3ab36c916a
GIT binary patch
literal 170
zcmYe~<>g`kg2McZ86f&Gh(HF6K#l_t7qb9~6oz01O-8?!3`HPe1o6w?*(xTqIJKxa
zCM7>FJ2fVtGC3o$C^w)eKPxr4q&Ox$C$l6uBPTH_z5pVG5Q$05OU$V(&Mc0JkI&4@
bEQycTE2zB1VUwGmQks)$2eRlh5HkP({V^>e

literal 0
HcmV?d00001

diff --git a/core/__pycache__/__init__.cpython-39.pyc b/core/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..d1f1fb6aff0e4250ee311206ce41d5c1c57205d9
GIT binary patch
literal 166
zcmYe~<>g`kg8KZ686f&Gh(HF6K#l_t7qb9~6oz01O-8?!3`HPe1o6w;*(xTqIJKxa
zCM7>FJ2fVtGC3o$C^w)eKPxr4q&Ox$C$l6uBPTH_z5pVG5Q$07FG`JxkI&4@EQycT
XE2zB1VUwGmQks)$2eRZd5HkP(Lf9*C

literal 0
HcmV?d00001

diff --git a/filters/__pycache__/__init__.cpython-39.pyc b/filters/__pycache__/__init__.cpython-39.pyc
index 5d5a22fb7a664a6c88972c4d8d3bcdf8a7400b75..bcf1d2f4924ee039d42daeb8f2a34ebe8ed7fb29 100644
GIT binary patch
delta 22
ccmZ1>vO<J6k(ZZ?0SHnVPiIWo$SchS06F0W8vp<R

delta 22
ccmZ1>vO<J6k(ZZ?0SMwlPiDw$<dx<E06FCZ?*IS*

diff --git a/filters/__pycache__/block_mosh_grid.cpython-39.pyc b/filters/__pycache__/block_mosh_grid.cpython-39.pyc
index faa589d95b4cf976e238e14e7d101f832e4a7329..4713b867857081526aa74d8d723d060f367f5b62 100644
GIT binary patch
delta 20
acmZ4JxzLk4k(ZZ?0SHnVPjBR&rUC#pX$1@b

delta 20
acmZ4JxzLk4k(ZZ?0SJ;aPj2L%rUC#r!3A&t

diff --git a/filters/__pycache__/spectral_shaper.cpython-39.pyc b/filters/__pycache__/spectral_shaper.cpython-39.pyc
index 9f02ac4526233d1acb93803d3ec3a2841c236597..5a6c1743cf96285a243fe7ddd356097feb02bc37 100644
GIT binary patch
delta 282
zcmZoOYBS<a<mKgJ0D@G;(;K-nco?H5m+(|D25)}Lvy72D1SnAy3L?TL&*Lj(Ox-NN
zZ^0;#1`<gJ5g8yNXmW&rJ!9tP83GQhjA5H^igGeC7EgXGW@#A=l1>E@x7afhixW#q
zii#>gLYW{!5k#m12~CM2J`g(_MC5>o+{vNh3ejO8rYDHV0}=Tkq5wn`0*PD9iMa(u
zU<Vq3#Ed~i36O|l%Z)ECNKL-QnqOKHp9XOvCrB1daD!M`lP`!*Wvri^CSfN4cO%4A
KS(CR&1OWgbWI&Dp

delta 282
zcmZoOYBS<a<mKgJ0D@cLCpU6u@G#z*T*6bq7_#{-&oV~tP@qIn7>Ed;JddxCF>SK|
zzXhW}I!Gh~L}Y@9;K>mJ_KaDZX9zg3GKO!yDay&nSTgysn5AV1NIDHj++xp2EKV#b
zDJrT231xu@MG&D5Bs3+8_(1F&5RnTa@+OChD@2Ebn4TaaA4C*@h(Zui1SD=TC*~Fu
zfgNZB5;F!7r9dKzEjPZnAT{|GYkp}-d>X`woFG{+!3|<%Pre{Nm9b%RnuMJI+>H=d
KWl!EB5d;8-<w5uW

diff --git a/google/credentials.json b/google/credentials.json
new file mode 100644
index 0000000..e69de29
diff --git a/gui/__pycache__/app.cpython-39.pyc b/gui/__pycache__/app.cpython-39.pyc
index cedeb8caea873398e80ead143e8c9a8811473cfe..86b105dd6c4225ca2bdd7605beaed9137fb3d551 100644
GIT binary patch
literal 25791
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
ZWUYvYo%4qOc5ZO^y+-?+%nfDC{|nY&Y(fA4

literal 21838
zcmbt+d6Zk%dEeUrJYX;@hvW=bkRmC9l19{GNv2s@5=kwVG-5<ril3$6VDR3|U<RA+
zdqWa1Ms`d(QG7yIj@^^SR+6F5X=}zw>(oh`q>h_-$!XK{k2-13>1)%Z?vm1V?bLSC
zMsb|}e&5A996D|S9Nc%`-Iwov`$chdG-Kd1{=P3Rf23p>|AjAuALc${7-sl)EyM5)
z->eu_(=$!Rt%~JY^0Yl0PrKq&6JDZ|m-JFdb1KQI>$%mmm#${KOeb%|%eJPGo2ZOd
z$Gq|Cgg0p#FB-LjjuA{X-)|cH`bj@^#qh>`*H7a)`7Wbo9XDDNsF$g1t4@2<QfH6U
z`E;kw-G0^|y<&RPozgQXJyzLX-Qn#tjbO$fzl^b?r#Y$he@(-iHI3E|<V*y!mo4VK
z3p4X(-#uH)=;v{x)9YkqS9Q0yTk6lS{_AG*V5eWp+dVM8smh+}UT^PE$!B^c_YRcY
zR@qnG@9iHdd7)Qw|3Jy<O0IgqJ1|soqgV34K*{ZugVo!-+lEU1cCX}Z10{D<4pk3(
zhlfgjyI1n?K*^nzBh}lz+oh!J((6|9s4n@0;m`Q9R}3HP=iRRB_`Cew{+>51f3Lsq
zisK#i_xm~j0NxM!x8XhSAMy{sVfsh>+wpb`EgbdpXdxfCD|cMBy*rU|%)bLEcXU$j
z^6&KT0u;;zcl&dz*6Wt~XfSt~P-2}k^2cuwX7gq|QmobLQ86mlYvDZJowLPgId8{y
z6s^XY#d0O^%f(84Db7@bFf1+w3-wERD^3?L6w8(3LM4dpr69sV82*@eJ;hVtAhKkf
zGp?KS*A2zP(GT7{bLzxP?+gPKzU0?ytHDcWo2BKVs-9K#m7o-bFD+HdQE3_76dF3I
zpYqbuTKT17qcPWL##1U-Du<D37J8!^Lq{PFAcml_2umDL_ro~zWPr?#jJ9#ve81^q
zpel_7EQI@X&^)75U0uhb)QZ)hKW;UGB5}6YD;8h^Dc$}UM+0LRU8PxQlp8^%Tno;Z
zl1T4<7#~`rcDHNkCZCM$a&;-TOVOn`5k^5HjMIx)@xo#;jN()^h*Y_RG(T8aTPk3G
zHjPeAqJtgybqB?F3@U{kjj-UY*>_`jFXuY1xpK8pS5e^So_o5rXRE9ndk_2*Xk+B5
zD&XK$v38*t;?;g~&Br7Cgeo?cUnmC`@sfGA9u~``XUnxR-bT-=APk~si#60!NEmsx
z7_OdLuGg{mc+H+I)`H5ZdMyer-3&_HsYeJ((})Cyhg|{^HGK=fZTmKW*-`tEHMGU7
zWaIZVD{@2H#)`3Fw#{pTiM!iu#crYCmrGHh5GU6felZFF+)fx&7GrDm;-*DqVay1H
zPou?e;b*kA4~~7Vn?Ij-SeRggmNSJyweGJ~7|#|8udEd-I!7Hs69b*d@gQ)?gaDp;
z`&?7r-^|n+b2Y!HRI&NyWIvv3=jQ7*3|vj2Mx0bZw5Do9%Rx{};3p9OFd}V`qcuZi
z3Gsyf$Xu~5Tk0s5$wu5+l{oUujReYKwXfM5N#<NLvEuf;Vv{%i5<xx{XUbu@7DmNd
zDTu9FBTjWj87KUx*$CpqTDcZI<T<5Exe+G;!AQ)TGTedL%c*i}jY3o}tUdH3nhu53
zny%@XGx(|dkk-oJq+`m&Q?ZRWHq30OJCJqLlnDVcWqrsalgIorCZG?wrS3-o#ZuQz
z^%lna2ueniE?g|v3JrAi9CEv7>A`_o(l6e7A3`3HUT>)*W5wJ6z+N-gvC!&JWOEc7
z&b3|~%WV7BWpf?yxsvb!)V^~Sl(o&JPOSX_TFd0{IbE+dzx44+t(jXbMnuZFh8(Of
zeCFZ_DR56dcV_;D6S*gzdFuSBC!cxrvBKHs&zw7R{#@boQ_o9@d-J*T7mLcT=Prh;
z#TL#T+Gqu>+^KS~P!4o6=<08PnDv-K>F(%CfB~0twQ`UHhQ?zh$bIE~AIYsn7wf9k
ztTyvf&fC7_kXw)a&Bt*b@R4d1RZxq<*bOdW7=`*O5Uf=X<5W<)P*(Mta<Rq&2ys%1
zgmI#}>X!*zHp+O3#qy=V-wYmm`~b+b3hZ9+gT>-nB?6%$ssm0@&!fqZfM>W_bHa2j
z*Bmp|BX}<{aqvS3#K#PuLD)xep8cc7B95MKUvWLhcl-o60P=W_mmrUaw~Rl6w<Pkw
z#erKG^T+X?`cZ(O=K^{r;`G^~Dpnt_tLoa1pmkYp5ZExPgDRC*08ER_s}xl$hh+lB
ziWC4Ux3K2dFBXwqE9M$?AE)~wHZd$M2i0P<Hnh7WA}Y63&!I{feetInwQ@0^D^?cj
zxv;rZLve*()@rMzmGYd_EOlngSqq-#JAP((5Ru5Z+{4vvt8EmlGEPnb95X_vPoxtd
zjcbiS2^x*33!uXVP0$LZVnuT&=|Tx~Mb#@|JX$ENDZ+u^<-D!fSDe(a5pUa~_H~f8
zLZMVChGC(gH=k%h`YR(65^M}JYbNn+P4!l~M+Y>5Av01UUg&;C5n<I+obevyw2ckp
znsM5AIlFGPtqt=Un1febAY*I8X1oo|Rd7%$K?=5Rx9#xxD7li-sQIe3;u2>NLay4B
z7=Tfd8|k)zvQFDUE}%y8-K&miM47gI**tB$Zod38FInq}^<+Egr)Q1zR6DsbLYTT{
zt-BJ>qJ^}?MiI+MpH4gFTj(>}P5|C)f83w&C$B<^X}kUu2*=l>(Uq}iyq&&m`rEFW
z>m#T&(RSJ+{`6IAJzM(@%54WnYO2TD8HOl78BMj*?aT#?Ng-C7kepmQ<B!ckit%?0
zw6#sz+8Ir^Gf17e>Y&X}qRm-p^L@ItXnQ*i5@({l1+<5gLCoJ9&kkt=Joi-_wO3Gk
zL~4JoQ+sEx_J-8n^F3<c*&TnUzb{LT!4d1;_Hy>^tgPEU;qSZa=B&*4`|v#=Sbv23
z-cFq~Ub(=X%paUzBb_?>m@2O3S~cKo9JTI296Ymc%dLIsv(1%0RmcN?9Wqt1dGQ8W
zPB8XKQ0e8mik(K$za(KZHZPqA!{XrVREYl?#hR~3@YGob;|S1<5c0)Jy$JrZgYDuJ
znktuqP`H7-b%Q{zo@MZZ2(Bk$Th%Yd$x^+tR;_u-Fe;Z;oBgI^XQ5uNV33Im#mX93
zg4n%KRAmt>oS?Q=jg8n<K@rkHrHQd;IhS4u@WtTQ;-u6K!7$gN8>HW0gi3hCiHl`F
zT3$j_K43VQe1nWjYy}suTQX`H?sd~kUJS}h%Tazd9s|u^tQShl<%$n<!P$b%s5ce4
zzBo~;1Yp6=Fg{uUwy#$%1ck5>loZK+oOq_V5LCFZrPVm`I1y@`=3D}W(F&o7oh4QF
zV~Y~jV_1NoSbG6YzQpPyr<Q}#>cUzS)oXG39N7HY5;F+_v3sgsU8q9>i=7Guo<-^K
z4Def1y_4~Az0yE=i{+&?734<+$;lQf5*P5c9O)XPW;u4sQBaM|8pOS3L%o1h^&+!u
zEHc=&NL4nIy!65vmZboiQAfe>Aq0lG!_1gTD+3m7m+4r0%qepk-+iEXIZ(bk!MtV6
zgGiOo+6Ou~jbCe9A7S=djUBS%itP@ub3~Vv%mihA9uYG1Koukuh+Q*l){?PqYPp~d
z<OX&MWCN(OgG7N`KL}*!tS8zDGG9P?)&`KHZv)w-TF(Qik?UQI67A$=vu(GXlSb_!
zq$ZHsj({S2sRxm2BlRaDAk1EBHUi4*zP)I?a<5}V>E^F#k-wePExrrs$MI`ZZb{A$
zO_7Huh2J?+g?)&S>b<;!T%m8wf(C48M%?;{^@@Y)w%*qBC@H%S0Ou-!WwGXttM@W_
z6FZwZ$;B<ztBr?0!tBEcT8H|(pik1=$x0pcGkkciUtBs62o<2qXXF5=23yg`f{+wy
zK8k=W#dIwJ-SnADrJzAIL*CUe`6^0zF40P%T5QC2eGO=8Rb57MY+g|BXCuSoR{_#K
zj9<750l{tzAV*-c5a)LSw0Od7O>CZ0E5q~hZqEK?pa)_!EirJ-yC3puJrILR&1j90
zE(^uApaI)~4K<sG^oA}ON$9=KLDS^}*j|2Z-EK7^&~8vx02z3E=d!7uL<s8D2GB)L
zI}s(K<RZnan(%Z+J3%mg5xNMI6q_Yd$bG{{?1F(OWPvLv<vX)R<Mk!*2mR6juwycw
zjvfzybqs)Yto3QodZXf!rh@~pK($ji7;ZbYlGzv$9^*Ao^fahYdSw*9u|*4gef^bx
zhxoXkLi|mMPqdROlR`hokTU@aYOH5`7u4KoXQHXgq~AyV^!iBcprmY*loNgiDHD=1
zEh+EtN7hH$?gr@b%6NMO6g~TfO(`6`xG!SfoCWlP?VHvWdHGRF(n(G1ywL{v)3DHa
zO`d)9`A45U=Q-!jo;h{XNg^_qlQfOU5>HZg-GrzMF5ts*egwE6_k95Qpao=()ekTj
z2D&(NlCUF(=2Og;Lvu$T!iH$Tz}e~55*8EV{%a0VeTcpO?VCrYUPsz5bcfU-!CI)^
z##B;-{*e_5GK4dT?(;hoFsh+`3_+X%3tWsM6}w&bS>46V_b@XNtu-ovtX7<Yv=1^8
zdFimM`THQw$mUQU3gw)}&T6^ldt)y=`h4N+bLXBq|I~Byk3Qp#@crpC?|SjM=TGZ%
z$YFTNLQri)%}v7vv(jh;H9w#2ld;%bj2#)JU0+yHS2@7H!zOHuMG>iJNnVKAR!D?6
zYXiUV1Ofx7V+=?m16pN)K1~U2ngZR*LSnO^dKi<GtSBI+kUs%5lSEo;=Pf`WpH@fE
zu)3YWQ3P=cI;MIF62u`UU11O~;7GtjXaS=XR4QE|Lm==;77=mdQN(=wL>&TUh?7l@
z9UL21Oeae-^da2iV}?_}V0~HAx85*CnuMHiB@4w_!cRhh=8#}Qj!gNkNR??ngSQbs
zD^jI?8}-L1Q<Bd|-lRW;H`m|hPvdR7zXNY+UzgnJ&)_ZN&-%O2_6RlFcxFYXZFr;P
zdGS8xAMg+2Iqu))AHs9OKkOgDbJD-vKZ@s+pZAa9xeYzufj+3mcD!kS&cE9~4jK0z
z|6aUr_wV!XN2wkDTl@#`-045)KZNIu|5pD5YQ4=riBhxv-|`<u>MoIpcLSrmJ+>ch
zG+K#hb?*EsI8H~^>(P*O)}_NXR}tolVR_Vi4f5z~!c<VFV;YD%#OGRP<Kw*mJkRwl
z8<*|Nd{0I0N_r#Xr>>#)N~$ozQg~*|`Z?Npj&+{n(S+2Sgp{A++WI4yHza(@_ixxs
zMl^-`laOa7-bkYTZPF|3Lx^veaK~%L#!gC(c+P08Cu&$5v;L$&!IZ!4ihB(@rcUa#
zq;B7ox<gWTZc3ez)Y)#T$SAw!z4Q~Jtq1!{wmw=u52Q*RhyoS{M|mo`B$)LESsW1$
zpjL<4@{jO}&mX@XbonO{@mw&rL2W5ozHt(-g4S+eE5Pq~$!Hl2_cHVyusuY9mskzU
ztpK{5)CHg&@D?6aw}B7qM74pztoebL4*VrD7~!fSA)x-XucB#<oTSzn+JU?34-cVd
z?7El;fJjY|^0AJP(7T#LDAMb-LLImX!iyPziX7xv<=pbf#_q{VvAW<FAHKnKAsPDs
zc0I+wAf3<!2gVZqHO3Mau>?QQ&i>)hNYp>V>sNb&NSu89p5r$+&-In5at53#K^sOJ
zYd%h5FQa-D^UOjqyR-x?c37!Lx9sbG_WE*8KK|DKudWh`5}5i7Te#I!zSeC%ze_#F
zxZu>EMGO?G9Dzb9#*?s~K#8o#9LFvcI8gzn6g7ueFR38k)~moz9i5%3!P0_2U6*DE
zEYSaziqLh%4)kF~^$0UEeZbM;ST~`xxCAub(L6zThWIzue<jPpcW9&*AQMt_s>UM)
zE%8(#8KSO!sT7-Jf}I5rPMih-Db7p@DUf{?dcY}v5x<V~MfFqG9J7<4P0%yyukAV(
zD4GkJhVV@{LlspLR4!v{R=JfOgvTM^r=}o*pCG`qf&e#&xX4V(bH#2$(z*)dN98u+
zKz~qfSWsU>3DvfshNAk~f-)QEX@$xsmx?J#Nh2i%l-5bvaEYcQXM}yMr2Q;w54DW`
z(DG;-WJ_AM(ejv}ArPf2uCCE$Y8Sl?q;`5>?l$xQ2DI14G~Pk%dhgrup53B<NBV~v
zr_;ZKwsxZI=oV$6qQh8cz_#nLCQx=3Wyf^c4!R`e;pRV%NGgIxp}x52Igi7}2Kg-k
z-DOZwzlA+m8%6LO5DiRpu%3P8eSg1|JO#P@j_1J3{R`wl2UD+B0ny$_u>>Z9YKFR6
zqrLAOa6%3U6ME@fG3-|b%Y5ciIRc2W0rf8tcn&Rht!?M!gy-~`&m9G_$d`~k^tlDH
zP``*$`tS-K+yW2%8A}K<JRrc=KLcCf!^zHA1Sw!BZ~gv9^2>kaNZ#y@<ju5KuUB*T
z96x@zHTrlt%0)1Z;QUc-bqc!TKtYclL=n_5;o1ahoyCF%QSR}2#SawL)N`H;DvdQ4
zS&uH@_#!Dkt}fs;cAmusE5S`rfl(y`bGz?DIUSaYe$aW*yQe<I5q+A~Mp-5d$WLP@
zRgGyQAU7=xw19#3Ulz+zoJLMb1{zN@Dpu728W+1rEplY}q@WbfsV+dfldKX&1$<t>
z)_a*M`qcAe+A=1k=~*A|d;uf*27aQXH_Tn4>6rqKnL><M#T5)Rfj9nI<C`{lh|409
z;i8=)h5a4ClpJ``a9kCgKNUACVhhs;DKen05hMg%IE<3WO(Fz}@l!p7!FQM1X_SF>
zd?mF-3*f?#OYM3}T7V@*x6nEorB~R8OO6Z270RPR2JacPBD@#-fhGXHEYV2w^IBpR
zt3*b7adgJ$0#QO2fLhS-`cs|JWq}yCp|w%y!EI>~+_S%vh!JyV?hJCr26ATyYVJbb
z_)U3`%%RuceU&qsL@QHhWe-YD;<wG;d)1MC_W9kGrjZXW9NK%%=s+)hJJR84;vYi2
z9sc2~Sl_}<#CJ+L_5sfmu^qraNVEc<i#S>r3NNEDTbn}P(|m_t3R-7c#1YT>dC>xV
zopH29D}|uN&PwUM*o|Dh7rWub(%H=o&SSUi)n3H*Zc%$L)|m>vz1T<Fzk@wvE%(U?
zE#*b~Xy>5j0^`|_a{J*0^CL2@{W31RF?FcrT&MPLbw<cO2ovnXfh?l?$Wgz8Ru3TO
zz)<~zQr}j|f%=42)=&6%b?P5%C#3#u$hmE({vecdH#C$V+O#f*WL*v;|L_*I4@>S5
z$>kY20@+E%4Sm+_e5c&f8J{jo!~bD94M!nmb<5_Fdi18U$9iRt`Nw-@??CD?mK6eb
z&wQMLm7&}MdtI#Lp<c%eu$0=skw34lAyj1s6$H@w2MVTvVnr?C^~M;2R_eBU7x)F0
zTE@F)Ei6In9V|jg*aV4m!ZPr$$QM-FK!IIvpr|DL2T1@jziz3g5f=)F__K_YvseEB
z0q7?S_N@^uhg1ON`pN%_1ztwrrAx4xhRa2mgl*kufqA5zuzO?~XUm>La-!ZL$?8Aj
zaf1T+(#L*^pI?1D=Z8=35%u@*$U87BD`0il0_y6AkRlDLRms!i=!sA=(ALD!T0J-D
zfFt~_?%RIyou|Eo_~Cd-?SbPZpQzLqiZJVdwIDG|Y5EoB?-X-|H$wjvzf19!L&{CM
z$&kbO_XuJe1PNvq$@4}?Edo_ohN)M`oR{LRfTU<8Qt~meU8pa!`oCfDy9_R}p)|}2
z1zAXSiSIK7?Q;W)NM|CQ#Why1FgtM$AQ8mlg)Z?6E8O%rBa{#{6wJ;n3nq2_IJI01
zMKv^{85kL)=g!w7xUJP!y>4<;TnH6)$g#b==BwR^d5I<ZFR49@C#&MVr2YwC9G3Pn
z2n$PkEhjttx_&JnM`vpZAns=CSIHh>Z7n{8@l>aJ=bZ&Qq*-_cFBQQiL=v6G;0lYh
zAbIZ6g>J0ciEYwTDoO-Nz+g!AyJ6+*oORI7*_PO1vS!xaW$rWg;7fg%^Os5ftQqLF
zrtOS5W>NDsVdu<!_8z1iLE0X3S0~I_`;e3E{92O(bY06Vtu)*P=fv2h9zgFyl%AqQ
z3O~?zGn~N)eNacx3$rUYz}gA_7*YnI<+LPQzWboTQX63X1<Tu=QfZWeCPnPcWVB7t
z`w_wW31VLLAsBG9-vs?yT`=BBXiY}p899E{p)Lj~DbOj}UV*KIa>3l=Pf>)?qC&4%
z+RiyPcPIH0_PkB^jM1k-4JbZj{OzFTu26C<5HV*4IU~KCWRK1=Zx`~ioAU%~?$&Nq
zUV{E{p<ofQ+G))72UtV(E(U@*R~Y*W1LDvUenTIuwifBhv_{nPz{QK+1bzP}M>M<Y
zS5ZLyGXzlC2F-AQ>k~eHgxS<0c-T74z280n0R2O7GY>x`RiZWoJxC=410qFESsbyX
zN60}oy59`d?D(Z_$4~){(oKUBdVyp0$QP4cW{O8v7_NIzOp78PS{WkG*6dL(XUE+z
zw^r*piROX1$%5+T{cXnn69XbW7}JCd{5})@kO64{?5P~NpeHe+D#4QLOxuSb-a%Z|
z9S}||aJz8XSsAis&XvZm|AUnTK?<rQmdq!#(Ek=@c?jSK&Z)xU>p2TiZE$a7TfT`h
zKY-QgaO9481ZR9qblKEqJ7)4bZgRq!vJS#B3yysImK!&8S~<U-@E_v^rvWFm!_o4b
zim)#{tBtcE{M?F#lWTQ3H}KFFZC#fEYdD?ht9I|)v7C4<k?RFaru^(I6yc0*xITPL
zq+Qsp{4u0uaAtAtQD>stwjK-Gqq1NGd7_bqUx&1}k(HK4ufZS;PGqO32&Vn*SJLYk
z1Ns>AceG*f?QkhG^8zT~8-z9BVFLLl(1_<lE2W9%34Ia?78(>55JRPa2|j}JU0y<}
z0>C>8euBH`St{^<68b9u*6mL^l|Tr-t$Tis)z2ch>GW`Gw(;~(lSwTdrUci*&Sbl%
z34Rh2@Hbt9pOfgKsBnrirRqXQC8dqTre_s`O}fH3sSnV52vHXLFwEBB0f^}nwEj`o
zHCodrp-I)g3FqVl2L8hj=goPD!g65bm?*TUk4_6QnDxZvSp2iqcbJmuIA|%Jjd+|#
zNqnev$MIxm0D4-&fc!a|lr#J##NY{hkO^{r{v%_5!9dVhUyS`0(v~^J8AJ>ayBUx{
zIwxeUJ$BZdvM1~@Yv`!-C$6n%@L=vF(T{iN_>dE1e?sgYMlaYS9H0T`F6<YKpBYip
z!=(+N43{>9AYU*dzwYC(ecbqI8j+J5skVcI$DAa*3m`JU)O=z+6{XvWHcZ9qE?l|X
zXaq*%vr!f?I9@T{PHl`|Gd3pRwQJ%H#$fdL<FA};C)H=8$+lUBYk?dM8iPn8rywjQ
zt|sW}#qq-VDG7a^4N><Yh`Q6wKQ&?e#kG%IwB1i}e7@VxV3ZJoC=lZU2=ZUe-~xy|
zc>x3@6&}Vk5=SsbtQa7l4v26D?T)lZHg;;GM0*4R9F8&sdK*qq6uQx3n+OB-#Q@ye
z-Ma=b2dDoz+5J#I3UNYSZ#pVH>c_p{QK2tfUwc1GG~I(HF)HKcL2W7UK{P&$Dw|G*
z(7&I=Zfg2>L=MHKGuA&7UEM#>IWP^xn~tJ6l%|DD>E0k!P{|An@*?OBj<(U-|8703
zyJTK3=iqPUcYN>ZsF`b7CvrE<mS^=G5d%+xzRb{@t0Mh}0A|&yThZ2y?xZk)Cs0zG
z!2b{H%qnb!p{h)!5=#9BgWqKEc?5A<UmB>C7vfPJ?YOzeHr!v;Pq5%!3`7YJAMtQ)
zL3}CuC;^(zI)n-M<<|W0Vj1S0{j4Ay$!8h+F$CCSctJ&C?$p*(B9g96m@BNABv1en
z%(^fBow1FW=QQAPras1|KF)w^tbPH3=THy788r}{ycf-ck04@LV?YX`H@6*V(KE0T
zJG2#>hwx*H{-VsECsX8~k69V;(acL)S+h006_|(xU4h3PW|Fyu{GH-9P9Z{9g@y|g
zBGn9V0P1e2r5pH76agJMh=&GPL2?oZX8<=(<CB~T8wDQUD`UA8)DNLB^6J#i2?`??
zjc~kiS>O;a34mt@2O#>Ro-T)j6Ldn~WOp6>GJTUJ1$wkA+4TW_eBBWrWdj~Dm>~US
z;E9>IoFEzmnxMX_*REVXAm;&J7NqxeX&gt=-xd*Br7jD)<e1O~k(rCKp!xm|kqS(3
z>Pb=7XW%PJz1y@utMdfG?3!=wKB|S{&IOer7EzP_4XlFJT9gnQ`t&f(4kT+n`?45G
zeDfrcKW<yWjHZ4Lx!@A+$3uON!9Qmp`z4gAw{y5RLKYV`rC;Rsk$M_XtG15H25OD@
zfaKW6I^AjlALORd#1N(+BoIO144C0*M2IOgh+*Z-);^53ds6{KNF9S06TD@(Gav+0
zAOwjfC>p<=J8J~Waf}k;>j%)Do|8~xu8N)~PcQ%#*A?N`<!{2Pm@K{JG16b=WJx>?
zoFfaTYzn{cW73`KH*E_iD-&g#Bmktk{ZnMd+k4!FUd@8svf6S-l9~<qbq=v}oHPaa
zUb|5w=d$In1XFXrBX~ZMNA4f(?;=(6Ljn)|fM*&8*uIZ?_!|SGx%2yi4NX|WF3bBB
z_Vt4d-bC=`xIP0QGBj+Q$cYrB`QkrB{#qKrDWQ?DaA-M+0%?9k?Zsn2EFyCDx~9?U
zlF}m5gDgbAkH;ztl>z&N@OtX^kdsdhaBmZsp4!G>JA)kvJex`;S(839_ia@Cd1Q86
z0$uv)SXpPv&DyRFZym69utu1z9a}Ha&;cRRWAmqYKt72Gl@wawS%RPg&IQLJ+(jsA
zou{&*VpZ*R5Fqg+1)|zW(8Xij7B_i@F07p3<bdLg0^IR8GUVq_o}x>317Zr}8)JOp
zh~1APHs1UMcrB2J)}Cl$W70R_7!SVh8hYvQS&3H@!e`-0K1+~TdcKwE8wvB4mlPFY
z*xG+=u2EZh+p)Qoh7JQhE(Qw?JQk{r>sBlMXr)5wBnVsfvAJV7tN#>J$8|#_(K}N+
zcVCB-wzL`B&p+`PxTNDKl;5TjczELwQt1rAD&&Y``|MNCs6E)0*kQT{8)c0;UTuI+
zU>l1~bq}hlUtwS4g>bokkvy4J<P9(Yb>@$B^@P;c5uqq<Rh(um82n)*BVO$&(dc>&
zMuNS2RvF&SMIrbaa0GgUKz<4}euscVx!n+Qp8Rgop&J-|NGCw}ArasUSFaHQ4@Sqi
z3_%RBa}Q!ZiWlsxCYHNEyeOPn+&S)1WJ6g6(zb+4+@HWT9$Y*iG(8~Dbch!6N}`(V
zKod<@;FzyLA*K1`4s@iO9|ClM(E)Ura45<|BQ$XgK!^RREzp5y4?0HX;UfuKa4RcU
z2<i)}*jk%wjf#D^OtUh~!!3u9lD7do_SyL-S_y$1ygBbUd*+E&b`XRVu7H!85m4a1
zrQImtnjh5YgrjyLSL@kv_1jRm)s0(w{m#I-ao6=8y4*wh+iOUg1SEwRYBB7>lEPJQ
zL+@sq`V@g3`1#P^ML^*;=F9$fq(6A*>Iz%#`=`<M@1sNqVPvq=nw3lbMKYmxe`avc
z+0oFRcgd(=398;SmVomw?oLAC0Y*f2c8}~jJO_k>vs?R+pMWybhS#{1q?8A&A`+C4
zSGV~BiEEd<c3VVgs2)%1lb)P!O>0$F=bA?cVRw$Lm*E9f+}I`ujtl&T=3jme!-UVa
z9M&wB7`f1r)p2cr3#SRS%^20Q>R&S^2wN7IoJyC~oMOHlqW($xJ>-9lD@sYjfVx>b
zo$SNe!L6v7&e^%iFg>)WsNS~*KY|zXCPcmvXHT|h3FL8tI4j80-hjs)<2}CQ#NfgS
zO0?%=m&^fe1=`q>RNp|u>gx<}FW*rA3o%?F#f3MSXP*!2&yD&y2)|v{B-_CbU`@oh
z4V=)m%HMiA=h4Q%bk4Sp>*)~dchcz;egdhO7}VFCY?6xFfhne%^IJ{PrVD^ewt(Y+
zYkhx;`R)|eQO4fMX&+<kmXrN5ihP%o9YciI+9>m6p*h?<U37Zu>E4UF1Jj+O7rj<f
z_4dnd-g(nx=xV0@7@)=J&*F~nIpW_%Unv~Oko15f2BjbE0-QKS3`sTwak8g!bWbAE
zI)stpfWp!MF^k$nY{WsvV0RdVFsJ#z79$ogf|M_7+aI$47grf5@*p0(PE(1^*5-rr
zHRNSEdd>IJTZ=QmYH#BlHkrL{z2Xm}oq-iU(W2!Y=Y=<oSDcN+CQwQ?AKGFr@u;xU
zJu7EwU=!xJ2``}+b%TL$__u_jucFBG;GRJ5yhrA93uE6+6C+iXEh0jp`gxF!;_f-l
z9{pKzJ%`h^XHc;Bh6~0Y&4J;dUnl;uAg9$wqCLSs5LB9BIm|rq&ZmGs>rtH?PUiF1
zbEofp$9=itYB2{M_jm|&M~G5KIPtCU!oNlCEGNme(A<OdUF}jwxkB7+z%gB1E|->v
zKyZj-AV1vtAVq52CVCv3C7MD2V~3Wsc{Sr+Nv8{fzBch1-&cqwaA}-ID;TjJLmRxk
z#JnW6jh!|i97`J)B%N)5Kc&%&@6raYa_TmKO7Ryjk=y*04u`QL0@dMlmLBK16>pK8
zSN|BZ(Bz)fP>iOnQSB<46YlH;NY5W3ODpR_O>_R32}#g>ATRabS@FMhYikTOinZ@5
zbnoUq9A`k?&E|9TOGw+#&DezqJ^D$2V9m5NDPoLQg<2B=g#%8k-TxBc-zTVJsEd97
zQ#@etR%**T$^w>8q6p;U(>Qa$8}i2qry&B!A1BcBf@Ho8>0byv;<PG~2|#+9S^)|I
z*MR(mPFeG<G04An)6f&%O`{e>s=LsG@XG3L#)wk!*B!ijdEdQ#d!07l{RvBmvg{yN
zOrso`hPsz4Cd8~y(f$m@@99JC1nBjQ+1k}bI5*p_hK?t}w|6{$1~1SJf#uPj?zmqg
zSd^?T@aX-RF<n4y++EW#++$j_;E$8QMLejNk;*&Frg&;mSfZAx1>29k>fi}Y5T9rb
z_Mo=C2z&;M5ERp_C;nTggWB}uO0J9`Hi8>-CcWwrj>^9$q~_HpxIQv}tcJFoVw)u{
z!9IlfF;P<Lbr<Gzj%B&{xMRLt#3gglN&XsBuOsjrfJ~_FLtQbQ>J9jH<a9w6$_FSs
zo{Y^GH|;>r{tt&_+GYxBt@aQ%WEwT7{g?yv(gqKGqi7$8WY>X8LmNY-9VaOOO4$dC
zatlcWIp8y{8I2>pP2wQj>LVR_#i1-gz{K52S!gk;djiV1-MDVmxUJkOnA%%YlJ0J#
z3E=D9OLCd!k81+MHnggUsy_UEfwd$KTfB(2?zDEnW`R*cI<{frOF}YAT}`ehfQcRe
zCdxFw2}}gbMQb0%HVR32jQ1-!zK$fEd=*#S&SA9ch*8?XrE~38#Wsz?1P&S<;lvn-
z_*C!Ex%2A3VzK^YCxZFnN~0X8i@ADq@e7~9zaWTwG^dKlYmL3w#NT2d5#k7>R{+j9
zl11Zs{<^KU^M#5(#g-rr_XHbFI=;g!k_bQ%uJSgt_WT1({XBz!fl$&12}zTDy^XQ^
z8M}{xz}*3+$?@*!NP44?TMb&R{XrJr3O@qX7^ewg$56rmR82s;=D^#-L7e*RX>$kk
z)f9eq0sf8(+;zDSlCuFL+z`-Fp6CJH7xBWymQ%ci_=`O7BDijAHjXV3TqyoNwi)cO
zO-TTU1>g`N7$@I^swDy7NCG%$k|J=p&5r>%pyU?d09J(|492Jd;Ba1*e~JKbASS>e
zqB6h&SQ{ZgZ)0=-I7A5}7&$fXCABh4fl)GKh1a;r9Ss@(%%ob(t*ZJe{wQPaym~82
z!O*#B@85$O0~*o(2Freb?_KWr0T3hn6?==nbTfX4d%Fi^_1;c%Z*ShsS)%yfZVo9u
z^Qa2@4<|6htk_8C?e7J=3~-sM^#E2+bD7|v$yRi7Da<^gcN^EHStdpF&=F=dlhMHL
z;UKrjWPsBiU^1*%Em2_L*;8OR^U(D`#t~hG2r;dlT2nOFOYXB8-@rh%l=n7npPV9!
zdRxjt!ew-5rflF=2Z+b7&PDDEMr6}@SURlwu>NZ3kf2_F5zpd<Ko`PN3N0e}FuGTO
zJPs_6-Fyd@2MdbjfrAqSls?WgUo~ZU@a!!QScplu{=wD12GwnMArk6;qcd+(r)po6
z63vYor3e(t>^oMZttL*CbBPlt6cD;BU=B=Ldv<sDc_`)bdp6y9)Yo#pfJ%yZL4A|K
zw-|`Up4KV#ZN5?sCvNYe0^Z~gqbMP%uQDLRt$v9C85kv}iFi%%0H_{*R6osJj#dX`
z)$}DwGAkTUcpL#-*6(n4jy*lL6W{!pGnR8F-ElYLx^CJ{AWXQ)v8joan{{`&lVfSc
z+9mvYAMPrT$0;mJcmxs3DL`BXd3Ql>a9z_E1c7Lr9_6v-J@=k_A3A>Nq2tFPIr31&
z*7;TGfP#FT|G(3W;rCOnRqEo?`m-!!0|^hzOY8v-3;i&+M@u2R`jf$53}Hq1?_<m@
z6!P}@^Yi)R{1dXpHT)9~{)9|%@ak<0QY?$VM~aqV#?^m-l!|b17p|f*Hm%nuo)>}0
zOW=<z8cnUn-PyOxm+C5*>;4~}A}^w?7#x=vpoPeJn`?Cc8&3#dobI)!W>61PAkpQ0
zVuGnqHt%4sjQ9fJA3h*HgmZ!zy2|5ORQ6`KE=UD3r39}d72=}JP($JbDi<QOSLlJQ
zo6-KEx*QR&cWCQ!9W0CMIsE54v6S3u3PTQJ``G5paGToeWub`w%-fG_jn_m=_XuA@
z29GiztO^k5Gub~35);UAPwGFUdzg?A5(r8DseW+547fI(MtK2x3^Dmn1zaZ6x^Oy_
iP5=dDa5?(>dUncBCni$xtC^ZAOug6O_fa>QG5;Sw{IUT6

diff --git a/gui/__pycache__/docking.cpython-39.pyc b/gui/__pycache__/docking.cpython-39.pyc
index 2945727edb1c8348d7b990031de136d190ab03a8..09ea924ecc3f2b68b172f35eb8266e1be8cbfd5b 100644
GIT binary patch
delta 22
ccmcb`e~X_tk(ZZ?0SHnVPiHLL$a|I@07CBuF#rGn

delta 22
ccmcb`e~X_tk(ZZ?0SNlOp3ErO$a|I@080@E9{>OV

diff --git a/gui/__pycache__/event_bus.cpython-39.pyc b/gui/__pycache__/event_bus.cpython-39.pyc
index 6bf87593ab31ca1e207bd8472ce5d10e19f02263..c24d484197a560d052df49feda3d86f5031a9d6b 100644
GIT binary patch
literal 4046
zcmZ`+&2QYs6`vuwU(#wVD~`X=8q<$7Vj(Zw7HA74HKNF>W29XhRt&*wxiptUNz`)5
z&5#>qiB%9-F05R7>B(?XNWHn&-U{Dp9s3XPn4WU$u?<k5zenz_R<=uNXNSYb_vU^5
z=C}6D%oM}*pD+HgwSJnhf6~q5rQ_y3#(31kL^8>J*5OUgX|DNNQ^U9J>m8$MbPCNv
zr`RlZO3hNI+$?u0&B{=2syPig!>@K`nlqeTXR;uRkC-g(Y0a9{R+(A)hOC-AowkD@
zjP2M9gQ#H^Q++Aur{!ha_wAPNrqkEl4ZG*Z*E}aqjePu#7sYA$W|!WvebOOwAqgRe
z^iEy{+`LB~`Ixw@$t8mqys1k~>eBd9%k~C;WJ#8>Qu$JsQ*!!|(JaXGSewCG4Qr?5
z?4v@n2$_;RE$6WEhCBnQlDv>fy_rd!mFFN;mR0z8F)gor;s){iy{LB;ft?b#ZmBSe
z`@*FMqScE;B0|{>RS+IMb-Wk97lAF5i-*b%ob4A+7PGg6`1<odi>TL%9Obp#`8e!)
z&Vq1SCLa6|FKoL}ta{t7a1gnc?X(v~F0_dC1<|$perU@@ijXNTUloloa3?f(doACK
zwnln~;<@sr)w_-54{qOV+*oclZmd9WyKZm9uChGoyQXkEUQCu{m~F7F`Ymk#?|<Ey
z(68K&d)VP?^-ro_5sBUH$9CYki(;q06COPz)m_h3J5hq@P^@-5S04RMcp}+Rwqrvs
z@Y++EwL3fZrZ)=NWw8|X17}Nxf#)Ov)C|2eg$fhLL!^%$+DDI^p0m|Q9RD<YE_Oze
zUw{4;f*cCh_c~rcJAv&eX?sK0gy@DMjIoGpc|Fnfy>?H`2i>~pd3E3JyDF+XTXwMN
zN{V_E*xhI=jA{O=K)qf!>qE_#k<&b6rl8!4-qG{^jtwWmC~=Y(Pb5N=Tk2xf7hTkq
zCy;`n3G*G%v9Y}b<z~NlEKWq?*vhp~+HpJFaTf#>ZiK31`xL3rcf|wWj$$kK!W!v)
zAUfgEb62$bP#W0M&NkImiJJ(U{I{uU$MKn8>UQhaFt9J{GN~|W^HJD>HwbSiodoF@
z^DX#%+1<c~;$cjZ66)@^UgV?(6|bqKh6=+tEh;zesld_D-lL1=^jW69zlh0z517Sb
z9&39v(<P0DWav_@p*SSWLRzp$p{n36HP8+*R;cCDDGRCSxt8w+WHxgB4ONBIGp63a
z*S8-oFRtH-kn43B25oo!Rv$T69klwk>%`Iertihh768pcmT2jCWqq^ft!H3h0SxM0
zV4r1qffrjA?K>)BV7$nuwB+;%OzI<vR7Z1v`_>37@7>FKoj@|50ZQ-RU&wm>zNx2$
z3^h{CX{i}#bqMQ67tQIDMND84vjJiiRVhXTw#^6p0z1$K+F^DUtg>gk0hMKf8v<%I
zi+9qZ-R-)8G<7wHTXmj>3p7xe^5G0-X=RLL-^1<D$uc*1GB<W|EYe8MkFfsUOTNJn
z*+@%6z<SlM5*|}R;Tw<sjS2bHEqiQ_e}Q^{XWD_j&o|j2yxrB4-|chB+nQ?ZvjdzE
zhkVzF4XF=|r#R2z!a(2Sm=(S%>>&=p!ahGJ%Hko99^k#wCrl-fF7J~}<z?wL7R(te
zF7^Mw8U5X5fp&$_StF}oYLD4tzM<i?sXeOh!p=2z|AXCPGCyDj+b+vfzd%7-W$d?d
zFg0KY(}UtZ-)Dz9<ztO~{FhAgzjDok!k|d|yNmTJ_{dq*`RU$=aQ_4%0v`wwsb%f#
z9BJD}&t?DkoKZszwu3$ZCTsCA@Yj>muRvH@jKZFB++_aV`*&9Fk6`pQST~;w{wgVC
z$5B$qj3yPR-0*xis+)RJQN5rJ^ipwBrYV}s%@<vzLY34`8c7U-Rdo(ts%Z?Sme*cZ
z>(t_-i{@o~P?S8XW0KScjH0=xQ7nUth$ZXK=dq0Wfp&PDEp&sT#zgH`Rz7vyjD(~W
zoYsy@$8K8bDldpF_fyB@nf+%#3}CFCcSF_)Sr5!u(u=w_fWd-aKZnkUHpRHcYrM*n
zx5u3@M9=!Weu#F9uGUYy`3<?#FsrbF##g6smp7xn=>oyB?W8)OE1k+>8SQxSmJ%ce
z0?1SiLppVQpr<tp$7*+M!z@iS^Cc429blp!DM!6U3XU862Xvb`R~qj5ZLCD!$H25I
zpVKv7=2QGTe2!m&i$(2hshqickyo{3_GO2Y+R1iDw`aC8SotAzItFPTUc~e0KI`<e
zm{3PO)*kB{hU8LvRNgfP2Kqp6IKwx_Ulf9@7#?Dhe3aDo**-wwL^=HUb>*<elDT~i
z4T=Nhm(-v-TJf{2d~WCRXu;2}uwedGxeN?gKN-mp7yu52N79e56Vu4kL>Q?kh<U=O
zgq|6BC@2aO>7hr%1X$>pz*WD-N<;x;Kv$}(SxrOutGxW*{5zQ+hy7&UC(12XmEpHp
z$jzNhg!(BN&aD50W>f>}GKLj=qAW{%ZYnwVe@rRl?BsDo$)s*rrWXAO696AOz#&9H
zy{ixO=&a;8m;lii*shVB85jc`?tu0Mg7!Ua4RJ&s^nPQQH{+min6)vzhd5(2^`1cU
zjJe8cKZxD9pHW4y!7&pB3(U}Q+dX>fd!ikKs*A{b@dRX*PAOu%;f{Uu5VT1ONnn|s
zv|`(ChXU*mG+B-K9C-1<*y5PscKYJhjg{MLtId_`Hz#SdeS)}wB#l@v-q?0G!<_t%
z_?!@T)|Rd>Ee_ct7}^9|d}jp5^Cq;!b{j0X<<Stv@Wq~Fh@N|_a>$R08LFsxBtubK
zzf_x}!pNGFU_ueHPJqKiZ4RmJDg+`T3anT|bs7K%jh~^~<P%^p6gI&(@LwT*6xbct
zvOvqMPAGdm&8rqT8mMdjq-0q#bSz7~NqhJ%4OeKOl2kvVA=}OIkQFTbGNywgB5nsZ
zQkyN!70+Cnt0{V7o+5)AJ&;WpR75Wob!J+O`&}>C%!*i1tt+ZtMa)eR{ZLfMDcCE{
s1y`k7+)k&R(D%Uu=|^wIH!};b+f-V9H}{c#K(dH7Qq{^_AVyXFf4-D7ivR!s

literal 4167
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
ZEt;20D6Ue_Yr4d^-*16ITNbyu^MABvLUI5A

diff --git a/gui/__pycache__/panel_base.cpython-39.pyc b/gui/__pycache__/panel_base.cpython-39.pyc
index 2b9529905df8c9ca9e24f554da8c0babfe8b5b60..490cef7e2c80e7e030b16ecd43cbff0ab61ece2b 100644
GIT binary patch
delta 23
dcmbPiG1-DIk(ZZ?0SHnVPiM5rY~*8=0RTXm1w{Y=

delta 23
dcmbPiG1-DIk(ZZ?0SFAgpUgNRy^)Vq1^`H|21Wn?

diff --git a/gui/__pycache__/panel_loader.cpython-39.pyc b/gui/__pycache__/panel_loader.cpython-39.pyc
index 7381d8f4bce70ad2e5663710238aa637dfe0bc58..840bfbea2d14efeb774899a003a94ce388e8cde6 100644
GIT binary patch
literal 7111
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

literal 2539
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
MT9eJ`S7)aF1!N$R)Bpeg

diff --git a/gui/bench/__pycache__/__init__.cpython-39.pyc b/gui/bench/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..cadc367a8ca926ddd1ab69968322593103616dc2
GIT binary patch
literal 171
zcmYe~<>g`k0@m`&86f&Gh(HF6K#l_t7qb9~6oz01O-8?!3`HPe1o11t*(xTqIJKxa
zCM7>FJ2fVtGC3o$C^w)eKPxr4q&Ox$C$l6uBPTH_z5pVG5Q#}I&5TJ(%}dURiI30B
c%PfhH*DI*J#bJ}1pHiBWY6r6EGY~TX0O}wt{Qv*}

literal 0
HcmV?d00001

diff --git a/gui/bench/__pycache__/ab_runner.cpython-39.pyc b/gui/bench/__pycache__/ab_runner.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..ec31d61bbab05c673e62a014079fc57585efb6af
GIT binary patch
literal 1964
zcmZuyOOG5i5Vqa!$MigQNCG4wfjOZJ(ylh)f>4MEAsi6eEJ^}OYoOIT_RjXqboZ?7
zR<fgR4lLIdKLCMd4msoxaNx{=6Blk4HzcH7_yLi4ls&s)g>cK|s&e^N^;LD!Zifik
zJ3s%j_q~tMZ$>!X2ng>&mt!CdF+4@lYQzz?GKq*CoydWaOljsuZstWEHg?X`&w?n(
z8c_pe%G|F|6f%$bFg97h8Zfqan}ri1c6sX%ffc@s`pu_s9@^>??T$+};@XueQ4-{K
zGUB<4vtpj4ljON5<7qnKLu{5EHxI@J^jpv+1ESCZRcMK8oT8dk_<i)*N42AH<uJ?$
zbB>&^->9h~3#X!B<yLM*6dk(@uX2|7I{Fk|MBzJhFxo$J70G*>a9{I1fWCjGB5-rM
zrLlPCmTGtXttVIqJRcS;%}0G-)6ulp(X^QHT+^{EfKH2qX;Mf{XNlU=!A>H1o@Bi5
zX&*F-i(I?A>6A<DszgqtSc8XXysN2VeD?_wFM<5*<6CbJ?n^G@fED?K54I16dx^-l
zMKR_>B?qHvs)l>hWG9}jRR3xQqcR=rz%BO%FfGbF=VD`aphI)D*q+%m4(tFyIK&hO
zxC`SZ7Uw}TGzd9q#?W-@@jrlB`FVks2z>qPfYeS+=igNjV~F>L!edfV<NG60yZH^!
zJD~sISnnL`Uk5z}{pZTD_VifaQGllkeS^Lwhxkiexy-wOYOit^F7s2gB(-mOKpF6X
z@)myOL1anYNKw^zj4S^!W<eFC7<f`SCc^tIid1m$J4SVg(fkq%Rig?Iar)fi0id7`
zzX<nRt8o);!YUj4=9VTmulBK~S;08)*ED`_-npMo^5S9Mv&ijf3V`6+&$trlP-;)5
z8IR@Y#EIJFLKLDOYByCplY+ub)CSaZktiOU)xrgx4nIkzCBJQ~wKIb4Oe~@X#4uJ|
zDybW{9}W3TrGPX?D$#F7;VOF!#Kc)+?F%l;sgjYatnx*(F>IEL%fN|O4SCHNx~nZQ
zw}@MjmyNMK&u(kh%1s~$P}0T3BE_HuI_Z!Aw{VNJ2*KoULdajlp?`MV4!(lL6<9Mg
z3r|`AjOi9hKLG=|i<hW|{2h~3wlaDId1z%9ve!G27Y^8AMJqgZ4{=QtRGW$%0``Cl
zEJuNBSk6`cBB&tWD|hJtcJR0%epKPO3B9#w8+mDJLwH0mQXM0+CTp=a)QVp1tF>_#
zFy*rjTQj#gT_N%=REQr=R|tlnK6JO{{`$Jjt9$c{+p8S!siODc-8)-7qwm>#?~^DH
ze7{TuXPWNu>1^(<uNS47ckh&HR;twkV=FFzgTyO_Tml043;3f{s<@bF{7^t$N5VMs
zsli7dM_!sUsG<EAbdZSAED@4Nott7*W}w|RqKH}vV=>HHT@+d)BTJk07CSa-!ht=b
zhAguz5$T+32d*egvCu)5OgKx$an169wGcBELbQwpWo0(&2a#vD7n<4w3@-okq{v?#
za3Ic^NmKJqA&_QCnqLE*ya)tY*a7HBNJ1!7AwbW==kXaV-h^2l#IdoD<9<i1gTh`#
znBSnic69c6vD|>txM549&8*c^FaFQ;hK2tsQ*COloOH$Pd2*(CdK{m+x_yMrpx`=`
ci*m|unD|KZ!T{a?AL-(*6NJI#;9P+J0SqSNw*UYD

literal 0
HcmV?d00001

diff --git a/gui/bench/__pycache__/judge.cpython-39.pyc b/gui/bench/__pycache__/judge.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..550257fc131d193b337b22ecab3217044b663b0e
GIT binary patch
literal 2593
zcmZV=U2hyovAbt>c6U6xUVjiS5MacIl$DIn7l9Dg1?6;iI-QhQr%NEpoTJfry1gEI
zJ~rLGI6KTDWC!sC$}94nWJ|n&c;^qqzu=zeCnTQo!Xpm|395R}9|yfV)z#Hi)%DR+
zHA%1M6BvK_>*sqvTp;A{xVSz%SllCosv|%+;WQ@&jVMK&<t$=$b|S~lZsgjz6}4b?
za<6Dd?V=NPif+`U<O9N8-g-fJOZdl5w7@;yenFyucX*fkpEAC{gBNbp<10Yv^F??D
zpSpaBFTZF-ea;?|;p%I&Zb;2SQkIoYbXJvWYv>sFy)4znd8eEj_kN~yihS1xg~dJe
zWB`aD5#<D|r(ikibxiOmD?~NX?@L+9`t6UCObH$y?ujx?LY0-HT!dOE9j1vAp?EIR
z2_6nuDg;-d2JtY@icGI>4PDcT<1#5k92-B5i;7Qj#Dh3~Hc9d?cG_{wt2B=PNF>C5
z4*vDv-OcTvDk0T2ugU|l{n0etOJwnptoB8!)%GaQbh?)(JMnl<x}t24CfW9mDAT>|
z{Rtn5_3>0<0^9H?7eI%))KXFgtBZj+KJQ|50zfq6`IsI-gdj3(tA68Aq7JUPjIQz!
zVl|v=8?wk#*{GZprnM`<>nnF8>NA5FML;0lOG=&#OI6keD*MRcC@t%Oo{oiDe_*5a
z2=F0;4VfBG3O$i!iaER(DDA*wt^OJynw(Nj&*+S5){utoJI9Q|Y<)1@6i&`~q6H+U
zWe+m`)k((1jAGU}+@m-iGKu%ZIFP#k^~R5pH%==qkVj#N3H50}<r{##M$76x-p5bC
ztF;jB<Wu8hrG}GTlrpY{fST?_P?TH(krchT7|Vd*ov_}mgGLRWpnoHB#*XRC8IhUG
z*{oFu=q*sZ$E3XD675WXMhX73d)hi9v$pm)Yv7i1r)i&%&)A4^_qVP`o<MdtKr3(E
zB(sigH(t{@X6opYAJ$j=4~g!~Ic8nmZMw%){rQr!{bkO2L;I%-O&4<E^G@UcoJe!Y
z+r7^F7;FH$m#y9ZnA`n?lx&0O;L2a_AG7z!OZs%M&1MU;pa~!n3mA!6&*DLbc)tmF
z4}4jyf1rD(J>A>y>%}v;1F#x2><p?_(`|YgY5ISlzoWAO(z&IB4Zi{#mR{27pD39v
zQBrR-?&&h`Hw!0(FE&dM2^TdyhPd&;Z0VQ4`;1+!%6oI_20>py&)>eB1*>hzYFoB>
zu-cx0SI^ko<7Ut-9<Y~G{<CRu|3_rjDsNe-6)Uyc3{DvTO0#&vKJ(BLl+<3+Y8<_S
z@Br>b<6>^%#^0FSgqOt+VMK>ANt4a+7vn^!I4$*BsG)M^YoR41I)3Z+#+z>q*Fu4%
zPi=m(zP|o+wr+**SEI?k2*=|5sGNoxG>M%gJqX9Lo`yT;N3VX*lXPz_OppRaLFq(l
zQG{wNlS5u7n^sF0em{hoTxJ6P;qIh7NcXd~%dNxdVRe2qJ%qwoou9n=&DBnkm01Dg
zSHBMHQN`!mp_-1$1Pa1*ZX;^9g*Qy=L`}e0d9704=2bC0KgsdrJ8C!=feHYnTuCe_
zb&yvHkFE2Y{?Ls&7l8sU3{=#;43zQaF^YUqYB?QO@K)EWS9n}x3VX$7Sl_%xg-#Wx
zNe)Fj7n`A3*{bx1#W)uQ@CZKdIM=l(J=xh2d^3EF1{yb!BW1jU!}%<pkD(L5i$AZa
zw=@3yZtV;=!>u}ylM>07G{5eFNksxJV@_)W->A}e>kbrj)N^;ZYMfk@#u*813z+G?
z4?S&+-3@BgMaqr8TS-s^#V<83R!P&|OH`t@G;I*INaw;!)6PnT>P;8+R5g*QFkJyH
zLP)5=#`X&cZTsPeAG~w_;|I12M6D!;R%bhu@sjaalw4wIA1=$U!z6DZ_y&S+AqW9P
z9wtX{`BhjLrgw~s-PN$&@{0-%;W1Rp@1VqY5quBD90)?h^#8T0E<`Z4m*WPosa*i1
zJAl6FG6oespdI>6)`4md&wo4zXN$Sa(hv_=Ks|PA&dnI>!%iQ51A2pg8|Dto0rRQP
zLePmnpR#|;AHzw|P;cV27{OP=?gZ{Qd^JdHC~^hC5W$-W?f@_z^f9<?5<7>)1}|F(
rZX>|1WTR?xYPDZ$WcGW*_U6vp^RJVi;3>BK2Q;Ls&Y;zC2i|`HbzG{+

literal 0
HcmV?d00001

diff --git a/gui/bench/__pycache__/metrics.cpython-39.pyc b/gui/bench/__pycache__/metrics.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..1c27cfedeb41063e79058fd18e1df770cf224673
GIT binary patch
literal 2253
zcmZWqOK%)S5bo}I?Cisi<Cxe{APNXVRze1m3j`|x#oSPc#N)78YZy<DcgLQ`rl*(0
z*6e8`#X;o81(ZX4%)fzaiyH^z6G+?;NPN|6V?%nh)m1e$)m>Fz)kbr3Er#{lw?7U4
z_8I$ygwxA~@F8Qo+6N<<<QdC(k8|QhCVIl|PS3Hs+jFrynV0)LKX3FJdC&`vY@5B7
zbn$r7f9lAF3?90@wroOfJr%MoJCHka8JdNsT%MJS553+Tq^3M4m+-|)@;of&rTC0>
zR}SfpU2fV@QItB;X<1aayN+=`Nh@vK^)%MT`KZ`6PFiT=ZDnPo>Gl1zsEnVLRh3{@
zi5{yW7Ub+`IoOd0hMiZRgQ;1~m)T>!&n4dxYKhL595Esfj~QoLki}F?gmxaWM|?|A
zj1L3t)&k%7%WNvv*_2PYZ0z%M>>|VcgWHP3_W(bv-)|xkH!kzdn6$@>u0`p;Mpsz@
zQ?reQ3EyY?oDTdFhu=f`;f~*a&bq>g)prcn&xLBk*ziJiu>bk#t?T_Sszg<NSr$7<
z|IThaj8uL{mD@?ItNtKMbv(?X&2ThRooM=laoXQZig?)16Rpy?S{?10=Gq`Bk_RJo
zV-EiRz>n=+s?tFb>ZH=)Xmu?s<0z|ctp00wNO2ufKwZzcd8CK4J34vvz&O=7H=c@$
zLDF?p03+1|F?`1cpw5uyENR-OP9eL>VwVTJgQvySMd<e01cAG@;u}bcC)2I1N|EJ%
zvg<)X*}X;CT?eDtGhU;d2V%m(J2e&DJ>V$pvBV%b+LfZ_+a5~pqWGeAR#@#`M2S%e
zXI5CX1czPUh+<?KQ57i_?WzWJW-czrg$|3d*h^HYmPzMU>0Z+H)XOCB2SyCE5t&vC
zkY_2NLe5gqi8G2Plu4!|GC0aXhtK2baP>NLhd<)1Lz^-;Poje0B_kch6!7sPkkFNE
z0=@&I**1TMfDoi>LuT4VGQ8T`_AK_V5cUUb;%grO<m+r>ZPKXS?M6MbaisginFO`}
zjL`2$5B>5LJT>d!fENL{7I9O4fcbInUC8a)m%eNako3NoG$$>5*PL?D))bv|(kWf>
z>+!u+7u@Gvp)O-L4V8?tC{EOykOn_|Z`aMiHM@Sh+3l!T$jk@4WSN_`OtzwNrbAT>
z)Fr&JRk5zr1#1`&%QQ}mAB{#yA+1~E=ZQ?C!UXrmQK8c;>9*BXvi4Gq#zFy;L>hM|
zEu?YC^Q-jI{TfYRcxX6iWccO_wcIRAU1=4K!Z@V{uNFa=Me{s&u`lwge2J^;(C*FC
zP`eBBw=QF_ZJ<@&gIc{$#G?E37$d+?ciQ6q3`R3e#RY=xjuNZ@u{5+GyH<z7&kzs2
z^MW2<Lhov?7E?aM{0f_RfPz!I=mozPO6vwZ1q7ifFN73;hfv>GZS#~i(5+fXf(wdn
zdC&4K-6rpow(gKuz{;;1byM;S4Ach=>XwySR%*+}llBQnEHZ4xx?EvuGW9kQ+l%c}
zgT>V;P5)6y<HR(nLqeJoy|!iJG|bBTz0R>POb0`QR|J8X-Q1CIWI2B#lC5pQ?woNm
z3?d7^8Pe!)MNyfJlO=^6Rx|VwbZ1wkLfg;Luc$WAds1VX4ktmV56BT88J_nXoZoYC
znY`x{1r|L!AN~)xGnlk_q%dv5QIx8RW<_-wgz**oEMSVB$3ycp-~vCID&jBoF>HXi
zH?XNIMCi`lGo}@WTVwo*CSj-uf9gDlL4xzdxZ71(7+>#>QnUpAP?@6nqiFIPuNdc}
s-C1^MY}=?U(Ct~LZhkWRg0;Mq<1D#BCsp$x9o%|}2hL)!5G-{50d@Bde*gdg

literal 0
HcmV?d00001

diff --git a/gui/bench/__pycache__/stats.cpython-39.pyc b/gui/bench/__pycache__/stats.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..0faf9ce9fa88c7b68c63406fda63d157c53ba258
GIT binary patch
literal 2677
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

literal 0
HcmV?d00001

diff --git a/gui/bench/__pycache__/templates.cpython-39.pyc b/gui/bench/__pycache__/templates.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..e32ff72d3e6f6f0e70e90e56f47d483b4fe2a5be
GIT binary patch
literal 2408
zcma)8O^@R=7*5jp%*-&$=h=colAW}g!ij1+Vl`TEfziM&m!u_fW4GgN;zYLFnJv2#
z2mSzO_P`#H;Ky*{fK+kg#9!dVYbTwiEGv<!iDSQ?kDvE-@X?WL!FB)nZ`a2Mmi4E8
zX<kS0@`+{HGJ*lIh@Dxv9oe=XJDC$X@N8wRd@I_j=eDD5vPHJZ4%sDpWS_X?fE<z|
z@&-93_g)-EJLFCB7J2)HL*60pezz6v66cW>y!V&(8raJN%z2@(Vg;9%@V<Ld%($Xr
z@e!e8B<P$9NfW7rFM9|c0cxM?XU|1&394p-BN_L4?e5TBe5sYjY~=GEVq6(vcviwV
z9Q9Abu2CEp0wo}V1m+X!^Pq?H@+ib7qo!r-F22_`<t$H9IZya3A3;RE9xHmQ)-m0=
zDX~zpAD117l9hgdw69Y8S}Ap8nK9*ip%)-FMt73Krf2ZzgH69|7%-*-ck#0hDKF-X
zPZBM6+d~<XDn!$D+IphO8(d7!`lkrO$SC)3gEJ7Tk&7#z#Z2|<p^lcVk*PG=)01vc
zS<|qCcn6my<-|AcW7cCQ(_s)a696H1@jJ`QLMU+Ox;ki8Bq`2m26svSb4x4u1g$|5
zUi>v~FCMg`)Aq;16E8$^1#IPQ1@{_eGh=|=0Mty!r^8NG+)&{MC!W`NQZVk9ofMZ$
z;fyV4bGs^qZf{ualHOKCGf9!>xr?7(O-yn;rLRv+qCUXTk+YF6JU@n{bVh+6LvF(W
z5)<B_n+!hGDF&+`4WJvE296aLUSg!1u&>~OC1A=AV^QQNEwYTJrp8bmcU@-Hu3(NQ
z0_W1lhR-1yt$95vifp6UYE2(^1T8b1Qr|-mh3DM`9rXJvq0#GwHZc5OVWzq@BsYa1
zvPm7n(wgb2m_p^L6?ldc%5a%>#*7o3Wq`egUSn>^6l`!roAOt&YimI1#jmE?sF=_M
z3X+OB&ZN)gbv>|oUjoA^@nc<bP+rFEt#-@i!-}N;sxKMRYI$8!P^8cYb!F)~mFF;s
zp{2#$VXs+kF{suybs=gxn)O<?pW|D9tr{ZwYDvB{b$C;l&H?>QhDc#ZPSpuXN_qdA
z=Y~_J8H6Sm3ZhhC1<ew48qEMAuk_nSPOGomi++n&%fk?{3T_>{S-KteS(Ck&1*h)f
zQyrpIm<iJ+>Sn&d!r1%3yYDk-O9t*n$I=j-hCG0sU3^=!9ZOX)y`oSGL;wnjbWQWS
z_O1FL+=1HH{Yj)7_?ez88Hdm~@ScZA%U*!BDhk+fZl-Q<HuV*dCpcUlG!C(43l68~
z80<7plgM57^5|%zMVi-jV~O@wr5YVHsv$att!dIT+EvvCNBeg$t~5;Y%NCqY3m0za
z8PcE!&T@-GXI}19CqruM1G>KSxCQ?U{bis(Ae8l^{mgo4!%1#mf~uQ5e)##-XAd4f
ze6(z7D%oNe#D1{^d}LUEe{s<pd?n%B9FT%f>EP;VdW}VXC5k7|mgHap$6<P%;Zagn
zQ|p<*WX1*~%G2wCqB-;%MP;Xax;z9gZ~|8|U2q~DxLLN)UogQQM3jtY@NqzsMCg^J
zBj^$^yK96(C$wzA28w+c89fti<94V;_RjKx%rbheQIPM$?a<z{;ooxX`nT<DJ1u9+
N*>!ec=8v6|e*nX*){g)H

literal 0
HcmV?d00001

diff --git a/gui/bench/agents/__pycache__/agent_mozaika.cpython-39.pyc b/gui/bench/agents/__pycache__/agent_mozaika.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..5e41e21c24fcdaf70c2688eb82dc3aad4f2252b1
GIT binary patch
literal 8493
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
UwO*~1|6l+9W$QtyT>8cT0!vaNEdT%j

literal 0
HcmV?d00001

diff --git a/gui/bench/agents/__pycache__/agent_ms_like.cpython-39.pyc b/gui/bench/agents/__pycache__/agent_ms_like.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..a80537b44a8e0f35f4c63303c2783c51042db26c
GIT binary patch
literal 3024
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
DW`oUU

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/__pycache__/__init__.cpython-39.pyc b/gui/bench/tests/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..dc97e1f6adc8cff6b4eef30a66fe3acb92fdf32a
GIT binary patch
literal 177
zcmYe~<>g`kf@ijuGeGoX5P=LBfgA@QE@lA|DGb33nv8xc8Hzx{2;x_mvsFxJacWU<
zOiF%Uc4|yOWpYMhQEos{epYI7NpVbiPG(7RMowZ<d;vrVArg~bni-RnnwOjrQ<7Q?
hR2v_knU`4-AFo$Xd5gm)H$SB`C)EyQ-)A6Z004+kFgXAK

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/e2e/__pycache__/__init__.cpython-39.pyc b/gui/bench/tests/e2e/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..611191e534175d0d617b7aee93d75518f750551d
GIT binary patch
literal 181
zcmYe~<>g`kf@ijuGeGoX5P=LBfgA@QE@lA|DGb33nv8xc8Hzx{2;x_ivsFxJacWU<
zOiF%Uc4|yOWpYMhQEos{epYI7NpVbiPG(7RMowZ<d;vrVArg~bni-RnnwOjrQ<7Q?
lRGVs)8WSI%nU`4-AFo$Xd5gm)H$SB`C)EyQ=Vu^h002@aF_i!S

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/e2e/__pycache__/test_ab_runner.cpython-39-pytest-8.4.2.pyc b/gui/bench/tests/e2e/__pycache__/test_ab_runner.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..64605b8f5533e2c580517dad80dd57d91330757d
GIT binary patch
literal 5058
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

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/e2e/__pycache__/test_plot_results.cpython-39-pytest-8.4.2.pyc b/gui/bench/tests/e2e/__pycache__/test_plot_results.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..a1abae4c602be620dbba88d3d751641228b2de33
GIT binary patch
literal 1360
zcmb_cON$gS5Kj6%v$LWoqKFR!W&6_V`dC?16!EAC;$>)PGo9X<9{WX-QD^NIalHzA
z@*o~|j$ZsT-hwwl@Gp3>lHOh0gPsgjrRuA6zDiZnWO=!dV0@T-nS8+reN#?%7~tFn
z;p?C%qBuiCtY;%P4TMo{4Q<>;oS_2|BXe_a=mBO@>n$4gD1L-|`v-iF9{5-es;m?d
zOZY4kJO<AF;eq9X+y&vEAtKNe?-&$QL+wTFh27v9QRf6|3}M!|HmLi~04A?7Yoj&+
zw`yx@HFj-pp~k5l{+{+|U)Vd&0zE@K6z+~!8w<=f!0IWhFd(jMbAk12@6OHw)1{Br
zQPj9Xtyrqv1>VAM;Pe)1Ob`piZX7!J8~ZlqNB`je3j4JD-!<3&;a~m-|A#I=<nv@N
zgKf;F|1k#yJwEV2_QqK%;z>qE(j3oHX^)a3p2!|yBHbXd;F~TP1yf!YLtEVg?i;eF
z+^8aABHeN(BAT+z0g2-oBk??_it*-s!g<2PnR6@Ee9h<mm%GN9n;N>h2Y~_5ii%zY
z^Ma19`rHqa7bzFK->mrkhN*kzThfG8O06n&RjIYjC6VT7G3J`~Aj#5k5k2D(;X)z)
zKpG{Nmd@3hmTAG%`;bn%y&T-G=Fw=DW+E-Pbh0ug8JB%PMZ!fym^>EoNjb|X-2aM2
z<E$K!EGkHz$X>+BMxtPO;Eq0SS{C;hE15hTZImo0B1&FV87YW>i0?^H<drTPQ;$ZU
zN-n7k+G<_uI+wf7m0@SuwKmc+T>pgFN!aXXe0M#33^nH=EsLi~_;4Oi2+JR`a+*LF
z!~Hf#RSW$_Lg;&_+a9V@^DtRWv=wz9eo)QjAzhU&Y5_MNfI`L*?BRj=3ctqeH28jB
zdV7^+hX9brqqeL;dt9hVz>?=I6;R84NV>ZiI}G2jWl+QO`^g88YM@gMW+Kg?>z!Yd
eZms6lCF!VBir%}CmvojTx6~hutHjUZf$<ABG>>Zl

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/fuzz/__pycache__/__init__.cpython-39.pyc b/gui/bench/tests/fuzz/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..aecc25ef3094b812395a5ba58d949172c6f1f2ea
GIT binary patch
literal 182
zcmYe~<>g`kf@ijuGeGoX5P=LBfgA@QE@lA|DGb33nv8xc8Hzx{2;x_?vsFxJacWU<
zOiF%Uc4|yOWpYMhQEos{epYI7NpVbiPG(7RMowZ<d;vrVArg~bni-RnnwOjrQ<7Q?
mRGU^>RTUE-pP83g5+AQuP<e~PCO1E&G$+*#Wa(!hW&i+{urg@?

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/fuzz/__pycache__/test_fuzz_tasks.cpython-39-pytest-8.4.2.pyc b/gui/bench/tests/fuzz/__pycache__/test_fuzz_tasks.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..d03b075059e8c19975205dd49cb962358cdbf9fe
GIT binary patch
literal 1392
zcmZWp&2Jk;6rZ==U9Ue98bByTAVtth*~=<UODI(m1r;PtQ6&U|m8;cyXKZh?AMVV!
z)MocWdPX^N;1D0VapuUM0Jjl0PC0Yyi8s5pG3v<g&70qQ^FC)CZf&&*uHR>Wj?aLQ
zzx82r8F)BD5)YA4LLnhORJ)Nj3<4xIeG6)h?c1m^l4k1o4q^>zz9fE&!k5IgZty-i
zcR_VWOa_vrlO&WZ(&%dGOf)@05?^38660M$Nn%ohgn|@Mz-0q)r*NB;hBT;g37?TG
zc(PkIXyY0qQtKr_+}8LdETA+CqcG8ng}a5jUD$<rVU*3Hc?IG~n%5RZc?i_enxU~U
zX-nGI%>{W*#E+<V3S$BMCzM)R$_(1tu=sUt@!S6_+G`(wR2C-s_^Yx&34OFH*;+ug
z+Y3Ns85Q$#R(Gy|zqxsfc7C?sA*DmRbgOV;K)EHguTIfgV7Gq2>6oOnknFPgY@ZVB
z{`R@*aQ2*W!2%)q4aE*C5@CziOAp#a5}J0A739e+Y&*F|hYR=`NBzvGMrq8u;UL=k
z@J{dW-Z$U+=dPh_9%eL8l^u=qIAVwx-hqPP7sB;GUkx5T?0+RNe4pmo1?xYaMdOgC
zk9q!-MN;%fNi3sr5)Oh%4gH7oN7J}JU|BToOD52EIGxWcG0;*VLvbOz$xOA5M=WD6
zCj7L6A^$-l^E>)Vu&P|!d&fy0g^4)z*5)^Fqp1t8jFS@==I3|!C$l40w7*{pdnbEZ
zI&j6l-tVteC@fXIrRvZXZo9<a-bsDufh!aY6$sZ>4RoPdPqRbK?)%7&G<z_ABNW&k
zSw-q$C}pDMf!pPJEXrgrSfng$@`x$(X&z^)eKwg@#f4n$1XxjmWlngMr<0H~)kSqM
zn8t~WGokFdX0;oLaXw9GWg3i<d=Mr<7N$(K0uc_G_Mo;utx}2e>~qd@uHFiUIZs0w
zU~iK!3ngmYwlbrfGG%0f-@+7mOS2uFY)6N#%em)o96s7Sd|V%D&!6~Jy7i&gtDa2F
z^d!~JYeTdU7Td@OIAB5-`8MnVzl#W_=Bx_m?;)UW2X(8wIw?%w<Lo;gODua0spb;n
z@8TV9BlF*1KT8iEp;tXZZ}rb5s?k&-HxkybomW{q$7xQd2|Lvvnb2R>2heT&3*Y~V
A9smFU

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/perf/__pycache__/__init__.cpython-39.pyc b/gui/bench/tests/perf/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..e04d41be3ab5c92bab64b3571a12cbf0ee824644
GIT binary patch
literal 182
zcmYe~<>g`kf@ijuGeGoX5P=LBfgA@QE@lA|DGb33nv8xc8Hzx{2;x_?vsFxJacWU<
zOiF%Uc4|yOWpYMhQEos{epYI7NpVbiPG(7RMowZ<d;vrVArg~bni-RnnwOjrQ<7Q?
mR9lc*lok^opP83g5+AQuP<e~PCO1E&G$+*#Wa(!hW&i+@W-><r

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/perf/__pycache__/test_perf_timings.cpython-39-pytest-8.4.2.pyc b/gui/bench/tests/perf/__pycache__/test_perf_timings.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..46313165d5f51ef234042d6aa828064536d84576
GIT binary patch
literal 996
zcmYjQ&2H2%5VrHT*`F3FD%46XR7ePNS+$gMs0tKSh+9<&aal#OvaxqJG=H+arMn~-
z+Q;C~J#s-j0B^y~H-v=5EA+%TVaq!5Waj%k_RQxbSXyc!7{8zY7_DQ3e(7Lw7!Vx7
z6#HN(qBur9T)mCNG!RCK)w6NUI6Vg#BW@&a&jrk+)+OpSDSnGQ`w!%!V-Ks&kVzt0
zlE;B$p+@JU2~Gp%5lrzNOoU1#k;D{V-~tus!o*-HUPmRS1~pevX-MPBoT1VzaA90v
zjOw^B*HCFutF#NNuuoCx6pr{Ntt*?_g)_j^(fGiaS+pUYtHunSAu$EsEvy;lm*6$E
zmm0up-=1OWem3r+vO$})RWu?DzAIb6whMO#6@CI;EI6sODT0pM$EwZQ8RLQxA-Tfm
z(d|bF4L`1aee-jA`O?GJ_`t){m4}b>$+jo94z{$n>j`C0=^4rdSexDHav%ibvf}rE
z2XN2pD2tu5kn0;#mW&dnIyvJ55@zF6GOk*O`9v}yNx;<#34=H$oaH>sl04wB7--TT
zN3o1jp`18_6+*2MG0Mg<t(KBuob`j4qycQ+BqA6vy@OhQRn-$^>1)n2uI`XQ#*;u2
zb`H0i1`-&rsSMZ`4-|%m<TiJ7oo#(+-OZE5V5bi1ZJsU$&%PkO38~lgXy1PaG6<h$
z=_&J1CgCXH$qCQivrr0u7)LT3#X+CsHS{0xhvUfavosv}S`guDohp}9ih+1hIuzY}
zqBbhUDs+B%<CHQ^cD55?Lmi^}U+^k+;n~3aK44x;xpO7?E#2ojskQIcy@DQH&OY!+
zf{r(kYW&0a66El<PTag{qYFiMtD?K}zeQA+T^(6zvS9A%WcMJ+=s0FC^fw_aFb{CY
F_zNx2CvgA(

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/property/__pycache__/__init__.cpython-39.pyc b/gui/bench/tests/property/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..59f1567793da0490ff85e19c0ffd4360d9c92b6f
GIT binary patch
literal 186
zcmYe~<>g`kf@ijuGeGoX5P=LBfgA@QE@lA|DGb33nv8xc8Hzx{2;x_~vsFxJacWU<
zOiF%Uc4|yOWpYMhQEos{epYI7NpVbiPG(7RMowZ<d;vrVArg~bni-RnnwOjrQ<7Q?
pR0~v5kXlqy8519$nU`4-AFo$Xd5gm)H$SB`C)EyQ@n;}r004AnG$Q~2

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/property/__pycache__/test_tasks_property.cpython-39-pytest-8.4.2.pyc b/gui/bench/tests/property/__pycache__/test_tasks_property.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..bdd54702138976d9ed0d226ba0025dc296dcdbf3
GIT binary patch
literal 911
zcmYjP&ubJh6iz0yKe}!8AV@0+MNm2*OI_<ltW>HuDFxBPG7@Gd>F#thKg`S4j?Q>!
zJ^Ckj=pOxhyyYqg{tKRbnQdz`<mJ8Z%}d_*CDH0?kKp*d^K;Ung#2>B_2FT#ixUQD
z1QAq`A#GMKWgej<^@lC$GM;Luogr=_nDD=nVOP*MBxwD?I<g;7yE2xB8<`d=GBS4P
z<!GbR!MTSMzM&EHC3$~Z6GJL;Mr)do+B3AGl~;LZj1pYQI;olQDu#K#^5Ki{1T*a1
zpOa$(uTAT`ZM-?v@6hWwFLQbHD>kRi>d&e0zq8w<ZkaA3OI2%5&*&+#^KtLm|KJPa
z80-hkE^B!#HAoIdTXvX?>`j=ZJceVQ&C(I3K0S;8q&6G(H;ZyRfZpc|XJe;<wgT96
z$RL2ASKDqJDHV;B#LZbzZaFh>W;^I<C%X0JiHx<=#;)uZB_GWaWs(eRTjf{`wuh*Z
zV0fhM8iz?fQ-W(*Xg*f?C{jF&QfZesM2FJB_Qs2*!z9mMX`O3(iy!7XjSQD3cqv(A
zFcY*bo66GqaW16w@VI4n_=4M`>%rqiu-M|s52Dww)xSr3Ps6vU1B4>arZPMz<4L5`
z1Dzkq*g!Z|iHRr3oEHn|KN5~-NjQ>OJP92w2=R{s6)l^Pn+T@hsv4|cl=fc3ek?Po
z@kt5pT1Jx=iITt}&8L!KPtd$@+QrYOD^%Y>ELgJLOF{Lr(|DaP)a);)q7;2CKkCGw
ygjbO5Twr?D)!e;e)5qTXP4E57Cl1XuHm5bxTr=ygxce;4#Z1ZP?zX|12lOAqBoYt+

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/unit/__pycache__/__init__.cpython-39.pyc b/gui/bench/tests/unit/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..aab5715f9e4de7714273709b9aceac89fce31267
GIT binary patch
literal 182
zcmYe~<>g`kf@ijuGeGoX5P=LBfgA@QE@lA|DGb33nv8xc8Hzx{2;x_?vsFxJacWU<
zOiF%Uc4|yOWpYMhQEos{epYI7NpVbiPG(7RMowZ<d;vrVArg~bni-RnnwOjrQ<7Q?
kR9l*tSrQW;p9!Sm<Mj$EZ*kb<=BJeAq}qWj{S3qm0F&M_S^xk5

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/unit/__pycache__/test_stats.cpython-39-pytest-8.4.2.pyc b/gui/bench/tests/unit/__pycache__/test_stats.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..0f24b4a05a9d7e3c4c5a9ce4c41b7c966b76827c
GIT binary patch
literal 1909
zcmb`H&u<$=6vt;~f7(e~N(yR)1ipZ}QnBL1`BlYGsJKQIh>K;kT6@;^HtSt$X52Pm
z_tNrb^bp_R|KNzYaN8>qC^t?Va^k(&b-D(QUFm)2&6^*7^E{skZro@R`2OhqHvI+K
z-?3Bw7<3+i$%i1Ea2k_7)h(MDj8HN&`xeC!7TYtY?}Be|^9RyzaEsf}HaY!<c+MrP
zCnp{)EU5w|N7!9`8{l9XkHO^MAe`nTBO4^Aiaez`<7`56gBze`#xf%_U$NZEXl9+#
z+=kgsW@QfeZf1)wGgtnq*af7K*_k_LT+hs$v9UBEZf0ajxvi`Vdr6)V`2u2&f|z)T
zqv$0J#&ITFQr#L=YgVmQwGQm$ymsCvd4s#Wku@R;ep9)ys*yF9^c8&x<uXZ*M!{?_
z7mR@!U?!NAJDfm~nkRq4;o<x1^GgcNC05^KSM0baZ0(-=pMHFQe%A41>$um_?ye`B
z-><w@89Z3Uz^Oueo@|feXgroa4`UTH^ZU5y$deDsePB<onV<Wst={6M*SSIx1(V8i
z3Ih&-vWIfe2RSNCh;_8?YTY}(6-XHhRVD~$>Eo0GuPGd;Mt`$@o}&3^ex^dH{6G}9
z{ZSCdz6j@Hl+NaX2#ba<gK>zFViRWi!$lOUD3OI7r!ZL-cYQfc7ctkX{7IY+gV;}k
zSy<fsLT3@B$yY+8qS*4ssh9=I4`0mVAPE$VcpJqAZd)e2UGMDFJNy0Gw8Ju$a!qG@
zt+%#nx36=qCU)x^cFR>|MxFg~V%0nRiHHxOQdi$SemM9RDk%p%O-{qXle5t@5VI#D
zeHxCG98BU!jizxh^yg*hO=K`xM1x_NjHUyut{g0qNNLyCAh+jd#a&(Z`oG~1(?!Ci
z2|q6J5)&#~plj5-5NLpD>VF1DvySXjFqRSEn*rwrXFxqLe~Qdo@<(6`-h#{;Qy?7T
zW41K8rOXRU^ZYf8+nVPAc$#eB*+L)5*DbBul5Zy~`F1kko7=B#VA$pkhu1{&>{L7h
z?f>C<#j%x}n&HNYKy-xx;?XPC>v{B?BUFbgD8Z?q+*yUdsY2Vp=`c#tSp?TlMw7(X
z#hq8Yc2~UaYg}8s>J<QbH58tWKy9P!pmb68Q4R$@v+GE~+aWeF(Tb=$|M$z{CZ6XO
z%59W)QMORtLAitS9*F1G?`21P0I_;xuiiNj_x?3}w03oO)~<C|U*l3f!gX7^C~wN6
zqEO<Su)1syzy~DV73Dhf;+|hV5$zHrz_u;I=OR+@JY0tgr;6!w_qVRuXafmtO@hEH
ht;?-%wZLDiWr)ZLou+#{OZg%WKf?u@hEJGl`~$sF6vO}k

literal 0
HcmV?d00001

diff --git a/gui/bench/tests/unit/__pycache__/test_templates.cpython-39-pytest-8.4.2.pyc b/gui/bench/tests/unit/__pycache__/test_templates.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..2b9a027ce0b7bd4ca3ced696e0532af85e541a57
GIT binary patch
literal 1084
zcmYjQOK%e~5Vm(W&$d*kfXV?84xsKOq7O<z6crUN9I8sdB?_{fwUaE}NAP%4Qj!bh
zXK-kaaOBLt;N~k55`Up5#=C7AOCEnS-#7Mn*2|Zc>IBE%-QWEil#oBxnI8^1dpKbO
zjUa+Xq($@9iCu?K5__!@wTu&$<4UW7*cIMa(y9vjhWMp_m`4tLY8HD^GcDsm#I+1;
z^m3FDRB`U(gkNX`eM#Q`oDfaM<djbEyoocWV<)2%ckIFsP0t+RjNL93u8nt{sV6+`
zo_SL;B=8#fk|tBC-XbbnlsLi@rI{kKim_D;t->NylyXd`G+&)573FW<Ei&;$MO4RL
zND-HG1=;GjG^MBX3s&Zl3B~D7oR6L$c;niEUo#6z4y6LgKr7>R!;V>oEM@@=S(3#a
zq|A~|86^BjvVeok-GIk3D%>hhcu(;d%tDZ6iDt*C5@42Nsd|!yiI!@}BQO<xjN4?f
zPtVICG?G;N^knP)+F-QlL;dpwXzVsDdg#NNUDti^>yt*I&zWr>l>OAkORxstGcKyF
zS+{1>n(dQo96&0aC+zrOgFAk$$gA%SMp}YqT$$^5g(zZ54pflF1Foc5M4EN7Fw$WH
zrW~cH0JF-VpJtKBrK}gF9Ud`TfT=OyU1@hP*IwkOhH3IjsZ^O2)=gE+HItw4DJ5JZ
z<CoQvt$x8CQ&hPz?>w4!wpzKY*yVA-6wZ_HMBT-G&iVe+_B*^Qv_+a6$@bwW=yMex
zs`P^lG_-qBsDpmQJ8V#dt|IMT7PdPw3Hoi@4`^pesB<`b{LmbX%xd1PJ_pv}5C&JI
ziv@s(hR`Zi_i)AcRK4t-x`_dEn-$$|7I(!CG?hG7p~lY5LZ)&NQ!6&-&aCJrme|Zo
gY+nA4#n;bI%R4Y<8aBE5EKWrh$>;WwfHe>3e@07BKL7v#

literal 0
HcmV?d00001

diff --git a/gui/bench/utils/__pycache__/__init__.cpython-39.pyc b/gui/bench/utils/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..7d6b404b5db085b0604f71b13f9f32b1e034c371
GIT binary patch
literal 177
zcmYe~<>g`k0^hdF86f&Gh(HF6K#l_t7qb9~6oz01O-8?!3`HPe1o11(*(xTqIJKxa
zCM7>FJ2fVtGC3o$C^w)eKPxr4q&Ox$C$l6uBPTH_z5pVG5Q#}I&5TJ(%}dURDJ{v&
iDUOMc&&<m#iI3MSsJz8tlbfGXnv-e=vhOnxGXMZn3@_&Z

literal 0
HcmV?d00001

diff --git a/gui/bench/utils/__pycache__/plot_results.cpython-39.pyc b/gui/bench/utils/__pycache__/plot_results.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..87ab910a5a0e9032a9726b3ef250b57a02951eac
GIT binary patch
literal 4731
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
Fe*i)uoF@PP

literal 0
HcmV?d00001

diff --git a/gui/mosaic/__pycache__/__init__.cpython-39.pyc b/gui/mosaic/__pycache__/__init__.cpython-39.pyc
index 10afb94f9d29ba76faa3e6b30e646a217ec076c3..26f20a4cf30da82c3aa6752823d1d6a9d9059246 100644
GIT binary patch
literal 711
zcmZ9K&5qMB5XX~#H%;60Bi(1{g#$-Gh!tDl0IP-F6_ORnII-K9&BT%I0(~SNh8OUa
z6K8Im@TgkR#gc!T`P-fu&6thHQQ%kj^hY^t1;I~rPM6n$7k-;h9z5V-6+lQrXpt7Q
zNgFz(16|UE9_c}!^kF~-FeF2WNCYD?f|$fGCS#b82~5cp5|Y4-%wSIDupkRqk|m@h
z4Fle~4%Y2op-;0;U7YV_#VIJmWZ`C~9^GllUGhLG#Wxo*V<{JvWyZyYf<_Bts2AO&
zDJ9inCsj?iO1ra%KFwLh>Oye0`tLy0R;%XV2B;Uxhl(2`=~f7yv*ON8j`h(-tF5er
zTX1PChQhS>#V4}<!n9<yHMA&&e>Twjnks+Ib<I~H8kZWmtEm<Kk<av)=E7Q`UH{zJ
zOT~qYym7q;VEW*C?~Xl5HW#lq^ybY6da-$Re*5;u4L{zSm+KXom51Cn>ZB5lv(#-w
z2hm0J5Pie|F+|{x&?7{Q7$YW#DI!745Oc%=u|%YZmB;r$pP`NT^Zw<N?A8cvGOp@7
zkzE~%l4-co>a!@U$##{rMOm>NyNJ?1CEM*~c5HD*sjQ`?^bwBZ87RK5#B=;Czx@vW
E0)Cp+&Hw-a

delta 76
zcmX@kx`xp?k(ZZ?0SG#oj%9%8#~=b3FakLaKwQiMBvKfH88jLFRx%WUgrUUbIHpVh
DkZ=kk

diff --git a/gui/mosaic/__pycache__/hybrid_ast_mosaic.cpython-39.pyc b/gui/mosaic/__pycache__/hybrid_ast_mosaic.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..2f2a6e483fea929b1ea55d0abc9afbe44d326754
GIT binary patch
literal 22885
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
Gt^WfvHm~{s

literal 0
HcmV?d00001

diff --git a/gui/panels/__pycache__/__init__.cpython-39.pyc b/gui/panels/__pycache__/__init__.cpython-39.pyc
index 1e33d1678760123c5da5e620dd41957e5f0c09c0..3b7a524accefa1cb67ea2517264d65af08128bd1 100644
GIT binary patch
delta 22
ccmZowYgOY-<mKgJ0D@G;(-~Jc^8OG406F>w9{>OV

delta 22
ccmZowYgOY-<mKgJ0D>n$Co}Xm^8OG406nM%MgRZ+

diff --git a/gui/panels/__pycache__/panel_spectral_shaper.cpython-39.pyc b/gui/panels/__pycache__/panel_spectral_shaper.cpython-39.pyc
index 1de3162595836e5a3440798c6465ee97955bf12e..e347fbfb606754741780a599d2e9303bb4b33e89 100644
GIT binary patch
delta 20
acmZ4GzsjFGk(ZZ?0SHnVPjBR&uMPk=tOYgz

delta 20
acmZ4GzsjFGk(ZZ?0SM;!pWMhjUmXBC_XW8C

diff --git a/gui/services/__pycache__/compositor.cpython-39.pyc b/gui/services/__pycache__/compositor.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..a075a8e6a946d2569cfbdb0194186de063a1b1f0
GIT binary patch
literal 4407
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
H{ptS!1{+G8

literal 0
HcmV?d00001

diff --git a/gui/services/__pycache__/layer_manager.cpython-39.pyc b/gui/services/__pycache__/layer_manager.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..7b46374b8ef1ecaa51e34c441e669a01d015d91b
GIT binary patch
literal 10008
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

literal 0
HcmV?d00001

diff --git a/gui/services/__pycache__/pipeline_runner.cpython-39.pyc b/gui/services/__pycache__/pipeline_runner.cpython-39.pyc
index 06dc70b2b63c7c57d19268326e9c401bd3f0321e..e2f3fe776fae1b08127a5509cb597f7a15df4103 100644
GIT binary patch
delta 23
dcmcbod{3D#k(ZZ?0SHnVPiG_vY~;Hj2mnfg20;J-

delta 23
dcmcbod{3D#k(ZZ?0SN3APiB1N-^h1C5CBbK2F3sY

diff --git a/gui/views/__pycache__/bottom_area.cpython-39.pyc b/gui/views/__pycache__/bottom_area.cpython-39.pyc
index e1912dc40c91828540f040e58a6e3a8963aa3f18..f87cc209b5f8d6bf692f2e577b1acfa44d25d739 100644
GIT binary patch
delta 26
gcmX@ae~6zuk(ZZ?0SHnVPjBQFXJ?F>tjs<i08gp~^#A|>

delta 26
gcmX@ae~6zuk(ZZ?0SHvCpWMhT&dzvivNHR809ell2mk;8

diff --git a/gui/views/__pycache__/bottom_panel.cpython-39.pyc b/gui/views/__pycache__/bottom_panel.cpython-39.pyc
index 750d0eba5ffc5e1cb9da06a590770ca3ffc80c3b..9c631a3199023ebd6e2a73391667fa32df4e36aa 100644
GIT binary patch
delta 20
acmaE2@Wg;Sk(ZZ?0SHnVPjBRolmGxbQ3V$O

delta 20
acmaE2@Wg;Sk(ZZ?0SJy>Ke>@RQUU-%>jp~z

diff --git a/gui/views/__pycache__/hud.cpython-39.pyc b/gui/views/__pycache__/hud.cpython-39.pyc
index e4d70c2d256f518fae9cc39395841959559bc50e..367f11662766490cb3154be01b622f48f7fc418d 100644
GIT binary patch
delta 2771
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
L;pgOI!}op;DN1eF

delta 2771
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
Be@*}Z

diff --git a/gui/views/__pycache__/layer_panel.cpython-39.pyc b/gui/views/__pycache__/layer_panel.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..82cfb8946e560b6138214ef616573a5808229ba8
GIT binary patch
literal 14075
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
BLRbI*

literal 0
HcmV?d00001

diff --git a/gui/views/__pycache__/left_dummy.cpython-39.pyc b/gui/views/__pycache__/left_dummy.cpython-39.pyc
index a3843c7e6422e2b50ff24f4f84183baa9dd854c1..cf0e493439ae4c04917c2a2a500bfa7a569d3ad7 100644
GIT binary patch
delta 20
ZcmZn=Z4l*7<mKgJ0D@G;(;K-<xd15F1SbFh

delta 20
acmZn=Z4l*7<mKgJ0D|sir#5nzasdD>x&-k6

diff --git a/gui/views/__pycache__/menu.cpython-39.pyc b/gui/views/__pycache__/menu.cpython-39.pyc
index 0c27a0362e3a80cc3ae823c36d09add215febdfa..4da021f6d3b0bd175c67dd6d6ca33f8e1e18e854 100644
GIT binary patch
delta 2208
zcmah~TW=dh6z=*KC$Sql*OHr^xCwFM+9@iblqP{#O+vs85mgJWz!~q3o5gEyI=h>u
zmPolsMW~=k9S|=_6do$&1*x(Gukg$dAe~U4ec*|QiYF*YFlRP6CZu*Ge>yYsedo+<
zzB9A6u(fay`Tb1?_#c+OTUm(SKKQr0FYSB@6{8O3D(QM5?MidxBR8=$Owx4Jb6yIT
zuX@HLPaD^fApN@Gw%-o<c=G@mqn7ukCkTt}w5KuA8{lEoK}H1~V5|Z$nrobtfYwL9
zZS0E11(mrp)iBAh7}&b;ibRNGRBBq}x}~OD$w64^<-nS8(Il5;y_i!kkO<5)o?4gj
zs;TP5sMAh#4A@TsRPW+M^BJD)dNUoU%toEe5g%t#o=KViaFf2&@DL<-8rUQ!c=Ye#
zCikZO%9oVd%MX1&JEShU-4d2&>0d3M4MB}f$=;8B97yLqsi8tvK~n~#nW5hVhFhQF
zA>a8d%*+8Cr@seMkryEp%F~r72GJsiOAyS^l_0Lod(-AU2%f9WyJGX+XiX)>0ik$Q
zVp5UpQ~atR1H&bD&Ae-fs3^<5(+Nv+^kM63wd-9IDQKzf_1e4-Y~G)3%e8qQ+PsbS
zrP{pfHt)CgI{7}bc~-}n+W9`VdB1kdFV_5jeIj@q(yn=|ty*3lK9|)k^Zr}6qMf9h
z4_Px(l#GlF87Y|b(04oMt_a7w)uMveiD&^ZJm~}I2S|dh1#|={s-Cq>Q!f%QE(rmI
z0R}iQPX<A`oep8nJig4FT2`xam@wDloSfr7;}s6&=ewLz2;5In0J~nOIGW_j`9lp-
z7}huK{%4L{vAUT+xlC_7_8^w$Aqyxthb+y+>n1K5ylaWZr%QfIjptMi8*u}zVN#%9
zcK3ISsyZYP1$V0=`b+nXQLzly5_4U&RJ%|2-K0#v=$RK+Ngwt0zB&yT7i(BS1~N@T
z)<p(Im3KOQ=N4Imx}wqc6i=0J_I@rM+quWQnN@<<;8t4Zf=%8uxM~mLqe91SLADuc
z^`i+}NH$;w0f_F~{kRp)9iib+avoWw_d*kim-&EyW+4@)f0UF7DZLnaI#FFthUrIX
zwr$Ow(A3B|2;Z(n{=p_sho_E$Rce#(3NnY1`{eA=aX8Az*}AG9g^KzHW)kP?l7A9p
z4*Xk{M1dFTYVHXQ-5!`6S*lCEZ<C)L?3fUi^JaNpW{{@wTM(YTv_~~E1tc?PL06cR
z-P>7FdTnsp54SvXBU#28e>uM&oDh!@e_X`%{~pxX<F*WqN5;8#Gm&}QIZo!eq$(G%
z$r^LIY#Eu#6D5)N_erop??%q5a8-~a011F60G<Ij1psYNpzno=ZC47f2$Mzm0`nOr
vGF7>N%@tiC8Q=;V?rv8^G5YD@(=G3SqQT6oMH3Tpi2iXn5%?eR_)z#Cw$jF~

delta 2208
zcmah~&2Jk;6z_U%$4=}fO`L@0%TAm`c1Z1nk5EeU0a1z*DNTYxp^2y&@2;CA>s@zt
zH%*M7l#d=LC{hQ+1&P9;QZ7i9CAh+se}HsCf%d?OL&XUS63m+ojxntrDL=iL{r%pX
zUH{&j-MQVl!zdW6Kg9lC-2QHDHFopx-=1zNE+RedqV9rW<fwavAzOK{ttpt2A@8aX
zDqitEDtOzN4u{CsbvJ`f$kscDaDv#r>)sGNY$u)mWLFCd<1T!R(*Y7CNRq67TmV`(
z`PSbaALUf))>PBNalUYLkC!A|oFqd10@E$k-<TeNM_~rELD4O|B^i2FJ&y-r$3L?v
zDS1mZ^tk9GdJ5Rb0m@HtqG6e3+ioDerQNtlU5ODYtWzQVAMSKuelP~fMN_fxIE(&$
zxv9#uUj?Rx_Tv4(&n}^Z>@`M&S@KuoX9G}UM{v&Lybjx-zLOftWn?sALYf)!P19iW
z2^O-G&%(|ez%%6crupasgj~5)ijok$z~CYTGi2?EQl0mP!@GCnrRuy(4)3+*`ROSL
zp?F-Nf{q_h{0b)n!_7}keH#d?D8syS6duiy`^~RZuXmNFAcdB5)p;K{ygyrBt<L+<
z;k_AJs?OVXc)x{e<on3s*{#df^L^~_er-)HRQ<g^;XDQ_?v$eCZ66Dt%^0?I_pKZ8
zHr&mYv;oO-T0*9TWCiz-ciNu6#2xQZby?ZOyamAUI0DcMaEbwK1RX}QYGiE7GIR{a
z#eD!#fPNr((+JA#cL){Nl`Sf28LiA=++0J9oMr#!%M6OM?V=C{_v1x?122>ujn(4%
zBXvRqp6@vQPhDBPyqQ2Lk!wfq4eKnVO|p_jwq_}tmZF=iYq7z$3qe~=WK~Tu6DHbF
zaGreG(bK`JVo1OX9#oadFCEv0_+uDL)P2ELoj!fwA+zL*&J-Ud-Ne^*b`k~`ty@DT
zvMh{W=NV*G+VAxJDY6B13jh_x7mL@sJ{O+YpJTps9xEF#l_bX9VNIiyoq>N;=-6FI
zG(+qjH0B8LW!RAc-Uc}MxFyXku3=CRkLAgo@L2K;Td>c}rTpz5CZ$|TE`*;>mY0K{
z_MzqW9L=rpL~I4ZcdL<qaLAL9iP6=X<lCIgpx`-qYIFo%C3d!^>PN03f!^nm=W3FF
z;$#NwTNQYL(=|1BxQ6WYj>nd3lJ7d?slL`RZaH6u^<^4q8k>S}?X7rKGo3>c6?2A6
zg-m5<4U?;VlR=pB)Pp2R(b&!Tecu?rjM(ME$N&3Kqrz<&l8BBl@1~<E$2lVPUR34t
zibefdL$b|u>539CpO+O0E|c5QGb)S<JOc0-z>@$I04V@yd#nP0i5*vRuW*wMvppIx
wEo7-uPO;Vu8E1gTZFo?PM@jN&|LMl}Kv8F{tGcCN+)4iEPd5FJczhu84=gy$iU0rr

diff --git a/gui/views/__pycache__/statusbar.cpython-39.pyc b/gui/views/__pycache__/statusbar.cpython-39.pyc
index 26168ece508a96616673832412ac013fa6fbedb9..95dc9be2e0fea210e9551d6aad39175506a39053 100644
GIT binary patch
delta 20
acmX?Sdd`$Pk(ZZ?0SHnVPjBQtECm2Lmjz(}

delta 20
acmX?Sdd`$Pk(ZZ?0SJ6tPHyBrECm2Ma0Q6~

diff --git a/gui/views/__pycache__/tab_filter.cpython-39.pyc b/gui/views/__pycache__/tab_filter.cpython-39.pyc
index 0b0871fd5077811942b06bccb807a4dfa23cb089..7c74788b43f2593609711deae8a7cd60e4a0e24d 100644
GIT binary patch
delta 3681
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
X`x+|gqP3}Xp?aX)o_o7(9>;$G47Prh

delta 3144
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

diff --git a/gui/views/__pycache__/tab_general.cpython-39.pyc b/gui/views/__pycache__/tab_general.cpython-39.pyc
index af45039c489fb2516686be96fb5ef98580020c52..bc66d74559dbc7b659992816dbc6ffbc0a057610 100644
GIT binary patch
delta 20
acmdm#y(ybJk(ZZ?0SHbPp5Dm4+!O#pR0e7Q

delta 20
acmdm#y(ybJk(ZZ?0SJ12oZQI0+!O#qy9TfT

diff --git a/gui/views/__pycache__/tab_preset.cpython-39.pyc b/gui/views/__pycache__/tab_preset.cpython-39.pyc
index dd070ac519cba8a75692b987c0f3449309579daa..d839546430ea7dacda0671c0013e61d7a2c4e982 100644
GIT binary patch
delta 505
zcmX?7e59B=k(ZZ?0SHnVPjBRIl4rcNxleu>8{?YErfS9_Yk?9)bwEOssftyvGBG!&
zX!qnAH5ayZAc^&pkEtC|+W}%`fz+@UX@b~0LBuW)VF)7PLB#RR8`KS$6pjJeQJlqz
zX{qr!`H3k-+dy)jAR+{;YLb?;=y4EB5KahzSX(C>Xf5YH1!A5C5oabp(z?rddGY~m
zQMQX9flHfjYfolm+%`F1w}|n|Bt!AZKXnhwUj<2lO}-0ap&5F0^KHEojNEfUQp-TZ
zyvgefWKF?tnhxUM0ueJnL^X)G4I=J<i1{D_WUeMN#LM?K8Tv3WKAP-n{6rk#CmWEm
znIL5>MUN(Xn4AZykTA^ylI^DUybpj9E18NOffPNPoM<LI`I%`c+j9{21&|xXwh_eK
zH2I*JquN6d6Ko+H#KOlQfhQp1DTsIpB3@0_Fh3@>6~t@=5ui9JY5@`8aCk78!{Q#}
KvB}RZ?g9WY=#6^-

delta 505
zcmZ9Jy-Pw-7{)tRw-0gXLyRJ9x}~8gcFiG(prN3)CKtI-4Pgma8u}n8g0=?Vp@M3w
zh)Oh-KBgp<tf4QLGBeGz{)D#fqfpQte*DgP9^P{fH{y=Cm7+>jTPA;eIPO<2X_-B+
zs@>(-0SUaN@lXz=1sOWUY^8BVoODX(G|%^QM+m$W<0JeDbON0!Ne4d#&Hyvu0Ac}O
zyGhX&mEB(B7RSdNPM0_;g^&#bBgK|S-=dDe>V8oV3zA8{r;J0dfg8%|Q|y5*I@R1A
zHtqw-PGT%XE`!7#J!TDk8!oj8M8(N3uzy1nfu!+@DK`=A09)iWwF<>MtzrEHtOIkv
zGmr$f0nF8vm!6zDHV-LShK4OU&EK1PP}@MQLdwuU*R9-W5~gIX2)(Mb9PBHk3`!p)
zS{o=YOmlfG3-Z#=`JjFZTl@GoXz@U<bYK=6??4Xt1iq-FJJuY8E&})`(lU?$(o}7G
JWl<{FQa=G5jY0qb

diff --git a/gui/widgets/__pycache__/canvas_container.cpython-39.pyc b/gui/widgets/__pycache__/canvas_container.cpython-39.pyc
index 67fbaa643519ce84bd2f57e500f2df3cfa7fe881..ac3f599e4914a2bff412e77b860b185a2edca458 100644
GIT binary patch
literal 14113
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

literal 12116
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

diff --git a/gui/widgets/__pycache__/image_canvas.cpython-39.pyc b/gui/widgets/__pycache__/image_canvas.cpython-39.pyc
index 52b11a474db862a0512195f49ef5f8e561267d66..73ddca52d50a1e7057d821bb6df62f997b3e40a8 100644
GIT binary patch
literal 8945
zcmbtZU5p#ob)G-|F3IKoX!T=Rp2)Hz+H1;n<HTJX{*&y$iNvUu>L8Sa>5zApJImn=
zb7!a(DXJ;5s<kPgBq&;-L4-gm+6O%sD9|899~wUu1^Q5+z&!LJeG*Xgp?#`Rp#9FB
zA98oO3kx1%hWDO1_ug~wJ?A^;+%e1LqJ-=3e(;YQzkETG{+%k*S00sjB}w*=$&$pR
zro?2XIC4*EDl(N-N9}1%t(R$Ldf8^Smuu#F`DR|c)0{%H2%d~n=*>0fWNB1IE$fte
z<z`uyzAL#anq*am>#{^YrZvmolU(K1h%e{N_o~h66yJ|izUmZT-dX4^HW#P({wC#H
zoZ>4uOTFdh@)X~{rF_c~A1mTF_dsDKR=%q>k9<>N6*hlYV)NGA=E}C(JPJycEr7BR
zQ;sq1id0)1{IeoS#ZPQ&tMBnZ|IHu%sowS6z;Z3F_dGWE?1uy0YjJZl(9d4=Jg4Q|
z(qGm;>X{wuyy@OF{aU?P{Md8Mwc;!KmF{OhG?}@k>-x2r`G)SAOushO;072!!U!Ec
z*tGNyZdz{e{=nC5{jAq-Z+fojxVBZ(FPcM(Uou?`#L=Q*TRI!`9lJ}d9Is<{ZJk>#
zv-sfL$n$#V`lhR&WtL-gh=X~%ge(>>4_avKZJDlh&TILYSI4G`K4K;xS*~sBXA@y+
zYeik}4_a&bz^>ag*Lr}t*V`MW+p+Z9R9V%%e&F8$qqtJWn^?;Fx*ZVp_5rWC<y&Bw
z@tO}Di~CWRw{P0M-Eyooy@m0pD?b*=p|$a2ao7PPeF2Gkrr)iLQEbN!h9ohOjIK3Y
z)#K4ub<^o@nC~1gm1s%WZQ6o&R&{K`L7ZQBO^Qv^u|E5i>wWg~wvAPel>+N<`J;<(
z>ak+IIlaGc?pBv41OzoXoHJe53(UawT)&nH)%V<Cs9mtzL74wepQxr2X0Af3tT2Dx
zbQ}|_-9S4v2)g*o2(6`lrqmbJTr2{LrD-({RX^Z0CDdHAXN6gA1q1H30YB+Q<qYog
z1WYR^5GXN~X)N<Vdnk=jf26=Hvx9f>@{-vneTC+`=4eYFB~#ab^XZ@HUDNekyFG#i
z)7v4QeDv#|v5~E}g<+cYP$OjwHQJjn*SGst5LjWZXPN$hTQ#5`^qKJm3>9j9yWQnW
zC}LJ>#|mmPub}o=;w0zipPXO2{(C;O?mF|_u66zL5IfI%m$|oTwFCcp2MW~QzzQ1u
zh%}*G?+ongTQ)<d{&itZMkHaqKMV^-&+HqdtKYydKEOzl6n+fPHWjBYEvm@=ODI@U
zQwFLlOm3>_5~}y4b>KA1-7Ph>dy*zKGg!=gST)3snfya+a?5OY2fu?Z-rF+yaMK+^
zX??3ZS-(}i!-nZv)ADaxegH)AgJ1uw?+)vq=YnqilI^!gFC<!X?HaazRVUqwN>H^M
zH&*qA=UO*Hjs9wCn1yu(7RO!?82KA~9%8iBXkOw;<t%Re%YGK>5=h(9LwPJel4WVE
z?8pZ0O*K-R`|xCewwc+HNr71QzPgFI<CkXzR=lslGtIHm1NokGPhMA8nN{wVek8Hn
zj%46w^PtMYE9AG)6DW&<vIIYoP?iPd$P{HoP>xPfjtR=~gaV23kmv+^=Dq@XlpSd^
z$4)|~XGx+R><a42HzXyJ;*@CpT+$j+=z{W<gu*23;pxT`a`#WjfF8?XcFVFm8^P#E
z>XZ78*|s)32mYWo(w=|gjW@^;1M5~07S}xvZ{rQ1>(u@UE$|c4rpH>Sa&IflwmoOi
zb72G~yCt4OUdDSeh2U1u7FvlqUC9o?RAm3_AOzB;yd#gLvCQQA>K$dQY${^bYGl~y
ztf8l3)~c9Mwoy~~X|xY>ZLilOLwpXkCo~q`kf8hwJzgY&#wnf&v+oarz=NP2ZnIE@
z*fo{EOmEb7kA-sUu@b7S01Uq6tP9KKN2!yq;c)@CPji>#s=O?ZUfgRHb;Gb-J1~s;
zTaMQ@9slh*`f6$v9ki+4^hGcx)}V^Qj`T2wGCKk=t?~JC>JrJiV`qgeL4{MB$1;Bw
ze?mx<Ur)+H;4uG|WA<9ieEVCV|2J-F^zs*wH)++>J_am3wa}b4loJv)HI5GW8&oF%
z<b)Vg3%Z8tw~6#79?i`AeBf_<nc*@m>f!M5E~ew<E=OSgB}U|n)Z3x+yEGZ^Qsgtf
z%y{Hm4j-?Pj2Gr_T0F3!g0R4>$8E%jp#mSS@vjokSv<n55037T*HCGyAHw~hu<Ifd
z7b;ppAyQFW68=?be7=yXXA-d;F5G4G5pVX#6uv#(XiK|C69M4i<Na<jUab&j{6QaX
zBcIr(Fr08cLanyvuG<|r^avs{7tNOC@N?AsRXoDN6{~M@Gw?XDLRi^JdPlYgBrO<5
z+cACLF!*m1S)j#vl-|be6Q?AX<g8qgPbte<R#}vj-zrL@;|JPgElcuJBxD$2(J&~P
zaHw1|jPDN+<VSCEhQYixMyD~uax6{Tavacv;fcpL@ivm}I7)Bf_Gx$XvL<t)?Ar~3
zOI))5A9(Hw768u#%@2grOxz{Xr>qDcD21vtH6&D(2Qr&yRU}jywt)H~609Y*jCz*U
z*%7$3B3pT&vZL(S-ApqVw>ZvDfP>yq`)Alm)C%kzT=KJ^odW-JOb36Fy$Z@#KsycE
z^Xv?0b8)K|*o$aY!l=~8SJ_$A%5km6UP7%xE}p#%iB{PwsLzXVrwUj3TVb96o6@<_
zmPk*&9Vc{ahh=4T!Fr)(>Yl!3bKC74oSSjW?4*&YKI+*fq9{aDey|mF)3{oLYi$ku
zuq<*F1bHHn3(HaDXLP~c@xwXt1}&2#0POP<*r`!D3Cyoi1T|VotJ8t@jnT1`z9-}g
zHA<HFGw7?9<wDcHgEAN9D{Sgxs*1oXaqFZ><QGY2RMMH>hxgqRcu9sbRuMR<fi_0a
z$)s(y{}SoZT_B5*L6DOjXZRY^Tm_++hG0yDR0ws_T99YbK<1wY`5j4US`MxAqLfcd
z1u9YShF%M9H7M?&|IG}WyN^K1C<Jq3t^W&K+LrHVK}q!YUn4yz?I7?aKHMroK4q-^
zrTk-1j4}=@&S+9l8UAN<Xb|z*(u5;ALU0#@`OPZAuQDXA+^4yg$C;nX{8jW>*jxZL
zL)LI#r66vz3<}xLLPT-T#5CfHX>mK^O4~hLd_)H(6w)m=1P1N0T#9<={x0nTZ3}Te
zmKy>I;0xqwOb}2-ez=2MK=bJNMDu5aGD&D4!mKF1($R2Veny%gyaoYJ<TV0>ciXZp
zG39|G{D;~Qkpkj0iWNf5!%+a@&AgEW_LRVoyuqxvf#ao+ci-5l$D-7W#*RjQBwvyE
zRq9d+D+Zj8(dM4-Z<sdcS3m}i%l@p9`~ycyXSp1YL@7l)&nSdb8>9KuYenZ0VJ<!t
zz{Igdk{FyfsWc-z3X;KVYIELmMUrR4=LO9rLFjbg64JRes}o{0pm32GOazK#!eOR`
zK);K1P+FaEaRXU^LzzIZfmpz`d_PpIE%>=KOyKWOE6w#mUgGbQNaSfafkIO?93;lb
zOU)qQVn$&J`M|`ZULe*vJi=UzRKnYY8bhMTDI-DdAhPYSaCO+XKH%Krp%Qe%?0G>J
zei%*`h-w+YLtxUx1<wK|;poI-3iT#gX?=YP)T9D=V))?y(=sb^Ma|0!entBIZ!uR@
zOLAUOWF7wcgtDk+;h&euUn`@9eP)5|UO*rjTXGQ`QdBP>@Q+al$k3715ZK+317$34
z%l-*6N#r_;04})EC|3j}BPiJ^N-hSs2~R;#ic>suf>N5Ilm(@dPy|@aH^Kr=zx+10
zTh@qTx7}x8`z(njBdnM}oh<1Q#Exu84wtyKju33aSm$2Ph<bV~Hx-;+%+TXMLk|(W
zoSCd+vZ0eyDaDtsgMXhqsl5?0kUV3g^*HSTvfy8Nl-QgA6#faA2v5k=MZ$Ch1hVp(
z0{%H(MglHkVfGyA?UN)2Zm}{t3JJzMB%cOs+a`G^IzpT*kWOpx>)^W@X2dZd4l$NU
zC~-_UIXR4gfP~~8J!Y)p&xuaS(&$KvDmUq@G)9Dda(>|z6X#bdP9CvhMYG>`h6Z)a
z4;AMZi8%aSl=cmNsQRcl%H%!jV8%Qjr5(Tb)E#G{yx^d&|03xc0N0{20Z5ofnj}sx
zfs?NjL4~1A<*WinHu2&oxP8j{Bt-LwoYlqTCyy5QYc>ZCkP>FZk=^cyi8`SrA{IcD
zEE0tPI!$n~jq^JyJp^FTv6V1jg$x*qBRYc?<u*)Tpzb=l;3GU@@%fMlBIp+nAwIqT
zE8HR`poC;f;I!AN*b#?uH?T<LMTITRK4>Fo5Yp2b!&vqapIrgyrL*{ObSj!hpc3>^
z<kx?RVy{Pt?GRTjBCg5|FGO)w{2>NC)RYEy(Ic?_HVGhRNCa`F#4VJ<!Uwn7mN<e=
zlCp`cd*)6pALI6kLy|RFQ%ZpSQ?v>bU{8=@pC+eU^cq@EO)lOd3dh`)n66;!>SD@j
z8m1xC8K7lYhSCFz;K^L(Z6On%%#GgjJM@^?!({L1?O)^eMM?&#={G8+3Wt6V7Wy<A
z0+E2;IO+s8;b@KYi}po%I1v)sm2KmY0Ed5?5O+$tKR8IRn|SfJBp4x$q~uAgN-CBx
z#ZhV9@ytLUi-TNj6=5O&K0So{q{U4xDpUL>H0l%zQ;U5f(xb6F2CAkO!6^_#r<0Y8
z31r4oL+w!rV)}dB6Jt1;N<9OcM=RnB$2HpxR&_jXOlCvK$wiEK_-tszso8uBp@0&o
z*oQT;iEVg}E|oLLjMU?>4^h&nw65Sll&~P1%-ubMP=WFwH|{Zmeq6zm3-V-VDQ09F
zT*Q#CkeC#yh|oRqiu6sRR+ubZSj5LN*AGm$ZG{>R*Mm@XEH_j!<EWP(po1_Y_A{}$
z$^7>$F%A0<xP3Y~BD`6VkI7X9ho(#EQcpb1!Rq@OT2C$9Q`nq?mSJ_!XJ%j-Hggc8
z`dvBzn<xvh@IRu*EVHAx|Ac$D*-bQMMhLWT9<=5{oykJ5MUxOJ0<{_AhDC(a@%Np7
zq2b9*NYm>!dH*!yG4wKPp5Ywz7YFD6IyK;Ox=~XM<j$ZYzzL!7LN<~Q7nM_oK+*Qp
zzI|=992s!r2uML=_}7N7&4B-~Om>*&HMPvtuKfsIN8!>KrNrs&5Ot3deh;(|w@-Nn
zDWQT>dtlVjbY{C#!J3S3m-wpCXw(+?M`*&yuW@loeUVDoN{Le>ApEWHQ4v@Y5(+Si
zEJY~Rr$oC)50ZmlqQ^u)k){aO+`x;gxP5|ZL=^?fN$~q0{q@R9Ra-7rvX$&I{pTub
zMdid_JI+ZUIu=|X;3FxH1v#yMm<@(~oIHupgA<tY3_VEwIK{0<!@4kNi}MX4(SC(0
zz6$dKRcS%P)9IJUI=(yB<L{2qSNvEnMdH?cb~d9>CGVEV`kE)G3w-swX}2vuN;#6F
zEMB4^DVh&6A95UKip)?<Z)%;yiqSgZgGO`$`nHOiU&li`T2fAu+ffyKkSWPUByThS
K)oNz(*#83?vg-~2

literal 15658
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

diff --git a/gui/widgets/__pycache__/image_layers.cpython-39.pyc b/gui/widgets/__pycache__/image_layers.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..cdc87f844d5dbaa6eadf9edfa1c64c216698eb19
GIT binary patch
literal 6829
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

literal 0
HcmV?d00001

diff --git a/gui/widgets/__pycache__/layer_canvas.cpython-39.pyc b/gui/widgets/__pycache__/layer_canvas.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..1c83183ba379c0525092352958e96077c5e1051e
GIT binary patch
literal 13563
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
WLcnr}vrR#)@_6$<Kr(b^Q~w8oo&pU3

literal 0
HcmV?d00001

diff --git a/gui/widgets/__pycache__/overlay_renderer.cpython-39.pyc b/gui/widgets/__pycache__/overlay_renderer.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..91100d5e9ddfc4d3223710370ed14bc592d4aecd
GIT binary patch
literal 7876
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

literal 0
HcmV?d00001

diff --git a/gui/widgets/__pycache__/preset_manager.cpython-39.pyc b/gui/widgets/__pycache__/preset_manager.cpython-39.pyc
index 05d4099863d52ededa06194eca9ba2fbec6e1214..7de0aa52e7298a51e4a11044edef7c4cbe2342e3 100644
GIT binary patch
delta 23
dcmZ2mySA1uk(ZZ?0SHnVPiHKQ*vL2E4ggb!2NnPT

delta 23
dcmZ2mySA1uk(ZZ?0SLmTp32w|wvlhX9ROHu2d4l4

diff --git a/gui/widgets/tools/__pycache__/__init__.cpython-39.pyc b/gui/widgets/tools/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..aff296705cab695731d555ae5def74ae0f4e5866
GIT binary patch
literal 5091
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

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/base.cpython-39.pyc b/gui/widgets/tools/__pycache__/base.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..f47141f17315a555cc89c8a6a59cd944f9d96011
GIT binary patch
literal 6002
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
PYc4fr{+&vB>Da#kC@zT+

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_brush.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_brush.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..f0818b7c09b018884bc6bc778ce34411526bca91
GIT binary patch
literal 6721
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
W9&&zAXy#2CUMaY$ufu^ijQ<6AXif0|

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_ellipse_select.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_ellipse_select.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..ca1d1c09b6cab288cefef0ba0c73c60a5dafd082
GIT binary patch
literal 7336
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

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_eraser.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_eraser.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..982e15cc32b34d4a3a786a451de4ca517a7ddb97
GIT binary patch
literal 6715
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

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_measure.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_measure.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..45b3462bf215f28e9b8e461911d3f6d5eaa089b2
GIT binary patch
literal 4706
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

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_move_layer.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_move_layer.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..b4a44f34ad4baa130a3463ed97de2ae74261a108
GIT binary patch
literal 5527
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
Y6Z?;gKjWoT<O@Vn9<P!*uTE?K1?akFLI3~&

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_pipette.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_pipette.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..726997c876da484eed44142c19d505dc108c4e53
GIT binary patch
literal 5634
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
O3;N7#z0@c+jQ;}f5d-J|

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_rect_select.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_rect_select.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..d94bcc6a616d200c59074fb0512dac8c79c2e05a
GIT binary patch
literal 6694
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
F{{xscBjf-8

literal 0
HcmV?d00001

diff --git a/gui/widgets/tools/__pycache__/tool_view.cpython-39.pyc b/gui/widgets/tools/__pycache__/tool_view.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..1d60c3f85923024b823ed1e45abdab56c188caca
GIT binary patch
literal 4028
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

literal 0
HcmV?d00001

diff --git a/scripts/gmail_send_patch.py b/scripts/gmail_send_patch.py
new file mode 100644
index 0000000..06a8ae5
--- /dev/null
+++ b/scripts/gmail_send_patch.py
@@ -0,0 +1,109 @@
+import os, json, subprocess, base64, sys
+from pathlib import Path
+from datetime import datetime, timezone
+from email.message import EmailMessage
+
+# --- ENV / STATE ---
+ENV = Path(".env")
+STATE = Path(".glx/state.json")
+
+def load_env():
+    data = {}
+    if ENV.exists():
+        for ln in ENV.read_text(encoding="utf-8").splitlines():
+            ln=ln.strip()
+            if not ln or ln.startswith("#") or "=" not in ln: continue
+            k,v = ln.split("=",1); data[k.strip()] = v.strip()
+    for k,v in data.items():
+        os.environ.setdefault(k,v)
+
+def git(*args) -> str:
+    return subprocess.check_output(["git", *args], text=True).strip()
+
+def short7(sha:str) -> str: return sha[:7]
+
+def build_patch(base_sha:str, attach_path:Path):
+    patch = subprocess.check_output(["git","format-patch","--stdout", f"{base_sha}..HEAD"], text=True)
+    attach_path.write_text(patch, encoding="utf-8")
+
+def build_message(subject:str, body:str, attach_path:Path, sender:str, to:str) -> EmailMessage:
+    msg = EmailMessage()
+    msg["From"] = sender
+    msg["To"] = to
+    msg["Subject"] = subject
+    msg.set_content(body)
+    data = attach_path.read_bytes()
+    msg.add_attachment(data, maintype="text", subtype="plain", filename=attach_path.name)
+    return msg
+
+def gmail_send(msg: EmailMessage, credentials_path:str, token_path:str):
+    # Lazy import (szybciej ładuje w hookach)
+    from googleapiclient.discovery import build
+    from google_auth_oauthlib.flow import InstalledAppFlow
+    from google.auth.transport.requests import Request
+    import google.oauth2.credentials as oauth2
+
+    SCOPES = ["https://www.googleapis.com/auth/gmail.send"]
+
+    creds = None
+    if os.path.exists(token_path):
+        creds = oauth2.Credentials.from_authorized_user_file(token_path, SCOPES)
+    if not creds or not creds.valid:
+        if creds and creds.expired and creds.refresh_token:
+            # refresh
+            from google.auth.transport.requests import Request
+            creds.refresh(Request())
+        else:
+            flow = InstalledAppFlow.from_client_secrets_file(credentials_path, SCOPES)
+            creds = flow.run_local_server(port=0)
+        # save token
+        Path(token_path).parent.mkdir(parents=True, exist_ok=True)
+        with open(token_path, "w", encoding="utf-8") as f:
+            f.write(creds.to_json())
+
+    service = build("gmail", "v1", credentials=creds)
+    raw = base64.urlsafe_b64encode(msg.as_bytes()).decode()
+    return service.users().messages().send(userId="me", body={"raw": raw}).execute()
+
+def main():
+    load_env()
+    if not STATE.exists():
+        print("Missing .glx/state.json (need base_sha)", file=sys.stderr); sys.exit(1)
+
+    st = json.loads(STATE.read_text(encoding="utf-8"))
+    base_sha = st.get("base_sha")
+    if not base_sha:
+        print("state.json missing base_sha", file=sys.stderr); sys.exit(1)
+
+    cred_path = os.environ["GLX_GOOGLE_CREDENTIALS"]
+    token_path = os.environ["GLX_GOOGLE_TOKEN"]
+    to_addr   = os.environ["GLX_MAIL_TO"]
+    project   = os.environ.get("GLX_PROJECT","glitchlab")
+    branch    = os.environ.get("GLX_BRANCH","main")
+
+    head_full  = git("rev-parse","HEAD")
+    base_short = short7(git("rev-parse","--short=7", base_sha))
+    head_short = short7(head_full)
+    seq = datetime.now(timezone.utc).strftime("%Y%m%d%H%M%S")
+
+    Path(".glx").mkdir(exist_ok=True, parents=True)
+    attach_name = f"glx-{project}-{branch}-SEQ-{seq}-{base_short}..{head_short}.patch"
+    attach_path = Path(".glx")/attach_name
+    build_patch(base_sha, attach_path)
+
+    subject = f"GLX DIFF | {project} | {branch} | SEQ:{seq} | RANGE:{base_short}..{head_short}"
+    body = f"Project: {project}\nBranch: {branch}\nBase..Head: {base_sha}..{head_full}\nSEQ: {seq}\nAttachment: {attach_name}\n"
+
+    sender = "me"  # Gmail API przyjmie 'me' (konto z tokena)
+    msg = build_message(subject, body, attach_path, sender, to_addr)
+
+    resp = gmail_send(msg, cred_path, token_path)
+    print(f"Sent via Gmail API: id={resp.get('id')}  subject={subject}")
+
+if __name__ == "__main__":
+    try:
+        main()
+    except KeyError as e:
+        print(f"Missing .env key: {e}", file=sys.stderr); sys.exit(2)
+    except subprocess.CalledProcessError as e:
+        print(f"git error: {e}", file=sys.stderr); sys.exit(3)
diff --git a/tests/__pycache__/test_hybrid_mosaic_algo.cpython-39-pytest-8.4.2.pyc b/tests/__pycache__/test_hybrid_mosaic_algo.cpython-39-pytest-8.4.2.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..289faa2fe90c53361d2ff60a4bc0f6092082a241
GIT binary patch
literal 11098
zcmbVSYm6LMR<2uB-Cg~dp0_<?J5I+*jC)CD=i&IV>o`tqCn2#16DJ|`Iutd1YkGR7
zr@MWt#`ersvsT6s2QUQK6|B~ZW}*dQek{uZ(f&XyBz6%(0<H36g-ZNDS&76ykOKSw
zMM2AVPF26g2}I1OZ=bsN)P3LYeCOPD1_m-3{=WD8-!B;tXxfkIq4zI=hf|s+yn{m1
zq*l_Tka|t5>Lp!}Y}AaB$=`|9q^=2VHC3|Wl5{DJ60??B&6cupUamC2+WAtRzXw-`
z_^n}1M@pkYb4QoQO5<*Rd6!Jc<Sijn(z>B-iqh^VucFEH+d^h;=`t&GTr$z4Js|U(
zHyP&*%AtzR+QV{$ONQmB9J`^F_Q-L$3*UR?ZaIPPeR$)(t^INmE$n$)Z0mBb+{bU+
zFYlB4p;3_c%L2Y1kPpZM_&y*Xln>$iLHV#ei0_A_aZxM&)Y@-h)-t~9`QGO#wU^cx
zR8`um4bQ2TZKqagOf}atB@{VV3#9Sae|EKS^#`vxUcK>yZ<MQztLx>ZLbagWigLa6
z<vKmenp2>P)@9?WTWJ)i8ny1Pt`(lV_~Lu7-#FjcaH=cLROThMR$gkXej!sRG}o#2
z!lRcncWG6NBFsAVdc$}8YNPJW<Jmk{_53io+K_8C7taZ=+-SOG((e5;@Nk;;K@Nhi
zZ3$mn*0;q)?T(l)8lkbY>Xb4LhAQ2f?|7x`*;k%Cf8pF&`{E0y?`X=xTbz9KrPE)y
z^pfW)?~-iPSKLb%Ff>Q4UQmr?x9oeDDz&O#UaC0@b~DQA=3L?#<@A$hG)z$slyh|w
z&3QT!O;@zP@0jn?1O3Iq51*(+&;Q&OK6s+2E86a1vgs&i)hlDicm7DG56?joLZB^c
z7d1s9%^JS~A*I~QYnbxxh*cUYp;2>I?}O0p)iC5T_Yea8k!<4AH_3q(U>mlZ(Nzix
zVXoX*ZDLz^Hb#p+(*PCKx3kRz%|`73l(btNg^blQE7*;9X(iQolw&Np*I4GHZ{*Y|
zYL`1!fIuU^WVA#}ZyCN=)&o5-qzHs>Nc~m<``?(qOE26>luXsQ>V;;xQA6svt_;nU
zYF(BrS5{oxUs6R=4MH^@*uq-1);=Ynb@t3NXYCiCeE~W{q_Y=EC|(G~>74_`?xlnE
zFcduMuBPXND&V_p&{O<JeWK;!fn0|`+c=tG3`E<~Asd128{1~f3;=4AS}PGGyl15@
z4d2{?ye+C?m)1)9Nj#^5<hIxpuL((drZi*yYoA45V)GOe^QGNCGXp$mE;)9yw&vLj
zuJ73HWqW2L?|3*Re&OLm&Gnh07aI72_MF{beH>r_3eIw)?iMYcK{bL=m4>SID~_r<
zb>FkgOKy2Z(Z&liry?-09Tlc+&slVp+f-rxNp1(VomHx#!clv%p;jH=cCR&SPMv|G
znCjVN1*%MU&V>fr3A3mb`;fXiUE+u6_1T?kbUy<jMvEa_sXF$~PJSNMdIS@i$cZ5_
zEmRS5-%gxBMiw7l!0%#dqXm@0*SE1BeIvkfsOdOYr(CH;xxb=MYIVJ$wRGT?*)p)u
z*s+1;>zi0?Y0v@&i50z-43cjO?`1!+m6T?XTojT^7WHjYCjHcwwXI#zyc;M_``Wfp
zzX>TrQe8(m<iOY#=uunqTcn9YEYx?o6cRLhHGbI92>UcrojU%VHK?_ZStDu<R<W&t
z9#4=CMl9YG>HukxjFv2Z!`v49jSVc*w=Hbpl+4I%kmBuZ`B{|a0;|29O|50%W8#y<
z%!oG)_2+?3DdyJ1yy2*zezS!+z_T9BB%U*vVFR<74bnk&CDF<Sxz<3CL!bT<x%nUy
z<dKVmgxrBQb?-Z9Hz}coc^;s5c%Jh;<N6R9=^)MH`iRE>8RN>coW*zsZ|fKjth^i!
z26;R~fw46Z3~dXcp>18=j9W>dl@aO#w=&vkMd$TS2N|@Yt6$=pA)}R1mh)(3j9VEd
z#t;m1D<j;>2(<#OJTP$gwqDiHmr*$(CxcPe8jI(4tY>Zq;`z<tJBv>OGlSMAv{ud^
z404;Im6dw{LD|4u(OTod_?w3JO&-JEU>sxEM<qOl`#NJVygkrJ`-2#Rp&p`slZ-Lk
zhq;P(BkDOtT0EbIdXBV6ruoEJyIPB^Me|{(CTsQ12WFk~u&d<$+X;+#7xAKC7ms*%
zJmTFwBW{m$9A}My?}7QyP>pJ6IJKH0J5&@O>5o5N6dNw#-LayV`Eo229%l%gZD&D<
zv!;vQ)EWDHrgex^=ZfAVta-RCJk}PD6un}mRd_tAX$EK-p=ALLGd312g4bzEW+|DY
z<S-?VQF4TmW1$HIp4k}e#bq?g*>iW$|C7}J5$X%|@nqB*IuYt}24;GSTAM+#ks_U=
z5vCu-JEQb`y!*}!-p5O`MV%Tx&MnMtSfn+B(ed+PMQo(MH>k2iojm&f*M4;HgY4As
zNldFaffl|<@1iTwtU~Bc;US(q%t_(V_CyzHwodR9RsxH(;1v_<QR+XDiS9_$+&z83
zqHzDFi$grgr3^SMnX0PvB0FT%+<M8t!l?szI~=yl*aSA&BC>3ba>E?i6ygGYweE$<
zS_2whIAMEBjWzHCQnf3!#)4C`>&~jH9;8k^L<uo~FzGa#Ze51?wk2C=G-{2eI)%dG
z1oHy*IZ`zIMzhy|%|r$)THvEmH=>7`>0Z6#QBh>*W@h`I4y$9RT77})@3D=CdmrZ1
zArzN*m~s6xQF&D5k=}=6kzU-`Twi04^_3mzD?3)|X}+(<<9%<<>@?I9k)fWoS6yGh
zTfs`%3yxPUKZZ_wV@NcS7YFs9Xmf0-hr~~`<3hcR{61?<wwyk&)53cX0=z2mwrGip
z_6BI}8ST{zWR01E>D%Cv;FYi|%f@caHzi4lO+A(klo*{7BP!X{_rgZq)V7iVkVt5k
zhhEo!j)pXEz%u&QP56vbpFnyBpH{+82MK(`!h1g=&(hCqW!aj4)6Z=U_`pH+El7Ei
zfQU(wiSqF`sGdySHpp`NgUA^QQa$*VXeAlfta(KQ<u0AgzR4hVPrd~X3|wglf%fYD
zmbi(DnA9kh+HP$U6SP}f5ii5jxU5U?{-U9N9?I$@l6hXJJ9?;3O^2d-2d>){oQr7r
z*vCkpsJL~|Hg)n@=>G>k+Qtm8=IIw~_=p|42=ZmaA6byj)QRYHot)~tyYWa5!U1j~
z%z)5?83ZQ)Dd2?qX|#fFGCDBCO;g5jmyd?xVkn*sjaBDbC`#%X6o(1r)GMxf3Nlxq
z&X9DL5&{MFG$sAV8Wfitosx-;d+hFn;#{bgm3oepFCghXHjhQ~@+B(c$=UzEPsAxG
zdU+(8ZV6LZ*xE<%Q5EE{=Wz#djwN?Zl`P<nQ!l%+lyd97YBbmTybL-Z<Y}CymEMod
z?`z~F;X}?6yoy`!G2kiCQ-Zt?KMCrf-!d=hEwhyXfdb78OyAnnTd5$`vVxR)5#%Wi
zf|>?-$^;qYS)hD1X-aJBtqgBs<!85YJ~pKaAPta&O-$Rot?^aTprfMRA`Oygo6A&3
z;~lO8G*JB&*8vF{Db_}P(z<Qp0AzzC4hBd7=v4~T?kSWHN)Q+vz6|v;Cd+ZV=;;vE
zOYK2>57!pA%`%Rg%rd>o$sA~4j%maIw=zJjKx-&S%6v?(@)Be($g|d<KaA3m08}UP
z#6YJke3JO2@X55&@r)*XtvjRW$G81ahJ&=sw}wE!hE~kha4^hsYj}F^++qapq7|N9
zy!lVm>(2ZRw`UJp|3z8^8K99mX_1T>MBu5TrF;9iE|7R=9pbtoLO;T9eA+zg>K{=)
zC`W@~%<~xanCE%Cr{-&1^C;K+8rKXN?T^cDFLjSrzun6}BCU2WS;lJcH|Vq6#p|6%
zc&szuyegROdsbzHN$&`+%4obQX#EpcC5@FCZVfSH?wMChI4*!Q%X4c80W}me!i^~c
z8Bn(fe;~y81KhcX@BxUzOw|Kj@abrV;<+%fSZg>wVh0RL<XtL4CN)dR5hQKm1&Y%q
zYeWsf)QHun!$@Mz1(v7C_<aK9LbsUifFerQ4^3Gu`{05C%xhzo2^*@6MnILvLqL-}
z1aLm0S|^!m5w&APM4!0_Uu<_nJ>KmL8tf;1sDnx0@#2_j(i;RmVZOOk1yN$=1?mv)
z?tivB7`AIiK@4f3Mfv3h0$CJ1P%D(IQu3)tO~9^zdYU5Z)8%8)n8ws7<rXNRKu*cP
zYO5MOHYgzwkMKLPK94a+QqNP_xlUQcf{v>5ls!+$MI?QErk}UXMP)I|npH1SRZP61
zs%EEm(w}j*6YbF>oVi%7yYgr8p0^8$rt2^d`2TOy)IT;8yTE=f3blcfzHlCmmh2Uq
zfe*k3B;sYgY=`2f6ov2+dV*Q#7=XU~M4S&V959A}6Ffpe5CwB!c~|`8a;lXfe_NXH
zwF!Ka@C|b^amyqR8(L|=(%<^lR$3+l3&6p3FmPBM{_}?@&rvW7plAUOAOSQineJ#%
z4Uy@1mo*~zPRk6#cAnz!Z9ooEFb)h5Y^2_jh{w0<L0`tGCLb*TNcU4+B%`%F*9$MR
z+bXo5BJJ34oMVl4%bngsYl*d@Iu&chBVd`lRT@<;{)S0G%pe6r1`db5a-0AfgF#9T
z#U^H$AiM47`$H%l4&do`z>ENl%nO;C3_j$=BhtZuHah?Q9RL0J301`osC<0q-`+jH
zaN&vfZ~g0EZ2jloeEVckFCk1^v;9V`l!9|b0y)4Z`W(m;kpoE%pZ?q|J{>2La4d2n
zfd&j{8*7X;9lv>oKrME6;gQ7v1gQ%^Q&q2AYj|$#J`*}c{xf->kKpEk`}a84i#|M3
zh&vkPpkcyX6M@1dL<i^4BlRRD1e@vvB?MZkj)dXq7!%n(=$b{7REF=7E?rb>^d5tb
zN0Lv;btGXb?r}sB8ELv;)Mbo}L;Vm`9F5|a1*(f9<wU{NSEyEDt6!#v4vUO{hcHK7
zL(&HzvBMR^$x*dPT30(-v6FUOt?$U1y(b)cs0}l-HbS`e)rRsYAnw#{K+lW~huOK}
zDyQO>P?bkWq5*YsVnR&lY7<X=XhWD!AA?Be_aGp`sNdj7{g&9)$p3i*QPO4jSa3BE
z%$DXY^9{tUUe{h1i%b)5SU1I1GSY>Y1lk9W3<w2UgkU%#b%+j03vnl$P|9Zv$+XFb
z7oa>FAm*rk6;h5QoazkA6cLRGUV;f;f=NQs2Z_S@!&&W|D@11b4CUwhyeABcy(fUZ
z@b=-MO8(Or7&AIb;mBpUk=xqu>X%L2l~_<f=){Eo>d@Uoa~=N4FCbIVT!x~)6Y?`B
z$ZS*e;bfWAei6yWY_vdL)n3HC#e!2_K`@=X7LOcbr^j*XysQTBA{?{?-+`43+;8*^
zgPcHGC7c%F5f8y2K8Lt9I|y6GP1pf)2bU8!5u2XWCO`|NwqkC!9YWl;ft|1~SWHs*
z-4FG8vy`k=>$nRnnRNv2!$iFyT~FOW_39NQ)E{TjcU72NaIrz%X!PV0saKJ>B=CqM
zSF!mSM%;EYnGmVVr~!0mn4p3nCZaPG8cRhpCeds54~d2KU2Gr{#UZicp!yAzg^8-~
z!n>nM3Uj?Zi9<);+A404+;#8&z<`HP0SAMCO`{|iD0ve}FUOeeVI9%YJ*<9?6ln*k
zTa@&;j=kOK+X@R%jBhT+#E94@)bAmu?|jnvrAklJ%Kse%Sb4sBqPq*S@i=b=?$78N
zisR{Ycd?1s1<nJXKb%8EFktE7ECxx)sUV@A3sT-YK1I+GQ4dl$$KVH4zKAO<<im}`
z4nibkE6pzAb>#8=g!(lu#ks^8O|gtq2=|WS8?gIu<19X-={S}Pr=WXAVe1n3q~e%I
zcAodWx`|;`@WJ1QPeegoUA6GUNl}kNqeOzcmMzMo*g~8~d^+LOs+Bs<EC(Aqr2V7b
z8!^~7Haf+D$a4G+wL?Y&afWKWG%9haO`ZT<k;d2VJzM5M(%xY^x?3jG-7=*#z0b!-
z{XV^Ph?1{Sa)pu$lo0-_mnh+V!wK)3VTKSM4Mkk0?U_|*c}XN1Hp+xh-+)Ar)A=Lg
zM7y6iiVxaI8-=cm_)ZaC>8(VIuCz3G_Sz;cy(n_D2Cs(hCnXjUKeNygI!lh>dpEAT
z2puOiAf?eVK_L@}Enq1Td^>@>Bt8^jNCx_fuIiUxp{)|60%Jl80QCSMohYPCt(fYS
zAigX>Z0Z$1OTM$zq(v8N*qCE<opeJ`bb`I=te*?AFeC8j=>jMiK;$AH<U!V?Kd_aD
zm!F3r$x{g%l0koPYlt=}G&E=o`=D!}h#ANuBx9q(>+jJzNLmzyfYvl=kqoUNmWk|9
z9+ACa_F@O+2z=-Gg2*35=@?PJ&bFp2ihNAr#^>+SD&94aC}RC;0!b;0OLDsm4++0s
zSfhRUlyX)IWDTUlztHF@FT8jCtNhE3LbHJ#S^fUk{q?B`FUP6E07)N2(5|2eA=|hm
z2v{wwB!@|Hy$&O+L!QD4Y60AWN!(RaXj2+1ni@k6Zl4iK#gWDiNVH6>(wWO+Fx*z4
zQ+{AnL<L3}`4+`|Kn_sfCYcm#{^_V=)F-BCFWzIesCV460{0AtYa-fvlh~oygD_W{
zAQHdL78r1kof}nEM0^M`vd995qO$XlWKPs@R@wOSA!bwbJf9qz&L#|RwO+CPs|~yE
zRx3*j4P|?{5OBS&30_z$ueg47!|i5uYemzis5j40H<IcSzF?XgwJ=#xjkTs1iYuig
zuDTJ?Q*V*tj#HfO)cyuay%8it#iA(T7*4T?v%GQi|JmcaL<-vRh-osRFq{!zhY-_s
zSk?9|4aW;2W>4gw=2mSXLC}CrEMq1|JBVPYuTwHd<%kQ?*LZ}N`zW9BGF8F;^?lHT
z=;s0WoyJPFsV1Qirrr7)?pGXa`0MnXSXys3{3wK*^cu>?lyMIZP<6npdr<X3%IiYw
za461~Qt=TgrB?BqsH(hH(yvXIblkrs2)4bLrXgCq9tx@6rYg25>EbTA<DZVZ4}F%k
zAk_A#-<lW$ueL-+&x@RH;>i*^r}!O$p2=9c`V(mN9f<*C&^BS1-iOVO0}6-+gwStd
zG-)uzUTK*W`b8*_eom5reNO_u6TX0r$DskZCOHV43{VCM$CAUqfaJdXRGgm%RHqOG
zHq}M||NJOg!x5((f&hba4CD}N=Rh&Ql>F^<Cpg>Y?b)_R?tLHS%+}REKpKd7JN)^M
z#=o!zfJJ@C8WC$ipq73AEN+emgDkU!oKIdnZm`?1ir56*_72UfFJrP86z-0Z#1P05
z0V})7(M87*Jc3K|Eh=-#XsgqOsChNM4aAR4C`!lMoq~IPjFN(A1kJd9EK}8FOjT#M
z^ABVq57VOppOVkIc?Wua1oNl#;&&+7L&+agau7+VFVCpgBH><oITtyMI{;=cZ&weT
z$Bv{`x)Al8)n?7TjjBAFqX=?xyjS4^(thPVtKLCb@!>FK+p<x%?J#58i);Rxa&24b
zC=0FjO)4{<aMF&>`Bdb@;%atExmOj4cL=gWzvDp`{fv$CqRF{V^(6iECXiSe^pF5B
zG}qOyLsox)q;#<JyS=H(T6HS=LDp3KyT>jGD;X$N1$txno<d%%(op+%U-p@^Pe1w6
zxff%cTC859Vf8G+D79Xs<Yh{Td{RV0t%O<rIUe0#ZnzwqW0#qEIdd*P(L8lMXwS>S
y#LYSp{T%WnO(1(}W-2ER03Ix1=@WV~l@S?Z2%q>nZ6&R&HHe&yWkJeV5C0FthRVzU

literal 0
HcmV?d00001

diff --git a/tests/ast_mosaic_coupled.py b/tests/ast_mosaic_coupled.py
new file mode 100644
index 0000000..5343829
--- /dev/null
+++ b/tests/ast_mosaic_coupled.py
@@ -0,0 +1,731 @@
+# -*- coding: utf-8 -*-
+"""
+demos/ast_mosaic_coupled.py
+---------------------------
+AST ⇄ Mozaika: sprzężenie dwukierunkowe + interaktywność.
+
+• Edytuj kod po lewej, [Ctrl+Enter] lub [Render] → AST i Mozaika się przeliczają.
+• Klik na mozaice:
+    - LPM: ustaw ROI-A na klikniętej komórce,
+    - PPM: ustaw ROI-B.
+• Klik na węźle AST: wybór węzła (do fuzji; opcjonalnie wpływa na mozaikę przez η).
+• Suwaki:
+    λ – meta skala (detal → centroidy grup),
+    β – siła regionu (fuzja),
+    γ – sprzężenie AST→Mozaika (ile mozaika pochodzi z AST),
+    Δ – feedback Mozaika→AST (miękka aktualizacja meta-wektorów),
+    η – wzmacnianie wkładu wybranego węzła w raster AST→Mozaika.
+
+Wymagania: Python 3.8+, tkinter, numpy, matplotlib
+Uruchom:   python demos/ast_mosaic_coupled.py
+"""
+
+from __future__ import annotations
+import ast
+import math
+import tkinter as tk
+from tkinter import ttk, messagebox
+
+from dataclasses import dataclass
+from typing import List, Tuple, Dict, Set, Optional
+
+import numpy as np
+import matplotlib
+matplotlib.use("TkAgg")
+import matplotlib.pyplot as plt
+from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
+
+
+# ─────────────────────────────────────────────────────────────
+# 1) Struktury danych
+# ─────────────────────────────────────────────────────────────
+
+@dataclass
+class AstNodeMeta:
+    name: str
+    kind: str
+    pos_det: Tuple[float, float, float]                      # pozycja przy λ=0
+    group: str                                               # grupa dla centroidu przy λ→1
+    meta0: Tuple[float, float, float, float, float, float]   # bazowy meta-wektor (L,S,Sel,Stab,Cau,H)
+    meta: np.ndarray                                         # aktualny meta-wektor (z feedbackiem)
+
+    @property
+    def energy(self) -> float:
+        return float(np.linalg.norm(self.meta))
+
+    @property
+    def entropy(self) -> float:
+        return float(self.meta[-1])
+
+
+@dataclass
+class Mosaic:
+    rows: int
+    cols: int
+    base_edge: np.ndarray    # stała „tekstura” (rows*cols,)
+    edge: np.ndarray         # aktualna mapa (po sprzężeniu z AST)
+    roiA: np.ndarray         # maska ROI-A (rows*cols,)
+    roiB: np.ndarray         # maska ROI-B (rows*cols,)
+
+
+# ─────────────────────────────────────────────────────────────
+# 2) AST: parsowanie, grupy, meta
+# ─────────────────────────────────────────────────────────────
+
+def _node_label(n: ast.AST) -> str:
+    if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
+        return f"def {n.name}"
+    if isinstance(n, ast.ClassDef):
+        return f"class {n.name}"
+    if isinstance(n, ast.Assign):
+        try:
+            t = n.targets[0]
+            if isinstance(t, ast.Name): return f"{t.id} = …"
+        except Exception:
+            pass
+        return "assign"
+    if isinstance(n, ast.Name): return n.id
+    return type(n).__name__
+
+
+def _attach_parents_and_depths(tree: ast.AST):
+    def walk(n, parent=None, depth=0, fn=None, cls=None):
+        setattr(n, "_parent", parent)
+        setattr(n, "_depth", depth)
+        setattr(n, "_parent_fn", fn)
+        setattr(n, "_parent_cls", cls)
+        if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
+            fn = n.name
+        if isinstance(n, ast.ClassDef):
+            cls = n.name
+        for _f, v in ast.iter_fields(n):
+            if isinstance(v, ast.AST):
+                walk(v, n, depth + 1, fn, cls)
+            elif isinstance(v, list):
+                for it in v:
+                    if isinstance(it, ast.AST):
+                        walk(it, n, depth + 1, fn, cls)
+    walk(tree)
+
+
+def _group_of(n: ast.AST) -> str:
+    if getattr(n, "_parent_fn", None): base = f"G:def:{getattr(n, '_parent_fn')}"
+    elif getattr(n, "_parent_cls", None): base = f"G:class:{getattr(n, '_parent_cls')}"
+    else: base = "G:top"
+    d = getattr(n, "_depth", 0)
+    return f"{base}/D{d//2}"
+
+
+def _coords_for_tree(tree: ast.AST) -> Dict[ast.AST, Tuple[float, float, float]]:
+    per_level: Dict[int, List[ast.AST]] = {}
+    type_bucket: Dict[str, int] = {}
+    def walk(n):
+        d = getattr(n, "_depth", 0)
+        per_level.setdefault(d, []).append(n)
+        for ch in ast.iter_child_nodes(n):
+            walk(ch)
+    walk(tree)
+
+    b = 0
+    for n in ast.walk(tree):
+        t = type(n).__name__
+        if t not in type_bucket:
+            type_bucket[t] = b; b += 1
+
+    order_on_level: Dict[ast.AST, int] = {}
+    for d, nds in per_level.items():
+        for i, n in enumerate(nds): order_on_level[n] = i
+
+    coords: Dict[ast.AST, Tuple[float, float, float]] = {}
+    for n in ast.walk(tree):
+        x = 2.0 * order_on_level.get(n, 0)
+        y = 2.0 * type_bucket[type(n).__name__]
+        z = 2.0 * getattr(n, "_depth", 0)
+        coords[n] = (x, y, z)
+    return coords
+
+
+def _meta_for_node(n: ast.AST) -> Tuple[float, float, float, float, float, float]:
+    rng = np.random.default_rng(abs(hash((type(n).__name__, getattr(n, "_depth", 0)))) % (2**32))
+    L, S, Sel, Stab, Cau, H = rng.uniform(0.30, 0.85, size=6)
+    if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
+        Stab = 0.85; H = 0.35; Sel = 0.55
+    if isinstance(n, ast.If):
+        Sel = 0.80; H = 0.55
+    if isinstance(n, ast.For):
+        S = 0.70; Cau = 0.60
+    if isinstance(n, ast.Call):
+        Sel = 0.65; Cau = 0.55
+    if isinstance(n, ast.Assign):
+        L = 0.55; Stab = 0.70
+    return float(L), float(S), float(Sel), float(Stab), float(Cau), float(H)
+
+
+def ast_nodes_from_code(code: str) -> List[AstNodeMeta]:
+    tree = ast.parse(code)
+    _attach_parents_and_depths(tree)
+    coords = _coords_for_tree(tree)
+    nodes: List[AstNodeMeta] = []
+    for n in ast.walk(tree):
+        if isinstance(n, (ast.Module, ast.Load, ast.Store, ast.Del)):
+            continue
+        name = _node_label(n)
+        kind = type(n).__name__
+        group = _group_of(n)
+        m0 = _meta_for_node(n)
+        nodes.append(
+            AstNodeMeta(
+                name=name,
+                kind=kind,
+                pos_det=coords[n],
+                group=group,
+                meta0=m0,
+                meta=np.array(m0, dtype=float)
+            )
+        )
+    return nodes
+
+
+# ─────────────────────────────────────────────────────────────
+# 3) Geometria meta: λ → pozycje
+# ─────────────────────────────────────────────────────────────
+
+def group_centroids(nodes: List[AstNodeMeta]) -> Dict[str, Tuple[float, float, float]]:
+    by_g: Dict[str, List[Tuple[float, float, float]]] = {}
+    for n in nodes:
+        by_g.setdefault(n.group, []).append(n.pos_det)
+    cents: Dict[str, Tuple[float, float, float]] = {}
+    for g, pts in by_g.items():
+        xs, ys, zs = list(zip(*pts))
+        cents[g] = (float(np.mean(xs)), float(np.mean(ys)), float(np.mean(zs)))
+    return cents
+
+
+def coords_for_lambda(nodes: List[AstNodeMeta], lam: float) -> Dict[str, Tuple[float, float, float]]:
+    cents = group_centroids(nodes)
+    pos: Dict[str, Tuple[float, float, float]] = {}
+    for n in nodes:
+        p = n.pos_det; q = cents[n.group]
+        pos[n.name] = (p[0] + (q[0] - p[0]) * lam,
+                       p[1] + (q[1] - p[1]) * lam,
+                       p[2] + (q[2] - p[2]) * lam)
+    return pos
+
+
+# ─────────────────────────────────────────────────────────────
+# 4) Mozaika: konstrukcja z AST + sprzężenie
+# ─────────────────────────────────────────────────────────────
+
+def build_base_mosaic(rows=10, cols=14) -> Mosaic:
+    rng = np.random.default_rng(42)
+    yy, xx = np.mgrid[0:rows, 0:cols]
+    diag = 1.0 - np.abs(xx - yy) / max(rows, cols)
+    base = np.clip(0.45 + 0.5 * diag + 0.06 * rng.standard_normal((rows, cols)), 0, 1)
+    base = base.reshape(-1)
+
+    roiA = np.zeros(rows * cols)
+    roiB = np.zeros(rows * cols)
+    return Mosaic(rows, cols, base_edge=base.copy(), edge=base.copy(), roiA=roiA, roiB=roiB)
+
+
+def _norm01(a: np.ndarray) -> np.ndarray:
+    if a.size == 0: return a
+    lo, hi = float(np.min(a)), float(np.max(a))
+    if hi - lo < 1e-12: return np.zeros_like(a)
+    return (a - lo) / (hi - lo)
+
+
+def _sobel_mag(img2d: np.ndarray) -> np.ndarray:
+    Kx = np.array([[+1, 0, -1],
+                   [+2, 0, -2],
+                   [+1, 0, -1]], dtype=float)
+    Ky = np.array([[+1, +2, +1],
+                   [ 0,  0,  0],
+                   [-1, -2, -1]], dtype=float)
+    pad = np.pad(img2d, 1, mode="edge")
+    gx = np.zeros_like(img2d); gy = np.zeros_like(img2d)
+    for r in range(img2d.shape[0]):
+        for c in range(img2d.shape[1]):
+            roi = pad[r:r+3, c:c+3]
+            gx[r, c] = float(np.sum(roi * Kx))
+            gy[r, c] = float(np.sum(roi * Ky))
+    return np.sqrt(gx*gx + gy*gy)
+
+
+def mosaic_from_ast(nodes: List[AstNodeMeta], rows: int, cols: int,
+                    lam: float, gamma: float,
+                    selected: Optional[str] = None, eta: float = 0.0) -> np.ndarray:
+    """
+    Buduje mozaikę z AST (pozycje wg λ, wagi = energia/entropia).
+    gamma (γ) ∈ [0,1] skaluje udział komponenty AST (reszta z base_edge).
+    selected + eta: opcjonalny „boost” wybranego węzła (η≥0) w akumulacji ciepła.
+    Zwraca "edge" (rows*cols,) po sprzężeniu z AST (przed blendem w App).
+    """
+    if not nodes:
+        return np.zeros(rows * cols)
+
+    # pozycje 2D (x,y) zależne od λ
+    cents = group_centroids(nodes)
+    def _pos_lam(n):
+        p = np.array([n.pos_det[0], n.pos_det[1]], dtype=float)
+        q = np.array([cents[n.group][0], cents[n.group][1]], dtype=float)
+        return p + (q - p) * lam
+    pts = np.array([_pos_lam(n) for n in nodes], dtype=float)
+
+    x0, x1 = float(np.min(pts[:,0])), float(np.max(pts[:,0]))
+    y0, y1 = float(np.min(pts[:,1])), float(np.max(pts[:,1]))
+    if x1 - x0 < 1e-9: x1 = x0 + 1.0
+    if y1 - y0 < 1e-9: y1 = y0 + 1.0
+    nx = ((pts[:,0] - x0) / (x1 - x0) * (cols - 1)).clip(0, cols - 1)
+    ny = ((pts[:,1] - y0) / (y1 - y0) * (rows - 1)).clip(0, rows - 1)
+
+    heat = np.zeros((rows, cols), dtype=float)
+    for k, n in enumerate(nodes):
+        r = int(round(float(ny[k]))); c = int(round(float(nx[k])))
+        w = 0.6 * n.energy + 0.4 * n.entropy
+        if selected and n.name == selected:
+            w *= (1.0 + max(0.0, float(eta)))  # boost wybranego
+        heat[r, c] += float(w)
+
+    heat = _norm01(heat)
+    edges = _sobel_mag(heat)
+    edges = _norm01(edges)
+    return (edges * gamma).reshape(-1)
+
+
+def region_indices(M: Mosaic, key: str) -> Set[int]:
+    if key == "ROI-A": return {i for i, v in enumerate(M.roiA) if v > 0.5}
+    if key == "ROI-B": return {i for i, v in enumerate(M.roiB) if v > 0.5}
+    return set(range(M.rows * M.cols))
+
+
+def region_centroid(M: Mosaic, ids: Set[int]) -> Tuple[float, float, float]:
+    if not ids: return (M.cols * 0.5, M.rows * 0.5, 0.0)
+    cols = np.array([i % M.cols for i in ids], dtype=float)
+    rows = np.array([i // M.cols for i in ids], dtype=float)
+    z = np.array([2.0 * M.edge[i] + 0.1 for i in ids], dtype=float)
+    return float(cols.mean()), float(rows.mean()), float(z.mean())
+
+
+def region_feats(M: Mosaic, ids: Set[int]) -> np.ndarray:
+    if not ids: return np.zeros(6, dtype=float)
+    ed = np.array([M.edge[i] for i in ids])
+    fL   = float(1.0 - np.mean(ed))
+    fS   = float(0.5 + 0.5 * np.std(ed))
+    fSel = float(np.mean(ed > 0.6))
+    fSt  = float(1.0 - np.std(ed))
+    fC   = float(min(1.0, 0.3 + 0.7 * np.mean(ed)))
+    fH   = float(0.4 + 0.5 * np.std(ed))
+    return np.array([fL, fS, fSel, fSt, fC, fH], dtype=float)
+
+
+def fuse_meta(node_meta: np.ndarray, reg_meta: np.ndarray, lam: float, beta: float) -> np.ndarray:
+    align = np.ones_like(node_meta)
+    return (1.0 - lam) * node_meta + lam * (beta * reg_meta * align)
+
+
+# ─────────────────────────────────────────────────────────────
+# 5) Rysowanie (szarości dla metawarstwy; relacje jaskrawo, przerywane)
+# ─────────────────────────────────────────────────────────────
+
+def draw_ast(ax, nodes: List[AstNodeMeta], pos: Dict[str, Tuple[float, float, float]],
+             pick=False):
+    cmap = plt.get_cmap("Greys")
+    for n in nodes:
+        x, y, z = pos[n.name]
+        h = 0.9 + 1.9 * (n.energy / np.sqrt(6))
+        c = cmap(0.35 + 0.55 * n.entropy)
+        ax.plot([x, x], [y, y], [z, z + h], color=c, lw=2.0, alpha=0.9)
+        scat = ax.scatter([x], [y], [z + h], s=30, c=[c], edgecolors="black",
+                          depthshade=True, picker=pick, pickradius=6)
+        scat._glitch_name = n.name  # tag do pickingu
+        ax.text(x, y, z + h + 0.35, n.name, fontsize=7, ha="center", color="black")
+
+
+def draw_mosaic(ax, M: Mosaic):
+    xs, ys, zs, dx, dy, dz, cols = [], [], [], [], [], [], []
+    for r in range(M.rows):
+        for c in range(M.cols):
+            i = r * M.cols + c
+            h = 2.0 * M.edge[i] + 0.1
+            xs.append(c); ys.append(r); zs.append(0.0)
+            dx.append(0.85); dy.append(0.85); dz.append(h)
+            g = M.edge[i]
+            cols.append((g, g, g, 0.92))
+    ax.bar3d(xs, ys, zs, dx, dy, dz, color=cols, linewidth=0.1, shade=True)
+    ax.set_xlabel("cols"); ax.set_ylabel("rows"); ax.set_zlabel("edge→height")
+    ax.view_init(elev=25, azim=-58)
+
+
+def draw_region_frame(ax, M: Mosaic, key: str, color="lime"):
+    ids = region_indices(M, key)
+    if not ids: return
+    rr = np.array([i // M.cols for i in ids]); cc = np.array([i % M.cols for i in ids])
+    rmin, rmax = rr.min(), rr.max(); cmin, cmax = cc.min(), cc.max()
+    z = 2.45
+    ax.plot([cmin, cmax, cmax, cmin, cmin],
+            [rmin, rmin, rmax, rmax, rmin],
+            [z, z, z, z, z], color=color, lw=1.6, linestyle="--")
+
+
+def draw_fusion(ax_ast, ax_mos,
+                node: AstNodeMeta, pos: Dict[str, Tuple[float, float, float]],
+                M: Mosaic, reg_key: str, lam: float, fused: np.ndarray):
+    ids = region_indices(M, reg_key)
+    cx, cy, cz = region_centroid(M, ids)
+    colors_reg = {"ROI-A": "lime", "ROI-B": "magenta", "ALL": "orange"}
+    reg_color = colors_reg.get(reg_key, "orange")
+    ax_mos.scatter([cx], [cy], [cz + 0.05], s=60, c=reg_color,
+        edgecolors="black", depthshade=True, zorder=10)
+
+    x0, y0, z0 = pos[node.name]
+    ax_ast.plot([x0, cx], [y0, cy], [z0, cz],
+        linestyle="--", color=reg_color, lw=1.8, alpha=0.95)
+
+    base = np.array([x0, y0, z0 + 0.28])
+    pairs = [(0, 1), (2, 3), (4, 5)]
+    rose_colors = ["cyan", "orange", "yellow"]
+    labels = ["⟨L,S⟩", "⟨Sel,Stab⟩", "⟨Cau,H⟩"]
+    scale = 1.2
+    for k, (i, j) in enumerate(pairs):
+        val = float(0.5 * (fused[i] + fused[j]))
+        vec = np.array([(1 if k == 0 else 0),
+                        (1 if k == 1 else 0),
+                        0.9])
+        tip = base + scale * val * vec
+        ax_ast.plot([base[0], tip[0]], [base[1], tip[1]], [base[2], tip[2]],
+                    linestyle="--", color=rose_colors[k], lw=2.0)
+        ax_ast.text(tip[0], tip[1], tip[2] + 0.08, labels[k],
+                    fontsize=7, color=rose_colors[k])
+
+    ax_ast.text(x0, y0, z0 - 0.6,
+        r"$m_{\mathrm{fused}}(\lambda)=(1-\lambda)\,m_{\mathrm{node}}+\lambda\,\beta\,\psi(\mathrm{region})$",
+        fontsize=7, ha="center", color="black")
+
+
+def draw_infographic(ax):
+    ax.axis("off")
+    ax.text(0.02, 0.92, "Infografika sprzężenia", fontsize=11, weight="bold")
+    ax.text(0.02, 0.82, "■ Szarości: warstwa meta (AST, Mozaika)", fontsize=9, color="black")
+    ax.text(0.02, 0.74, "◆ ROI: lime / magenta / orange", fontsize=9, color="lime")
+    ax.text(0.02, 0.66, "— — przerywane: relacje node ↔ ROI i róża metryczna", fontsize=9, color="magenta")
+    ax.text(0.02, 0.58, "γ: AST→Mozaika;  Δ: Mozaika→AST (soft feedback);  η: boost wybranego węzła", fontsize=9)
+    ax.text(0.02, 0.46, "Jedna arytmetyka relacji:", fontsize=10, weight="bold")
+    ax.text(0.05, 0.38, "m_fused(λ) = (1−λ)·m_node + λ·β·ψ(region)", fontsize=9)
+    ax.text(0.05, 0.30, "λ: detal → centroidy grup (supergraf)", fontsize=9)
+
+
+# ─────────────────────────────────────────────────────────────
+# 6) GUI (Tkinter + Matplotlib)
+# ─────────────────────────────────────────────────────────────
+
+DEFAULT_SNIPPET = """\
+# Edytuj kod i naciśnij Ctrl+Enter (lub 'Render')
+def f(x):
+    y = x
+    if y > 0:
+        y = y - 1
+    return y + 1
+
+class K:
+    def __init__(self, a):
+        self.a = a
+
+def g(n):
+    s = 0
+    for i in range(n):
+        if i % 2 == 0:
+            s += i
+    return s
+
+z = f(3) + g(4)
+"""
+
+class App(tk.Tk):
+    def __init__(self):
+        super().__init__()
+        self.title("AST ⇄ Mozaika — sprzężenie meta (λ, β, γ, Δ, η)")
+        self.geometry("1440x940")
+
+        # model
+        self.nodes: List[AstNodeMeta] = []
+        self.pos: Dict[str, Tuple[float, float, float]] = {}
+        self.node_by_label: Dict[str, AstNodeMeta] = {}
+        self.M = build_base_mosaic()
+        self.reg_key = "ROI-A"
+
+        # layout
+        left = ttk.Frame(self); left.pack(side=tk.LEFT, fill=tk.BOTH, expand=False, padx=8, pady=8)
+        right = ttk.Frame(self); right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=8, pady=8)
+
+        # editor
+        ttk.Label(left, text="Kod Pythona (Ctrl+Enter = Render):").pack(anchor="w")
+        self.txt = tk.Text(left, width=66, height=32, wrap="none", font=("Consolas", 10))
+        self.txt.pack(fill=tk.BOTH, expand=True)
+        self.txt.insert("1.0", DEFAULT_SNIPPET)
+        self.txt.bind("<Control-Return>", lambda e: self.render())
+
+        # controls
+        ctrl = ttk.LabelFrame(left, text="Sterowanie")
+        ctrl.pack(fill=tk.X, pady=6)
+
+        row0 = ttk.Frame(ctrl); row0.pack(fill=tk.X, pady=2)
+        ttk.Label(row0, text="λ").pack(side=tk.LEFT)
+        # ZMIANA: λ teraz wywołuje pełny rebuild mozaiki (a nie tylko repaint)
+        self.s_lambda = tk.Scale(row0, from_=0.0, to=1.0, resolution=0.02, orient=tk.HORIZONTAL, length=220,
+                                 command=lambda _v: self.on_lambda_changed())
+        self.s_lambda.set(0.0); self.s_lambda.pack(side=tk.LEFT, padx=4)
+
+        ttk.Label(row0, text="β").pack(side=tk.LEFT)
+        self.s_beta = tk.Scale(row0, from_=0.2, to=2.0, resolution=0.1, orient=tk.HORIZONTAL, length=140,
+                               command=lambda _v: self.repaint())
+        self.s_beta.set(1.0); self.s_beta.pack(side=tk.LEFT, padx=6)
+
+        row1 = ttk.Frame(ctrl); row1.pack(fill=tk.X, pady=2)
+        ttk.Label(row1, text="γ (AST→Mozaika)").pack(side=tk.LEFT)
+        self.s_gamma = tk.Scale(row1, from_=0.0, to=1.0, resolution=0.05, orient=tk.HORIZONTAL, length=220,
+                                command=lambda _v: self.recompute_mosaic_from_ast())
+        self.s_gamma.set(0.7); self.s_gamma.pack(side=tk.LEFT, padx=4)
+
+        ttk.Label(row1, text="Δ (Mozaika→AST)").pack(side=tk.LEFT)
+        # ZMIANA: Δ po zmianie aktualizuje meta i natychmiast przebudowuje mozaikę
+        self.s_delta = tk.Scale(row1, from_=0.0, to=1.0, resolution=0.05, orient=tk.HORIZONTAL, length=140,
+                                command=lambda _v: self.apply_feedback_and_recompute())
+        self.s_delta.set(0.0); self.s_delta.pack(side=tk.LEFT, padx=6)
+
+        row2 = ttk.Frame(ctrl); row2.pack(fill=tk.X, pady=2)
+        ttk.Label(row2, text="η (boost wybranego węzła)").pack(side=tk.LEFT)
+        self.s_eta = tk.Scale(row2, from_=0.0, to=3.0, resolution=0.1, orient=tk.HORIZONTAL, length=220,
+                              command=lambda _v: self.recompute_mosaic_from_ast())
+        self.s_eta.set(0.0); self.s_eta.pack(side=tk.LEFT, padx=4)
+
+        ttk.Label(row2, text="Region").pack(side=tk.LEFT)
+        self.cmb_region = ttk.Combobox(row2, values=["ROI-A", "ROI-B", "ALL"], width=10, state="readonly")
+        self.cmb_region.set("ROI-A"); self.cmb_region.pack(side=tk.LEFT, padx=6)
+        self.cmb_region.bind("<<ComboboxSelected>>", lambda _e: self.on_region_changed())
+
+        row3 = ttk.Frame(ctrl); row3.pack(fill=tk.X, pady=4)
+        ttk.Label(row3, text="Węzeł AST").pack(side=tk.LEFT)
+        self.cmb_node = ttk.Combobox(row3, values=[], width=34, state="readonly")
+        self.cmb_node.pack(side=tk.LEFT, padx=6)
+        # ZMIANA: wybór węzła (gdy η>0) też przelicza mozaikę
+        self.cmb_node.bind("<<ComboboxSelected>>", lambda _e: self.on_node_changed())
+
+        row4 = ttk.Frame(ctrl); row4.pack(fill=tk.X, pady=4)
+        ttk.Button(row4, text="Render", command=self.render).pack(side=tk.LEFT, padx=2)
+        ttk.Button(row4, text="Reset widoków", command=self.reset_views).pack(side=tk.LEFT, padx=6)
+        ttk.Button(row4, text="Aa+", command=lambda: self._font_step(+1)).pack(side=tk.RIGHT, padx=2)
+        ttk.Button(row4, text="Aa−", command=lambda: self._font_step(-1)).pack(side=tk.RIGHT, padx=2)
+
+        # figure
+        self.fig = plt.Figure(figsize=(10.4, 7.4))
+        gs = self.fig.add_gridspec(2, 2, height_ratios=[12, 1], width_ratios=[1, 1], hspace=0.25, wspace=0.28)
+        self.ax_ast = self.fig.add_subplot(gs[0, 0], projection="3d")
+        self.ax_mos = self.fig.add_subplot(gs[0, 1], projection="3d")
+        self.ax_inf = self.fig.add_subplot(gs[1, :])
+
+        self.canvas = FigureCanvasTkAgg(self.fig, master=right)
+        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
+        self.toolbar = NavigationToolbar2Tk(self.canvas, right)
+        self.toolbar.update()
+
+        # picking/click handlers
+        self.canvas.mpl_connect("pick_event", self.on_pick_ast)
+        self.canvas.mpl_connect("button_press_event", self.on_click_any)
+
+        # initial render
+        self.render()
+
+    # ------------- helpers -------------
+    def _font_step(self, delta: int):
+        try:
+            fam, size = self.txt["font"].split()[0], int(self.txt["font"].split()[1])
+        except Exception:
+            fam, size = "Consolas", 10
+        self.txt.configure(font=(fam, max(6, size + delta)))
+
+    def reset_views(self):
+        self.ax_ast.view_init(elev=22, azim=-48)
+        self.ax_mos.view_init(elev=25, azim=-58)
+        self.canvas.draw_idle()
+
+    # ------------- core flow -------------
+    def render(self):
+        code = self.txt.get("1.0", "end-1c")
+        try:
+            self.nodes = ast_nodes_from_code(code)
+        except SyntaxError as e:
+            messagebox.showerror("Błąd składni", str(e)); return
+        except Exception as e:
+            messagebox.showerror("Błąd", f"Nie udało się sparsować AST: {e}"); return
+
+        labels = [f"{n.name}  ·  [{n.kind}]" for n in self.nodes]
+        self.node_by_label = {lab: n for lab, n in zip(labels, self.nodes)}
+        self.cmb_node["values"] = labels
+        if labels:
+            cur = self.cmb_node.get()
+            if cur not in labels:
+                pick = max(self.nodes, key=lambda nn: nn.energy)
+                for lab, nn in self.node_by_label.items():
+                    if nn is pick: self.cmb_node.set(lab); break
+
+        # po każdej zmianie kodu: odtwórz meta = meta0
+        for n in self.nodes:
+            n.meta = np.array(n.meta0, dtype=float)
+
+        # pełny rebuild mozaiki (uwzględni λ, γ, η)
+        self.recompute_mosaic_from_ast()
+        # odmalowanie
+        self.repaint()
+
+    def on_lambda_changed(self):
+        # λ wpływa na pozycje → musi przebudować mozaikę
+        self.recompute_mosaic_from_ast()
+
+    def on_node_changed(self):
+        # jeśli η>0, wybór węzła zmienia wkład do mozaiki
+        self.recompute_mosaic_from_ast()
+        self.repaint()
+
+    def recompute_mosaic_from_ast(self):
+        lam = float(self.s_lambda.get())
+        gamma = float(self.s_gamma.get())
+        eta = float(self.s_eta.get())
+        # który węzeł jest wybrany (dla η)
+        sel_label = self.cmb_node.get()
+        selected_name = None
+        if sel_label and sel_label in self.node_by_label:
+            selected_name = self.node_by_label[sel_label].name
+
+        ast_comp = mosaic_from_ast(self.nodes, self.M.rows, self.M.cols, lam, gamma,
+                                   selected=selected_name, eta=eta)  # (N,)
+        a = _norm01(ast_comp.reshape(self.M.rows, self.M.cols))
+        b = _norm01(self.M.base_edge.reshape(self.M.rows, self.M.cols))
+        # blend z bazą
+        edge = (1.0 - gamma) * b + gamma * a
+        self.M.edge = edge.reshape(-1)
+        self.repaint()
+
+    def apply_feedback_and_recompute(self):
+        # delikatny feedback z mozaiki do meta wektorów (Δ)
+        delta = float(self.s_delta.get())
+        if delta > 0.0 and self.nodes:
+            lam = float(self.s_lambda.get())
+            pos = coords_for_lambda(self.nodes, lam)
+            rows, cols = self.M.rows, self.M.cols
+            edge2d = self.M.edge.reshape(rows, cols)
+
+            def feats_at(x, y):
+                xs = np.array([p[0] for p in pos.values()], dtype=float)
+                ys = np.array([p[1] for p in pos.values()], dtype=float)
+                x0, x1 = float(xs.min()), float(xs.max())
+                y0, y1 = float(ys.min()), float(ys.max())
+                if x1 - x0 < 1e-9: x1 = x0 + 1.0
+                if y1 - y0 < 1e-9: y1 = y0 + 1.0
+                cc = int(round((x - x0) / (x1 - x0) * (cols - 1)))
+                rr = int(round((y - y0) / (y1 - y0) * (rows - 1)))
+                rr = max(0, min(rows - 1, rr)); cc = max(0, min(cols - 1, cc))
+                r0, r1 = max(0, rr - 1), min(rows, rr + 2)
+                c0, c1 = max(0, cc - 1), min(cols, cc + 2)
+                ids = [r * cols + c for r in range(r0, r1) for c in range(c0, c1)]
+                return region_feats(self.M, set(ids))
+
+            for n in self.nodes:
+                x, y, _z = pos[n.name]
+                psi = feats_at(x, y)
+                n.meta = (1.0 - delta) * n.meta + delta * psi
+
+        # po feedbacku też przebuduj mozaikę (bo zmieniły się energie/entropie)
+        self.recompute_mosaic_from_ast()
+
+    def on_region_changed(self):
+        self.reg_key = self.cmb_region.get() or "ROI-A"
+        self.repaint()
+
+    # ------------- interakcje myszą -------------
+    def on_pick_ast(self, event):
+        art = event.artist
+        tag = getattr(art, "_glitch_name", None)
+        if not tag: return
+        for lab, n in self.node_by_label.items():
+            if n.name == tag:
+                self.cmb_node.set(lab)
+                self.on_node_changed()
+                break
+
+    def on_click_any(self, event):
+        if event.inaxes != self.ax_mos: return
+        if event.xdata is None or event.ydata is None: return
+        col = int(round(event.xdata)); row = int(round(event.ydata))
+        if (row < 0 or row >= self.M.rows or col < 0 or col >= self.M.cols): return
+
+        r0, r1 = max(0, row - 2), min(self.M.rows, row + 2)
+        c0, c1 = max(0, col - 2), min(self.M.cols, col + 2)
+        mask = np.zeros(self.M.rows * self.M.cols)
+        for r in range(r0, r1):
+            for c in range(c0, c1):
+                mask[r * self.M.cols + c] = 1.0
+
+        if event.button == 1:   # LPM
+            self.M.roiA = mask
+            if self.reg_key == "ROI-A":
+                self.repaint()
+        elif event.button == 3: # PPM
+            self.M.roiB = mask
+            if self.reg_key == "ROI-B":
+                self.repaint()
+
+    # ------------- repaint -------------
+    def repaint(self):
+        if not self.nodes:
+            return
+        lam = float(self.s_lambda.get())
+        beta = float(self.s_beta.get())
+        reg_key = self.reg_key
+
+        pos = coords_for_lambda(self.nodes, lam)
+        self.pos = pos
+
+        self.ax_ast.cla(); self.ax_mos.cla(); self.ax_inf.cla()
+
+        draw_ast(self.ax_ast, self.nodes, pos, pick=True)
+        draw_mosaic(self.ax_mos, self.M)
+        draw_region_frame(self.ax_mos, self.M, "ROI-A", color="lime")
+        draw_region_frame(self.ax_mos, self.M, "ROI-B", color="magenta")
+        draw_infographic(self.ax_inf)
+
+        sel_label = self.cmb_node.get()
+        node = None
+        if sel_label and sel_label in self.node_by_label:
+            node = self.node_by_label[sel_label]
+        else:
+            node = self.nodes[0]
+
+        ids = region_indices(self.M, reg_key)
+        reg_vec = region_feats(self.M, ids)
+        fused = fuse_meta(np.array(node.meta), reg_vec, lam, beta=beta)
+        draw_fusion(self.ax_ast, self.ax_mos, node, pos, self.M, reg_key, lam, fused)
+
+        xs, ys, zs = zip(*pos.values())
+        self.ax_ast.set_xlim(min(xs) - 1, max(xs) + 1)
+        self.ax_ast.set_ylim(min(ys) - 1, max(ys) + 1)
+        self.ax_ast.set_zlim(min(zs) - 1, max(zs) + 3.5)
+        self.ax_ast.set_title(
+            f"AST — λ={lam:.2f} · node={node.name} [{node.kind}] · reg={reg_key} · "
+            f"β={self.s_beta.get():.1f} · γ={self.s_gamma.get():.2f} · Δ={self.s_delta.get():.2f} · η={self.s_eta.get():.1f}"
+        )
+
+        self.canvas.draw_idle()
+
+
+# ─────────────────────────────────────────────────────────────
+# 7) MAIN
+# ─────────────────────────────────────────────────────────────
+
+def main():
+    app = App()
+    app.mainloop()
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/ast_mosaic_protocol_experiment.py b/tests/ast_mosaic_protocol_experiment.py
new file mode 100644
index 0000000..809ca18
--- /dev/null
+++ b/tests/ast_mosaic_protocol_experiment.py
@@ -0,0 +1,349 @@
+# demos/ast_mosaic_protocol_experiment.py
+# -*- coding: utf-8 -*-
+"""
+GlitchLab – AST×Mozaika 12x12 (hex) : kompresja AST + Φ/Ψ + protokół kontekstu
+Uruchom:  python demos/ast_mosaic_protocol_experiment.py
+Wymaga:   numpy, matplotlib
+"""
+from __future__ import annotations
+import ast, json, math, hashlib
+from dataclasses import dataclass, field, asdict
+from typing import Dict, List, Optional, Tuple, Set
+
+import numpy as np
+
+# ====== 0) USTAWIENIA ======
+PLOT = True   # rysuj 2× subplot (AST kompasy/hex-grid)
+ROWS, COLS = 12, 12  # plaster miodu ~ 12x12
+
+# ====== 1) AST: PARSOWANIE + KOMPRESJA (Merkle-AST) ======
+@dataclass
+class AstNodeInfo:
+    id: int
+    kind: str
+    label: str
+    parent: Optional[int]
+    depth: int
+    children: List[int] = field(default_factory=list)
+    hash: str = ""
+    meta: Tuple[float, float, float, float, float, float] = (0,0,0,0,0,0)
+    pos3d: Tuple[float, float, float] = (0.0,0.0,0.0)
+    count: int = 1  # po kompresji (ile zwinęto poddrzew tego samego typu)
+
+def node_label(n: ast.AST) -> str:
+    if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)): return f"def {n.name}"
+    if isinstance(n, ast.ClassDef): return f"class {n.name}"
+    if isinstance(n, ast.Assign):
+        t = n.targets[0] if n.targets else None
+        return f"{getattr(t,'id','assign')} = …"
+    if isinstance(n, ast.Name): return n.id
+    return type(n).__name__
+
+def build_ast_info(src: str) -> Dict[int, AstNodeInfo]:
+    root = ast.parse(src)
+    nodes: Dict[int, AstNodeInfo] = {}
+    nid = 0
+    def add(a: ast.AST, depth: int, parent: Optional[int]) -> int:
+        nonlocal nid
+        me = nid; nid+=1
+        k = a.__class__.__name__
+        nodes[me] = AstNodeInfo(me, k, node_label(a), parent, depth)
+        if parent is not None:
+            nodes[parent].children.append(me)
+        for ch in ast.iter_child_nodes(a):
+            add(ch, depth+1, me)
+        return me
+    add(root, 0, None)
+
+    # pozycje: radial by depth (kompas 3D)
+    by_depth: Dict[int, List[int]] = {}
+    for i,n in nodes.items(): by_depth.setdefault(n.depth,[]).append(i)
+    for d,ids in by_depth.items():
+        ids.sort()
+        R = 6.0 + 2.0*d
+        for j,i in enumerate(ids):
+            ang = 2*math.pi*j/max(1,len(ids))
+            nodes[i].pos3d = (R*math.cos(ang), R*math.sin(ang), 2.0*d)
+
+    # meta-heurystyki (spójne z Twoimi demo-metaglifami)
+    rng = np.random.default_rng(1337)
+    for n in nodes.values():
+        L,S,Sel,Stab,Cau,H = rng.uniform(0.25,0.85,size=6)
+        if n.kind in ("If","Compare"): Sel,Cau = 0.85,0.80
+        if n.kind in ("Expr","Call"): L,S = 0.65,0.55
+        if n.kind in ("Return",): Stab = 0.90
+        if n.kind in ("Assign",): Sel = 0.70
+        nodes[n.id].meta = (float(L),float(S),float(Sel),float(Stab),float(Cau),float(H))
+
+    # Merkle-hash poddrzew
+    def merkle(i: int) -> str:
+        n = nodes[i]
+        child_hashes = "".join(sorted(merkle(c) for c in n.children))
+        s = f"{n.kind}|{n.label}|{child_hashes}"
+        h = hashlib.sha256(s.encode("utf-8")).hexdigest()[:16]
+        nodes[i].hash = h
+        return h
+    _ = merkle(0)
+
+    # kompresja: policz powtórzenia hashy; zbij „izomorficzne” poddrzewa
+    freq: Dict[str,int] = {}
+    for n in nodes.values(): freq[n.hash] = freq.get(n.hash,0)+1
+    for n in nodes.values(): n.count = freq[n.hash]
+
+    return nodes
+
+def d_ast_distance(nodesA: Dict[int,AstNodeInfo], nodesB: Dict[int,AstNodeInfo]) -> float:
+    # lekka odległość: różnica rozkładu hashy + różnica głębokości
+    from collections import Counter
+    ca = Counter(n.hash for n in nodesA.values())
+    cb = Counter(n.hash for n in nodesB.values())
+    keys = set(ca)|set(cb)
+    dist_hash = sum(abs(ca[k]-cb[k]) for k in keys)
+    da = np.array([n.depth for n in nodesA.values()], float)
+    db = np.array([n.depth for n in nodesB.values()], float)
+    dist_depth = abs(da.mean() - (db.mean() if db.size else 0.0))
+    return float(dist_hash + 0.05*dist_depth)
+
+# ====== 2) HEKS-MOZAIKA 12×12 ======
+# axial (q,r) → 2D; generujemy maski i cechy
+@dataclass
+class Hex:
+    q: int; r: int
+    center: Tuple[float,float]
+    feats: Dict[str,float] = field(default_factory=dict)
+    roi: int = 0
+
+@dataclass
+class Mosaic:
+    rows:int; cols:int
+    hexes: List[Hex]
+    index_by_qr: Dict[Tuple[int,int], int]
+    layers: Dict[str, np.ndarray]  # np arrays of shape (N,)
+
+def build_hex_mosaic(rows=ROWS, cols=COLS, seed=7) -> Mosaic:
+    # układ „offset odd-r”
+    def axial_to_xy(q:int,r:int, size:float=1.0)->Tuple[float,float]:
+        x = size * (math.sqrt(3)*q + math.sqrt(3)/2 * r)
+        y = size * (3/2 * r)
+        return (x,y)
+    rng = np.random.default_rng(seed)
+    hexes: List[Hex] = []
+    idx: Dict[Tuple[int,int],int] = {}
+    k = 0
+    for r in range(rows):
+        for q in range(cols):
+            cx,cy = axial_to_xy(q, r, size=1.0)
+            edge = np.clip(0.45 + 0.45*np.sin(0.3*cx+0.2*cy) + 0.08*rng.standard_normal(), 0, 1)
+            var  = np.clip(0.4 + 0.6*np.cos(0.2*cx-0.15*cy), 0, 1)
+            hexes.append(Hex(q,r,(cx,cy), feats={"edge":float(edge),"var":float(var)}, roi=0))
+            idx[(q,r)] = k; k+=1
+    N = len(hexes)
+    layers = {
+        "edge": np.array([h.feats["edge"] for h in hexes], dtype=float),
+        "var":  np.array([h.feats["var"]  for h in hexes], dtype=float),
+        "ssim": np.ones(N, dtype=float)
+    }
+    # domyślne ROI: prostokątny „blok” w centrum siatki
+    cx_all = np.array([h.center[0] for h in hexes]); cy_all=np.array([h.center[1] for h in hexes])
+    x0,x1 = np.quantile(cx_all,[0.35,0.65])
+    y0,y1 = np.quantile(cy_all,[0.35,0.65])
+    roi = ((cx_all>=x0)&(cx_all<=x1)&(cy_all>=y0)&(cy_all<=y1)).astype(int)
+    for i,h in enumerate(hexes): h.roi = int(roi[i])
+    layers["roi"] = roi.astype(float)
+    return Mosaic(rows, cols, hexes, idx, layers)
+
+def region_ids(region:str, M:Mosaic, edge_thr=0.55)->Set[int]:
+    N = len(M.hexes)
+    if region=="ALL": return set(range(N))
+    if region=="roi": return {i for i,h in enumerate(M.hexes) if h.roi>0}
+    if region=="edges": return {i for i,h in enumerate(M.hexes) if h.feats["edge"]>edge_thr}
+    if region=="~edges": return {i for i,h in enumerate(M.hexes) if h.feats["edge"]<=edge_thr}
+    if region.startswith("ssim<"):
+        t=float(region.split("<",1)[1]);
+        return {i for i,v in enumerate(M.layers["ssim"]) if v<t}
+    return set()
+
+def region_feats(M:Mosaic, ids:Set[int])->np.ndarray:
+    if not ids: return np.zeros(6,dtype=float)
+    ed = np.array([M.hexes[i].feats["edge"] for i in ids])
+    fL   = float(1.0 - ed.mean())
+    fS   = float(0.5 + 0.5 * ed.std())
+    fSel = float((ed>0.6).mean())
+    fSt  = float(1.0 - ed.std())
+    fC   = float(min(1.0, 0.35 + 0.6 * ed.mean()))
+    fH   = float(0.4 + 0.5 * ed.std())
+    return np.array([fL,fS,fSel,fSt,fC,fH], dtype=float)
+
+# ====== 3) SPRZĘŻENIE Φ/Ψ ======
+def project_phi(nodes: Dict[int,AstNodeInfo], M:Mosaic, lam:float=0.0, gamma:float=0.7,
+                focus: Optional[int]=None, eta:float=0.0)->np.ndarray:
+    """
+    Raster z AST: rozrzucamy energię/entropię na heksy (przez pozycje/lambda).
+    lam  – skala: 0=detal (poziomy), 1=centroidy grup (tu heurystycznie: spłaszczamy do warstwy depth)
+    gamma – udział komponenty AST względem bazowego 'edge'
+    eta – boost dla wybranego węzła focus
+    Zwraca: v ∈ R^N,  v = (1-γ)*edge + γ*heat(AST)
+    """
+    N = len(M.hexes)
+    heat = np.zeros(N, dtype=float)
+
+    # bounding 2D sceny AST (XY)
+    xs = np.array([n.pos3d[0] for n in nodes.values()]); ys=np.array([n.pos3d[1] for n in nodes.values()])
+    x0,x1 = float(xs.min()),float(xs.max()); y0,y1=float(ys.min()),float(ys.max())
+    if abs(x1-x0)<1e-9: x1=x0+1.0
+    if abs(y1-y0)<1e-9: y1=y0+1.0
+    # bounding mozaiki (XY)
+    hx = np.array([h.center[0] for h in M.hexes]); hy=np.array([h.center[1] for h in M.hexes])
+    a0,a1 = float(hx.min()),float(hx.max()); b0,b1=float(hy.min()),float(hy.max())
+
+    def to_hex_index(x:float,y:float)->int:
+        # najbliższe centrum
+        d2 = (hx - x)**2 + (hy - y)**2
+        return int(np.argmin(d2))
+
+    # „grupowanie” po lam: im większa λ, tym mocniej przyciągamy do średnich poziomów depth
+    by_depth: Dict[int,List[int]] = {}
+    for i,n in nodes.items(): by_depth.setdefault(n.depth,[]).append(i)
+    centroid_by_depth: Dict[int,Tuple[float,float]] = {}
+    for d, ids in by_depth.items():
+        cx = float(np.mean([nodes[i].pos3d[0] for i in ids]))
+        cy = float(np.mean([nodes[i].pos3d[1] for i in ids]))
+        centroid_by_depth[d]=(cx,cy)
+
+    for i,n in nodes.items():
+        x,y,_ = n.pos3d
+        cx,cy = centroid_by_depth[n.depth]
+        X = (1.0-lam)*x + lam*cx
+        Y = (1.0-lam)*y + lam*cy
+        # przeskalowanie do przestrzeni heksów
+        Xh = a0 + (X - x0) / (x1 - x0) * (a1 - a0)
+        Yh = b0 + (Y - y0) / (y1 - y0) * (b1 - b0)
+        j = to_hex_index(Xh, Yh)
+        L,S,Sel,Stab,Cau,H = n.meta
+        w = 0.6*np.linalg.norm(n.meta) + 0.4*H
+        if focus is not None and i==focus: w *= (1.0 + max(0.0, eta))
+        heat[j] += float(w * max(1, n.count))  # powtarzalność wzmacnia
+
+    # normalizacja
+    if heat.max()>1e-12: heat = (heat-heat.min())/(heat.max()-heat.min())
+    base = M.layers["edge"].copy()
+    return (1.0-gamma)*base + gamma*heat
+
+def fuse_meta(node_meta: np.ndarray, reg_meta: np.ndarray, lam: float, beta: float) -> np.ndarray:
+    return (1.0 - lam) * node_meta + lam * (beta * reg_meta)
+
+def apply_psi_update(nodes: Dict[int,AstNodeInfo], M:Mosaic, delta:float=0.2):
+    """miękka aktualizacja meta-wektorów z mozaiki"""
+    ids_all = set(range(len(M.hexes)))
+    feats_all = region_feats(M, ids_all)
+    for n in nodes.values():
+        # heurystyka: If/Compare → region=ALL; Expr → edges/~edges wg parzystości id; Assign → roi
+        if n.kind=="Assign": ids = region_ids("roi", M)
+        elif n.kind=="Expr": ids = region_ids("edges" if n.id%2==0 else "~edges", M)
+        else: ids = ids_all
+        reg = feats_all if not ids else region_feats(M, ids)
+        m = np.array(n.meta, dtype=float)
+        nodes[n.id].meta = tuple((1.0-delta)*m + delta*reg)
+
+# ====== 4) METRYKI / FUNKCJA CELU ======
+def d_phi_cost(M:Mosaic, ast_comp:np.ndarray, denoise_ids:Set[int], blur_ids:Set[int]) -> float:
+    # kara: wysokie edge w denoise i niskie edge w blur
+    edge = M.layers["edge"]
+    cost = 0.1 * float(edge[list(denoise_ids)].sum()) + 0.1 * float((1.0 - edge[list(blur_ids)]).sum())
+    # zgodność ast_comp z base edge (im bardziej zbieżne – tym lepiej)
+    align = float(np.mean((ast_comp - edge)**2))
+    return float(cost + 0.2*align)
+
+def invariants(M:Mosaic, denoise_ids:Set[int], blur_ids:Set[int], thr=0.55)->Dict[str,str]:
+    I1="OK"
+    I3="OK" if all(M.hexes[i].feats["edge"]<=thr for i in denoise_ids) else "WARN"
+    roi = region_ids("roi", M); edges = region_ids("edges", M, thr)
+    leak = len(roi & edges)/max(1,len(roi))
+    I2=f"boundary_overlap≈{leak:.2f}"; I4="check after Φ"
+    return {"I1":I1,"I2":I2,"I3":I3,"I4":I4}
+
+# ====== 5) PROTOKÓŁ KONTEXTU ======
+def export_protocol(nodes:Dict[int,AstNodeInfo], M:Mosaic, ast_comp:np.ndarray, J:float) -> Dict:
+    ast_json = [{
+        "id": n.id, "kind": n.kind, "label": n.label, "parent": n.parent,
+        "depth": n.depth, "children": n.children, "hash": n.hash, "count": n.count,
+        "meta": list(map(float,n.meta)), "pos3d": list(map(float,n.pos3d))
+    } for n in nodes.values()]
+    proto = {
+        "ast": {"nodes": ast_json},
+        "mosaic": {
+            "rows": M.rows, "cols": M.cols,
+            "layers": {k: v.tolist() for k,v in M.layers.items()},
+            "hex_centers": [h.center for h in M.hexes]
+        },
+        "phi": {"ast_component": ast_comp.tolist()},
+        "metrics": {"J": float(J)},
+        "version": "v5-protocol-0.1"
+    }
+    return proto
+
+# ====== 6) GŁÓWNY PRZEPŁYW ======
+EXAMPLE = """\
+def pipeline(img):
+    R  = (120, 80, 200, 160)
+    E  = edges(img, method='Sobel', thresh=0.55)
+    D  = denoise_nlm(img, strength=0.35)
+    B  = gaussian_blur(img, sigma=1.8)
+    Z  = blend(img, B, 0.5)
+    M  = metric_ssim(img, Z)
+    return blend(D, B, 0.5)
+"""
+
+def main(show=PLOT):
+    # AST
+    nodes = build_ast_info(EXAMPLE)
+    # MOZAIKA
+    M = build_hex_mosaic()
+    # Φ: raster AST→mozaika
+    ast_comp = project_phi(nodes, M, lam=0.25, gamma=0.7, focus=None, eta=0.0)
+    # Ψ: delikatny feedback i ponowna projekcja
+    apply_psi_update(nodes, M, delta=0.15)
+    ast_comp = project_phi(nodes, M, lam=0.35, gamma=0.7, focus=None, eta=0.0)
+
+    # METRYKI i J
+    denoise_ids = region_ids("~edges", M)
+    blur_ids    = region_ids("edges",  M)
+    J = d_phi_cost(M, ast_comp, denoise_ids, blur_ids)
+
+    # PROTOKÓŁ
+    proto = export_protocol(nodes, M, ast_comp, J)
+    print(json.dumps(proto["metrics"], indent=2))
+    print("protocol-size", len(json.dumps(proto)))
+
+    if show:
+        import matplotlib.pyplot as plt
+        from matplotlib.patches import RegularPolygon
+        fig, (ax1, ax2) = plt.subplots(1,2, figsize=(12,5))
+        # AST „kompas” 2D (rzut XY + wysokość=meta_energy)
+        for n in nodes.values():
+            x,y,z = n.pos3d
+            h = 0.8 + 1.6*np.linalg.norm(n.meta)/np.sqrt(6)
+            ax1.plot([x,x],[y,y+h], color="#334155", lw=2.0)
+            ax1.scatter([x],[y+h], s=18, c=[(0.2,0.2,0.7,0.9)])
+            if n.depth<=3: ax1.text(x, y+h+0.2, n.kind, fontsize=8, ha="center")
+        ax1.set_title("AST – rzut kompasu (h~‖meta‖)")
+        ax1.set_aspect("equal", "box")
+
+        # heks-mozaika: kolor = base edge, obwódka = wkład AST
+        centers = np.array([h.center for h in M.hexes])
+        base = M.layers["edge"]; contrib = ast_comp
+        bmin,bmax = base.min(), base.max()
+        for i,(cx,cy) in enumerate(centers):
+            col = ( (base[i]-bmin)/(bmax-bmin+1e-9), 0.2, 1.0-(base[i]-bmin)/(bmax-bmin+1e-9), 0.95 )
+            hex = RegularPolygon((cx,cy), numVertices=6, radius=0.95, orientation=np.radians(30),
+                                 facecolor=col, edgecolor=(0,0,0, 0.25+0.7*contrib[i]), lw=1.0)
+            ax2.add_patch(hex)
+        ax2.autoscale_view()
+        ax2.set_aspect("equal","box")
+        ax2.set_title("Mozaika 12×12 (edge + wkład AST)")
+        plt.tight_layout(); plt.show()
+
+    return proto
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/ast_mosaic_to_lattice_experiment.py b/tests/ast_mosaic_to_lattice_experiment.py
new file mode 100644
index 0000000..6f4d7ad
--- /dev/null
+++ b/tests/ast_mosaic_to_lattice_experiment.py
@@ -0,0 +1,353 @@
+# -*- coding: utf-8 -*-
+"""
+GlitchLab — AST × Mozaika (heks) × TO-lattice (truncated octahedron, Voronoi BCC)
+- Heksy stykają się bokami (axial q,r z poprawną geometrią).
+- Wspólna rama 3D: komórki ściętego ośmiościanu (TO) aproksymowane kratą BCC (14-NN).
+- Kompresja: Merkle-AST + „snap” węzłów AST do komórek TO (CR_AST, CR_TO).
+- Sprzężenia Φ/Ψ i funkcja oceny J.
+
+Uruchom:
+  python demos/ast_mosaic_to_lattice_experiment.py
+Wymaga:
+  numpy, matplotlib
+"""
+from __future__ import annotations
+import ast, math, json, hashlib
+from dataclasses import dataclass, field, asdict
+from typing import Dict, List, Tuple, Optional, Set
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.patches import RegularPolygon
+
+# ============ 0) PARAMETRY ============
+HEX_R = 1.0        # promień heksa (inscribed) — ważny dla styków
+ROWS, COLS = 12,12 # mozaika 12×12
+SHOW = True
+
+# ============ 1) AST: parsowanie + Merkle + „kompas 3D” ============
+@dataclass
+class AstNodeInfo:
+    id: int
+    kind: str
+    label: str
+    depth: int
+    parent: Optional[int]
+    children: List[int] = field(default_factory=list)
+    h: str = ""                                  # Merkle hash poddrzewa
+    meta: Tuple[float,float,float,float,float,float]=(0,0,0,0,0,0)
+    pos3d: Tuple[float,float,float]=(0.0,0.0,0.0)
+
+def _label(n: ast.AST)->str:
+    if isinstance(n,(ast.FunctionDef,ast.AsyncFunctionDef)): return f"def {n.name}"
+    if isinstance(n,ast.ClassDef): return f"class {n.name}"
+    if isinstance(n,ast.Assign):
+        t = n.targets[0] if n.targets else None
+        return f"{getattr(t,'id','assign')} = …"
+    if isinstance(n,ast.Name): return n.id
+    return type(n).__name__
+
+def build_ast(src:str, seed:int=123)->Dict[int,AstNodeInfo]:
+    T = ast.parse(src)
+    nodes: Dict[int,AstNodeInfo] = {}
+    nid=0
+    def add(a:ast.AST, d:int, p:Optional[int]):
+        nonlocal nid
+        me=nid; nid+=1
+        nodes[me]=AstNodeInfo(me, a.__class__.__name__, _label(a), d, p)
+        if p is not None: nodes[p].children.append(me)
+        for ch in ast.iter_child_nodes(a): add(ch, d+1, me)
+    add(T,0,None)
+
+    # pozycje (kompas 3D): radial by depth
+    by_d: Dict[int,List[int]]={}
+    for i,n in nodes.items(): by_d.setdefault(n.depth,[]).append(i)
+    for d,ids in by_d.items():
+        ids.sort()
+        R = 6.0 + 2.0*d
+        for j,i in enumerate(ids):
+            ang = 2*math.pi*j/max(1,len(ids))
+            nodes[i].pos3d = (R*math.cos(ang), R*math.sin(ang), 2.0*d)
+
+    # meta (heurystyki stabilne, nie losowe)
+    def meta_for(n:AstNodeInfo)->Tuple[float,...]:
+        L=S=Sel=Stab=Cau=H=0.55
+        if n.kind in ("If","Compare"): Sel,Cau,H = 0.85,0.80,0.60
+        if n.kind in ("Return",): Stab = 0.90
+        if n.kind in ("Assign",): Sel,Stab = 0.70,0.72
+        if n.kind in ("Call","Expr"): L,S = 0.65,0.60
+        return (L,S,Sel,Stab,Cau,H)
+    for n in nodes.values(): nodes[n.id].meta = meta_for(n)
+
+    # Merkle hash
+    def merkle(i:int)->str:
+        ch = "".join(sorted(merkle(c) for c in nodes[i].children))
+        s = f"{nodes[i].kind}|{nodes[i].label}|{ch}"
+        h = hashlib.sha256(s.encode()).hexdigest()[:16]
+        nodes[i].h = h
+        return h
+    _ = merkle(0)
+    return nodes
+
+# ============ 2) TO-lattice (Voronoi BCC) i heks-mozaika ============
+# BCC w integerach: punkt „even” (x+y+z parzyste) i „odd” (przesunięte o (0.5,0.5,0.5)).
+# Najbliżsi sąsiedzi: 8 wierzchołków sześcianu (hexy), drugi pierścień: 6 osiowych (kwadraty) → łącznie 14.
+BCC_NEIGH_HEX = [(+1,+1,+1),(+1,+1,-1),(+1,-1,+1),(+1,-1,-1),
+                 (-1,+1,+1),(-1,+1,-1),(-1,-1,+1),(-1,-1,-1)]
+BCC_NEIGH_SQR = [(+2,0,0),(-2,0,0),(0,+2,0),(0,-2,0),(0,0,+2),(0,0,-2)]
+
+@dataclass
+class TOCell:
+    xyz: Tuple[int,int,int]      # integer coords BCC (skalowane)
+    center: Tuple[float,float,float]
+    feats: Dict[str,float]
+
+@dataclass
+class TOLattice:
+    cells: List[TOCell]
+    index: Dict[Tuple[int,int,int], int]
+    neighbors: Dict[int, List[int]]  # 14-lista sąsiadów
+
+def build_to_lattice(nx=8,ny=8,nz=4, scale=1.0)->TOLattice:
+    cells=[]; index={}
+    def to_center(x,y,z):
+        return (scale*x/2.0, scale*y/2.0, scale*z/2.0)  # /2 → bo są kroki ±2 i ±1
+    k=0
+    for z in range(-nz,nz+1):
+        for y in range(-ny,ny+1):
+            for x in range(-nx,nx+1):
+                if (x+y+z)%2==0:   # BCC-even warstwa
+                    cx,cy,cz = to_center(x,y,z)
+                    # cechy emulujemy prostym polem
+                    edge = 0.5 + 0.4*math.tanh(0.1*cx - 0.08*cy + 0.05*cz)
+                    var  = 0.4 + 0.6*math.sin(0.07*cx + 0.11*cy - 0.06*cz)**2
+                    cells.append(TOCell((x,y,z),(cx,cy,cz),{"edge":edge,"var":var}))
+                    index[(x,y,z)] = k; k+=1
+    # sąsiedzi (14)
+    neigh: Dict[int,List[int]]={}
+    for i,c in enumerate(cells):
+        x,y,z = c.xyz
+        ids=[]
+        for dx,dy,dz in BCC_NEIGH_HEX + BCC_NEIGH_SQR:
+            key=(x+dx,y+dy,z+dz)
+            j=index.get(key)
+            if j is not None: ids.append(j)
+        neigh[i]=ids
+    return TOLattice(cells,index,neigh)
+
+# heks-mozaika 12×12 — *prawdziwe* stykające się heksy (axial q,r)
+@dataclass
+class Hex:
+    q:int; r:int
+    center: Tuple[float,float]
+    feats: Dict[str,float]; roi:int
+
+@dataclass
+class Mosaic:
+    hexes: List[Hex]
+    edge: np.ndarray  # (N,)
+    roi:  np.ndarray  # (N,)
+
+def axial_to_xy(q:int, r:int, R:float=HEX_R)->Tuple[float,float]:
+    step_x = math.sqrt(3.0)*R
+    step_y = 1.5*R
+    x = step_x * (q + 0.5*(r&1))
+    y = step_y * r
+    return (x,y)
+
+def build_hex_mosaic(rows=ROWS, cols=COLS)->Mosaic:
+    hexes=[]; edge=[]; roi=[]
+    # generujemy z pola z TO-lattice: projekcja z=const (użyję syntetycznej funkcji)
+    for r in range(rows):
+        for q in range(cols):
+            x,y = axial_to_xy(q,r,HEX_R)
+            # tekstura „edge”: ciągła, bez szpar (tylko od x,y)
+            e = 0.5 + 0.45*math.tanh(0.18*x - 0.16*y)
+            hexes.append(Hex(q,r,(x,y),{"edge":e},0))
+            edge.append(e); roi.append(0)
+    # ROI: centralny romb ~30% środka
+    xs=np.array([h.center[0] for h in hexes]); ys=np.array([h.center[1] for h in hexes])
+    x0,x1 = np.quantile(xs,[0.35,0.65]); y0,y1 = np.quantile(ys,[0.35,0.65])
+    Rmask = ((xs>=x0)&(xs<=x1)&(ys>=y0)&(ys<=y1)).astype(int)
+    for i,h in enumerate(hexes): h.roi=int(Rmask[i])
+    return Mosaic(hexes, np.array(edge,float), Rmask.astype(float))
+
+# ============ 3) Projekcja Φ i feedback Ψ ============
+def phi_project_ast_to_hex(nodes:Dict[int,AstNodeInfo], M:Mosaic, lam=0.3, gamma=0.7,
+                           boost_id:Optional[int]=None, eta=0.0)->np.ndarray:
+    # bounding AST XY
+    xs=np.array([n.pos3d[0] for n in nodes.values()]); ys=np.array([n.pos3d[1] for n in nodes.values()])
+    x0,x1=float(xs.min()),float(xs.max()); y0,y1=float(ys.min()),float(ys.max())
+    if x1-x0<1e-9: x1=x0+1;
+    if y1-y0<1e-9: y1=y0+1
+    # centroidy warstw (poziomy depth)
+    by_d:Dict[int,List[int]]={};
+    for i,n in nodes.items(): by_d.setdefault(n.depth,[]).append(i)
+    layer_centroids={d: (float(np.mean([nodes[i].pos3d[0] for i in ids])),
+                         float(np.mean([nodes[i].pos3d[1] for i in ids])))
+                     for d,ids in by_d.items()}
+    # raster
+    H=len(M.hexes); heat=np.zeros(H,float)
+    centers=np.array([h.center for h in M.hexes])
+    for i,n in nodes.items():
+        # przesuwamy w stronę centroidu warstwy (lam)
+        cx,cy = layer_centroids[n.depth]
+        X=(1.0-lam)*n.pos3d[0] + lam*cx
+        Y=(1.0-lam)*n.pos3d[1] + lam*cy
+        # mapowanie do heksów: najbliższe centrum
+        # skalowanie współrzędnych AST → [min,max] heksów (tu wystarcza nearest)
+        # (bo heksy są równomiernie rozłożone)
+        j = int(np.argmin((centers[:,0]-X)**2 + (centers[:,1]-Y)**2))
+        L,S,Sel,Stab,Cau,Hm = n.meta
+        w = 0.6*np.linalg.norm(n.meta) + 0.4*Hm
+        if boost_id is not None and i==boost_id: w *= (1.0+max(0.0,eta))
+        heat[j]+=w
+    if heat.max()>1e-12: heat=(heat-heat.min())/(heat.max()-heat.min())
+    base=M.edge
+    return (1.0-gamma)*base + gamma*heat
+
+def psi_feedback(nodes:Dict[int,AstNodeInfo], M:Mosaic, delta=0.2):
+    # miękka aktualizacja meta z cech regionów (roi vs ~roi) — prosty przykład
+    ids_roi = {i for i,h in enumerate(M.hexes) if h.roi>0}
+    ids_nroi = set(range(len(M.hexes))) - ids_roi
+    def feats(ids:Set[int])->np.ndarray:
+        if not ids: return np.zeros(6,float)
+        ed=np.array([M.hexes[i].feats["edge"] for i in ids])
+        fL=1.0-ed.mean(); fS=0.5+0.5*ed.std(); fSel=(ed>0.6).mean()
+        fSt=1.0-ed.std(); fC=min(1.0, 0.35+0.6*ed.mean()); fH=0.45+0.5*ed.std()
+        return np.array([fL,fS,fSel,fSt,fC,fH],float)
+    m_roi, m_nroi = feats(ids_roi), feats(ids_nroi)
+    for n in nodes.values():
+        target = m_roi if (n.id%3==0) else m_nroi
+        m=np.array(n.meta,float)
+        nodes[n.id].meta = tuple((1.0-delta)*m + delta*target)
+
+# ============ 4) Kompresja i metryki ============
+def compression_merkle(nodes:Dict[int,AstNodeInfo])->float:
+    from collections import Counter
+    cnt = Counter(n.h for n in nodes.values())
+    return len(nodes)/max(1,len(cnt))  # CR_AST
+
+def to_snap_and_compress(nodes:Dict[int,AstNodeInfo], L:TOLattice)->Tuple[Dict[int,int], float, float]:
+    # snap: rzut pos3d na środek najbliższej komórki; policz CR_TO i Align3D
+    centers = np.array([c.center for c in L.cells])
+    occ: Dict[int,int]={}  # cell_id -> licznik
+    assign: Dict[int,int]={}  # node_id -> cell_id
+    for i,n in nodes.items():
+        p=np.array([n.pos3d[0],n.pos3d[1],n.pos3d[2]])
+        j=int(np.argmin(np.sum((centers-p)**2,axis=1)))
+        assign[i]=j; occ[j]=occ.get(j,0)+1
+    CR_TO = len(nodes)/max(1,len(occ))
+    # Align3D: dywergencja jednolitości po 14-NN: rozrzut occupancy po sąsiedztwach
+    var_acc=[]
+    for j,c in enumerate(L.cells):
+        neigh=L.neighbors[j]
+        vals=[occ.get(t,0) for t in neigh]+[occ.get(j,0)]
+        if len(vals)>0: var_acc.append(np.var(vals))
+    Align3D = float(np.mean(var_acc))  # im mniejsze tym bardziej jednorodne
+    return assign, CR_TO, Align3D
+
+def phi_cost(edge_base:np.ndarray, ast_comp:np.ndarray, M:Mosaic)->float:
+    # kara za „denoise na krawędziach” i słabą zgodność z bazą
+    ids_edges = {i for i,h in enumerate(M.hexes) if h.feats["edge"]>0.6}
+    ids_ne = set(range(len(M.hexes))) - ids_edges
+    leak = float(np.mean(ast_comp[list(ids_edges)]))     # duży wkład na krawędziach = ryzyko blur/denoise-konfliktu
+    miss = float(np.mean(1.0-ast_comp[list(ids_ne)]))    # niski wkład gdzie powinien być
+    align = float(np.mean((ast_comp-edge_base)**2))      # zbieżność z bazą
+    return 0.4*leak + 0.3*miss + 0.3*align
+
+# ============ 5) Protokół kontekstu ============
+def export_protocol(nodes, M, L, assign, ast_comp, scores)->Dict:
+    return {
+        "version":"v5-protocol-TO-0.1",
+        "ast":{"nodes":[{
+            "id":n.id,"kind":n.kind,"label":n.label,"depth":n.depth,"parent":n.parent,
+            "children":n.children,"hash":n.h,"meta":list(map(float,n.meta)),"pos3d":list(map(float,n.pos3d))
+        } for n in nodes.values()]},
+        "mosaic":{
+            "hex_centers":[h.center for h in M.hexes],
+            "edge":M.edge.tolist(),"roi":M.roi.tolist()
+        },
+        "to_lattice":{
+            "cells":[{"center":c.center,"xyz":c.xyz} for c in L.cells],
+            "assign":assign
+        },
+        "phi":{"ast_component":ast_comp.tolist()},
+        "metrics":scores
+    }
+
+# ============ 6) DEMO MAIN ============
+EXAMPLE = """\
+def pipeline(img):
+    R  = (120,80,200,160)
+    E  = edges(img, method='Sobel', thresh=0.55)
+    D  = denoise_nlm(img, strength=0.35)
+    B  = gaussian_blur(img, sigma=1.8)
+    Z  = blend(img, B, 0.5)
+    M  = metric_ssim(img, Z)
+    return blend(D, B, 0.5)
+"""
+
+def main(show=SHOW):
+    # AST
+    nodes = build_ast(EXAMPLE)
+    CR_AST = compression_merkle(nodes)
+
+    # TO-lattice (3D, wspólna rama)
+    L = build_to_lattice(nx=6,ny=6,nz=4, scale=1.0)
+    assign, CR_TO, Align3D = to_snap_and_compress(nodes, L)
+
+    # Heks-mozaika (12×12) — stykające się heksy
+    M = build_hex_mosaic()
+
+    # Φ i Ψ
+    ast_comp = phi_project_ast_to_hex(nodes, M, lam=0.3, gamma=0.7)
+    psi_feedback(nodes, M, delta=0.15)
+    ast_comp = phi_project_ast_to_hex(nodes, M, lam=0.4, gamma=0.7)
+
+    # Ocena
+    J_phi = phi_cost(M.edge, ast_comp, M)
+    scores = {
+        "CR_AST": float(CR_AST),
+        "CR_TO": float(CR_TO),
+        "Align3D": float(Align3D),
+        "J_phi": float(J_phi),
+        "J_total": float(0.5*J_phi + 0.25/CR_AST + 0.25/CR_TO)  # preferuj większą kompresję, mniejszy koszt Φ
+    }
+    print(json.dumps(scores, indent=2))
+
+    # Protokół (do GUI/HUD)
+    proto = export_protocol(nodes, M, L, assign, ast_comp, scores)
+    # (tu byśmy zapisali do ctx.cache jako JSON)
+
+    if show:
+        # Rysunek: lewy — AST (rzut XY), prawy — heksy (stykające)
+        fig,(ax1,ax2)=plt.subplots(1,2,figsize=(12,5))
+        for n in nodes.values():
+            x,y,z=n.pos3d
+            h=0.9+1.5*np.linalg.norm(n.meta)/np.sqrt(6)
+            ax1.plot([x,x],[y,y+h],color="#374151",lw=2.0)
+            ax1.scatter([x],[y+h],s=18,c=[(0.2,0.2,0.8,0.95)])
+            if n.depth<=3: ax1.text(x,y+h+0.2,n.kind,fontsize=8,ha="center")
+        ax1.set_aspect("equal","box")
+        ax1.set_title("AST – kompas (rzut XY; h~‖meta‖)")
+
+        centers=np.array([h.center for h in M.hexes])
+        bmin,bmax=M.edge.min(),M.edge.max()
+        for i,hx in enumerate(M.hexes):
+            cx,cy=hx.center
+            # stykające: radius = HEX_R, orientation=30°
+            face = ( (M.edge[i]-bmin)/(bmax-bmin+1e-9), 0.2, 1.0-(M.edge[i]-bmin)/(bmax-bmin+1e-9), 0.96 )
+            border_alpha = 0.25 + 0.7*ast_comp[i]
+            poly = RegularPolygon((cx,cy), numVertices=6, radius=HEX_R, orientation=np.radians(30),
+                                  facecolor=face, edgecolor=(0,0,0,border_alpha), lw=1.0)
+            ax2.add_patch(poly)
+        ax2.autoscale_view()
+        ax2.set_aspect("equal","box")
+        ax2.set_title("Mozaika 12×12 — heksy stykające (edge + wkład AST)")
+        plt.tight_layout(); plt.show()
+
+    return proto
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/demo_hybrid_mosaic_eval.py b/tests/demo_hybrid_mosaic_eval.py
new file mode 100644
index 0000000..da53dd3
--- /dev/null
+++ b/tests/demo_hybrid_mosaic_eval.py
@@ -0,0 +1,178 @@
+# -*- coding: utf-8 -*-
+"""
+tests/demo_hybrid_mosaic_eval.py
+
+CLI demo/benchmark dla algorytmu hybrydowego AST ⇄ Mozaika (Φ/Ψ).
+Zgodny z API: glitchlab.gui.mosaic.hybrid_ast_mosaic
+
+Uruchomienia (przykłady):
+  python tests/demo_hybrid_mosaic_eval.py --lam 0.60 --delta 0.25 --seeds 100 --rows 12 --cols 12 --kind grid
+  python tests/demo_hybrid_mosaic_eval.py --lam 0.60 --delta 0.25 --seeds 100 --rows 12 --cols 12 --kind hex
+"""
+
+from __future__ import annotations
+import argparse
+import json
+from typing import Dict, List
+
+import numpy as np
+
+# Import modułu algorytmu – utrzymujemy krótkie aliasy.
+import glitchlab.gui.mosaic.hybrid_ast_mosaic as hma
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# POMOCNICZE
+# ──────────────────────────────────────────────────────────────────────────────
+
+def _sign_test_p(wins: int, losses: int) -> float:
+    """Dwustronny test znaku (binomial, p=0.5) na rozstrzygnięciach (bez remisów)."""
+    n = wins + losses
+    if n == 0:
+        return 1.0
+    from math import comb
+    k = max(wins, losses)  # co najmniej k zwycięstw po stronie dominującej
+    return sum(comb(n, t) for t in range(k, n + 1)) / (2 ** n)
+
+
+def demo_run_once(lam: float, delta: float, rows: int, cols: int,
+                  kind: str, edge_thr: float) -> Dict[str, float]:
+    """
+    Pojedynczy przebieg: liczy J_phi (Φ1/Φ2/Φ3), Align, CR_* i profil (α,β,S,H,Z).
+    Używa aktualnego API hma.* (wszystkie funkcje Φ/Ψ/Align biorą próg edge_thr).
+    """
+    # AST
+    ast_raw = hma.ast_deltas(hma.EXAMPLE_SRC)
+    ast_l   = hma.compress_ast(ast_raw, lam)
+
+    # Mozaika
+    M = hma.build_mosaic(rows=rows, cols=cols, seed=7, kind=kind, edge_thr=edge_thr)
+
+    # Φ – trzy selektory (UWAGA: przekazujemy edge_thr)
+    J1, _ = hma.phi_cost(ast_l, M, edge_thr, selector=hma.phi_region_for)
+    J2, _ = hma.phi_cost(ast_l, M, edge_thr, selector=hma.phi_region_for_balanced)
+    J3, _ = hma.phi_cost(ast_l, M, edge_thr, selector=hma.phi_region_for_entropy)
+
+    # Ψ – feedback z progiem
+    ast_after = hma.psi_feedback(ast_l, M, delta, edge_thr)
+
+    # Align – z progiem
+    Align = 1.0 - min(1.0, hma.distance_ast_mosaic(ast_after, M, edge_thr))
+
+    # Kompresja AST (jak wcześniej)
+    CR_AST = (ast_raw.S + ast_raw.H + max(1, ast_raw.Z)) / max(1, ast_l.S + ast_l.H + max(1, ast_l.Z))
+
+    # Topologia mozaiki (jak wcześniej)
+    p_edge = float(np.mean(M.edge > edge_thr))
+    CR_TO  = (1.0 / max(1e-6, min(p_edge, 1 - p_edge))) - 1.0
+
+    return dict(J_phi1=J1, J_phi2=J2, J_phi3=J3,
+                Align=Align, CR_AST=CR_AST, CR_TO=CR_TO,
+                S=ast_l.S, H=ast_l.H, Z=ast_l.Z,
+                alpha=ast_l.alpha, beta=ast_l.beta)
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# MAIN
+# ──────────────────────────────────────────────────────────────────────────────
+
+def main():
+    ap = argparse.ArgumentParser(prog="demo_hybrid_mosaic_eval",
+                                 description="Demo/benchmark dla hybrydy AST⇄Mozaika (Φ/Ψ)")
+    ap.add_argument("--lam", type=float, default=0.60, help="λ – poziom kompresji AST")
+    ap.add_argument("--delta", type=float, default=0.25, help="Δ – siła Ψ feedback")
+    ap.add_argument("--seeds", type=int, default=100, help="liczba seedów do testu operacyjnego")
+    ap.add_argument("--rows", type=int, default=12, help="wiersze mozaiki")
+    ap.add_argument("--cols", type=int, default=12, help="kolumny mozaiki")
+    ap.add_argument("--kind", type=str, default="grid", choices=["grid", "hex"], help="rodzaj mozaiki")
+    ap.add_argument("--edge-thr", type=float, default=hma.EDGE_THR_DEFAULT, help="próg edge dla regionów Φ")
+    args = ap.parse_args()
+
+    print("\n=== PROTOKÓŁ DOWODOWY: AST ⇄ Mozaika (Φ/Ψ, ΔS/ΔH/ΔZ, λ/Δ-sweep) ===\n")
+
+    # baseline
+    base = demo_run_once(args.lam, args.delta, args.rows, args.cols, args.kind, args.edge_thr)
+    print(f"[BASELINE] λ={args.lam:.2f}, Δ={args.delta:.2f}")
+    print(json.dumps(base, indent=2))
+
+    # inwarianty
+    astA = hma.ast_deltas(hma.EXAMPLE_SRC)
+    astB = hma.compress_ast(astA, args.lam)
+    M = hma.build_mosaic(args.rows, args.cols, seed=7, kind=args.kind, edge_thr=args.edge_thr)
+    inv = hma.invariants_check(astA, astB, M, args.edge_thr)
+    print("\n[TESTY INWARIANTÓW / METRYK]")
+    for k, v in inv.items():
+        print(f"  - {k}: {'PASS' if v else 'FAIL'}")
+
+    # porównanie metod Φ
+    print("\n[PORÓWNANIE METOD Φ] (Φ1=heur, Φ2=balanced, Φ3=entropy-fuzzy)")
+    aL = hma.compress_ast(astA, args.lam)
+    J1, _ = hma.phi_cost(aL, M, args.edge_thr, selector=hma.phi_region_for)
+    J2, _ = hma.phi_cost(aL, M, args.edge_thr, selector=hma.phi_region_for_balanced)
+    J3, _ = hma.phi_cost(aL, M, args.edge_thr, selector=hma.phi_region_for_entropy)
+    imp = (J1 - J2) / max(1e-9, J1) * 100.0
+    print(f"  Φ1 (heur):   J_phi = {J1:.6f}")
+    print(f"  Φ2 (bal):    J_phi = {J2:.6f}  (improvement vs Φ1: {imp:.2f}%)")
+    print(f"  Φ3 (fuzzy):  J_phi = {J3:.6f}  (Δ vs Φ1: {((J3 - J1) / max(1e-9, J1)) * 100:.2f}%)")
+
+    # sweep λ×Δ
+    lams: List[float] = [0.0, 0.25, 0.5, 0.75]
+    dels: List[float] = [0.0, 0.25, 0.5]
+    print("\n[SWEEP λ × Δ]  (Align↑ lepiej, J_phi↓ lepiej, CR_AST↑ = większa kompresja)")
+    header = ["λ", "Δ", "Align", "J_phi2", "CR_AST", "CR_TO", "α", "β", "S", "H", "Z"]
+    widths = [4, 4, 7, 8, 7, 7, 5, 5, 4, 4, 3]
+
+    def _row(cols): return " | ".join(str(c).ljust(w) for c, w in zip(cols, widths))
+
+    print(_row(header))
+    print("-" * (sum(widths) + len(widths) - 1))
+    for lam in lams:
+        for de in dels:
+            r = demo_run_once(lam, de, args.rows, args.cols, args.kind, args.edge_thr)
+            print(_row([
+                f"{lam:.2f}", f"{de:.2f}", f"{r['Align']:.3f}",
+                f"{r['J_phi2']:.4f}", f"{r['CR_AST']:.3f}", f"{r['CR_TO']:.3f}",
+                f"{r['alpha']:.2f}", f"{r['beta']:.2f}",
+                int(r['S']), int(r['H']), int(r['Z']),
+            ]))
+
+    # test operacyjny: Φ2 vs Φ1 na N seedach
+    print(f"\n[TEST OPERACYJNY] {args.seeds} seedów — czy Φ2 (balanced) poprawia J_phi vs Φ1?")
+    wins = losses = ties = 0
+    diffs: List[float] = []
+    for seed in range(args.seeds):
+        Ms = hma.build_mosaic(args.rows, args.cols, seed=seed, kind=args.kind, edge_thr=args.edge_thr)
+        aL = hma.compress_ast(astA, args.lam)
+        j1, _ = hma.phi_cost(aL, Ms, args.edge_thr, selector=hma.phi_region_for)
+        j2, _ = hma.phi_cost(aL, Ms, args.edge_thr, selector=hma.phi_region_for_balanced)
+        d = j1 - j2
+        diffs.append(d)
+        if d > 0: wins += 1
+        elif d < 0: losses += 1
+        else: ties += 1
+        if (seed + 1) % max(1, args.seeds // 10) == 0:
+            print(f"  progress: {seed + 1}/{args.seeds}  | running wins={wins}, losses={losses}, ties={ties}",
+                  flush=True)
+
+    mean_diff = float(np.mean(diffs))
+    med_diff  = float(np.median(diffs))
+    p_sign    = _sign_test_p(wins, losses)
+
+    print(f"  mean(J1-J2) = {mean_diff:.6f}  | median = {med_diff:.6f}")
+    print(f"  wins Φ2: {wins}/{wins + losses} (ties={ties}) | sign-test p≈{p_sign:.3g}")
+
+    # JSON summary
+    out = dict(
+        baseline=dict(lambda_=args.lam, delta=args.delta, **base),
+        invariants=inv,
+        sweep=dict(lams=lams, deltas=dels),
+        op_test=dict(seeds=args.seeds, wins=wins, losses=losses, ties=ties,
+                     p_sign=p_sign, mean_improvement=mean_diff, median_improvement=med_diff),
+        setup=dict(rows=args.rows, cols=args.cols, kind=args.kind, edge_thr=args.edge_thr),
+    )
+    print("\n[SUMMARY JSON]")
+    print(json.dumps(out, indent=2))
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/hybrid_mosaic_test_report.py b/tests/hybrid_mosaic_test_report.py
new file mode 100644
index 0000000..c25230d
--- /dev/null
+++ b/tests/hybrid_mosaic_test_report.py
@@ -0,0 +1,261 @@
+# -*- coding: utf-8 -*-
+"""
+tests/hybrid_mosaic_test_report.py
+Runner + wizualizacja wyników testów dla hybrydowego algorytmu AST⇄Mozaika.
+
+Funkcje:
+- uruchomienie PyTest i zebranie podsumowania,
+- zrzut metryk demo (baseline, sweep, test znaku),
+- render Markdown z tabelami i minigrafami ASCII,
+- opcjonalny zapis do pliku (--out report.md) i/lub JSON (--json-out results.json)
+
+Uruchom przykładowo:
+  python tests/hybrid_mosaic_test_report.py --lam 0.60 --delta 0.25 --rows 12 --cols 12 --kind hex --seeds 60 --edge-thr 0.55 --out report.md --json-out results.json
+
+Wymaga:
+  - glitchlab.gui.mosaic.hybrid_ast_mosaic (moduł algorytmu)
+  - pytest (do uruchomienia testów)
+  - numpy (w algorytmie)
+"""
+
+from __future__ import annotations
+import argparse
+import json
+import math
+import os
+import subprocess
+import sys
+from datetime import datetime
+from typing import Dict, List
+
+import numpy as np
+
+# Import modułu algorytmu
+import glitchlab.gui.mosaic.hybrid_ast_mosaic as hma
+
+
+# ─────────────────────────────────────────────────────────────────────────────
+# Pomocnicze: ascii-wykresy i tabele
+# ─────────────────────────────────────────────────────────────────────────────
+
+def _ascii_bar(vals: List[float], width: int = 32, fill: str = "█") -> str:
+    """Prosty pasek (0..1) w ASCII dla listy wartości — rysuje średnią."""
+    if not vals:
+        return ""
+    v = max(0.0, min(1.0, float(np.mean(vals))))
+    n = int(round(v * width))
+    return fill * n + " " * (width - n) + f"  ({v:.3f})"
+
+def _ascii_sparkline(vals: List[float], height: int = 6, width: int = 40) -> str:
+    """Mini-wykres linii w ASCII (skalowanie 0..1)."""
+    if not vals:
+        return ""
+    lo, hi = min(vals), max(vals)
+    rng = max(1e-12, hi - lo)
+    norm = [(v - lo) / rng for v in vals]
+    cols = min(width, len(norm))
+    # równomierne próbkowanie do 'cols'
+    idxs = np.linspace(0, len(norm)-1, cols).astype(int)
+    grid = [[" "] * cols for _ in range(height)]
+    for ci, i in enumerate(idxs):
+        y = height - 1 - int(round(norm[i] * (height - 1)))
+        grid[y][ci] = "•"
+    return "\n".join("".join(row) for row in grid)
+
+def _table(headers: List[str], rows: List[List[str]]) -> str:
+    widths = [max(len(h), *(len(str(r[i])) for r in rows)) for i, h in enumerate(headers)]
+    def line(cols): return " | ".join(str(c).ljust(widths[i]) for i, c in enumerate(cols))
+    sep = "-+-".join("-" * w for w in widths)
+    out = [line(headers), sep]
+    out.extend(line(r) for r in rows)
+    return "\n".join(out)
+
+
+# ─────────────────────────────────────────────────────────────────────────────
+# Uruchamianie pytest i parsowanie wyników
+# ─────────────────────────────────────────────────────────────────────────────
+
+def run_pytests(pytest_path: str = "pytest", test_file: str = "tests/test_hybrid_mosaic_algo.py") -> Dict:
+    """
+    Uruchamia pytest w subprocessie. Zwraca słownik z podsumowaniem:
+    {"ok": bool, "returncode": int, "stdout": "...", "summary": {"passed": int, "failed": int, "skipped": int, "xpassed": int}}
+    """
+    cmd = [pytest_path, "-q", test_file]
+    proc = subprocess.run(cmd, capture_output=True, text=True)
+    out = proc.stdout + proc.stderr
+
+    # prymitywny parser podsumowania z ostatniej linii pytest
+    # przykłady: "8 passed in 0.25s" / "7 passed, 1 skipped in 0.21s" / "6 passed, 1 failed in 0.30s"
+    summary = {"passed": 0, "failed": 0, "skipped": 0, "xpassed": 0, "xfailed": 0, "errors": 0}
+    last_lines = [ln.strip() for ln in out.strip().splitlines()[-5:]]
+    for ln in last_lines:
+        if "in " in ln and any(k in ln for k in ["passed", "failed", "skipped", "xpassed", "xfailed", "error"]):
+            # Rozbij po przecinkach, policz tokeny
+            parts = [p.strip() for p in ln.split(" in ")[0].split(",")]
+            for p in parts:
+                toks = p.split()
+                if len(toks) >= 2 and toks[0].isdigit():
+                    n = int(toks[0]); tag = toks[1].lower()
+                    if tag.startswith("passed"):  summary["passed"] = n
+                    elif tag.startswith("failed"): summary["failed"] = n
+                    elif tag.startswith("skipped"):summary["skipped"] = n
+                    elif tag.startswith("xpassed"):summary["xpassed"] = n
+                    elif tag.startswith("xfailed"):summary["xfailed"] = n
+                    elif tag.startswith("error"): summary["errors"] = n
+            break
+
+    return {
+        "ok": proc.returncode == 0,
+        "returncode": proc.returncode,
+        "stdout": out,
+        "summary": summary,
+    }
+
+
+# ─────────────────────────────────────────────────────────────────────────────
+# Zbieranie metryk demo (baseline, sweep, sign-test)
+# ─────────────────────────────────────────────────────────────────────────────
+
+def collect_demo(rows: int, cols: int, kind: str, lam: float, delta: float, edge_thr: float, seeds: int) -> Dict:
+    # baseline
+    base = hma.run_once(lam, delta, rows, cols, edge_thr, mosaic_kind=kind)
+
+    # sweep
+    sw = hma.sweep(rows, cols, edge_thr, mosaic_kind=kind)
+    align_vals = [r["Align"] for r in sw]
+    j2_vals = [r["J_phi2"] for r in sw]
+    cr_vals = [r["CR_AST"] for r in sw]
+
+    # sign-test
+    sign = hma.sign_test_phi2_better(n_runs=seeds, rows=rows, cols=cols, thr=edge_thr,
+                                     lam=lam, mosaic_kind=kind)
+
+    return dict(
+        baseline=base,
+        sweep=sw,
+        sign=sign,
+        aggregates=dict(
+            align_mean=float(np.mean(align_vals)),
+            align_median=float(np.median(align_vals)),
+            jphi2_mean=float(np.mean(j2_vals)),
+            cr_ast_mean=float(np.mean(cr_vals)),
+        ),
+    )
+
+
+# ─────────────────────────────────────────────────────────────────────────────
+# Render Markdown
+# ─────────────────────────────────────────────────────────────────────────────
+
+def render_markdown(cfg: Dict, pytest_res: Dict, demo: Dict) -> str:
+    dt = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")
+    base = demo["baseline"]
+    sign = demo["sign"]
+    sw = demo["sweep"]
+    agg = demo["aggregates"]
+
+    # Tabela sweep (skrócona)
+    hdr = ["λ", "Δ", "Align", "J_phi2", "CR_AST", "CR_TO", "α", "β", "S", "H", "Z"]
+    rows = []
+    for r in sw:
+        rows.append([
+            f"{r['lambda_']:.2f}", f"{r['delta_']:.2f}", f"{r['Align']:.3f}",
+            f"{r['J_phi2']:.4f}", f"{r['CR_AST']:.3f}", f"{r['CR_TO']:.3f}",
+            f"{r['alpha']:.2f}", f"{r['beta']:.2f}", str(int(r['S'])), str(int(r['H'])), str(int(r['Z'])),
+        ])
+
+    # Mini wykresy
+    align_vals = [r["Align"] for r in sw]
+    j2_vals = [r["J_phi2"] for r in sw]
+    cr_vals = [r["CR_AST"] for r in sw]
+
+    md = []
+    md.append(f"# Hybrid AST⇄Mosaic — Test Report\n")
+    md.append(f"_generated: {dt}_\n")
+    md.append("## Setup\n")
+    md.append("```json\n" + json.dumps(cfg, indent=2) + "\n```\n")
+
+    md.append("## PyTest Summary\n")
+    md.append("```text\n" + pytest_res["stdout"].strip() + "\n```\n")
+    md.append("**Parsed summary:** " + json.dumps(pytest_res["summary"]) + "\n")
+
+    md.append("## Baseline\n")
+    md.append("```json\n" + json.dumps(base, indent=2) + "\n```\n")
+
+    md.append("## Sweep λ×Δ (skrócone)\n")
+    md.append("```\n" + _table(hdr, rows) + "\n```\n")
+
+    md.append("### Mini-wykresy (ASCII)\n")
+    md.append("**Align (trend):**\n\n```\n" + _ascii_sparkline(align_vals) + "\n```\n")
+    md.append("**J_phi2 (średnia — mniejsze lepsze):**\n\n```\n" + _ascii_bar(j2_vals) + "\n```\n")
+    md.append("**CR_AST (średnia — większa kompresja lepsza):**\n\n```\n" + _ascii_bar(cr_vals) + "\n```\n")
+
+    md.append("## Sign test: Φ2 vs Φ1\n")
+    md.append("```json\n" + json.dumps(sign, indent=2) + "\n```\n")
+
+    md.append("## Wnioski (skrót)\n")
+    md.append(f"- Średni Align (sweep): **{agg['align_mean']:.3f}**; mediana **{agg['align_median']:.3f}**.\n")
+    md.append(f"- Średni J_phi2 (sweep): **{agg['jphi2_mean']:.3f}** (niżej lepiej).\n")
+    md.append(f"- Średni CR_AST (sweep): **{agg['cr_ast_mean']:.3f}** (wyżej = większa kompresja).\n")
+    md.append(f"- Sign test (Φ2 lepsze od Φ1): **wins={sign['wins']}**, **losses={sign['losses']}**, **ties={sign['ties']}**, p≈**{sign['p_sign']:.3g}**.\n")
+
+    md.append("\n---\n")
+    md.append("_End of report._\n")
+    return "\n".join(md)
+
+
+# ─────────────────────────────────────────────────────────────────────────────
+# CLI
+# ─────────────────────────────────────────────────────────────────────────────
+
+def main():
+    ap = argparse.ArgumentParser(description="Runner + wizualizacja testów dla Hybrid AST⇄Mosaic")
+    ap.add_argument("--rows", type=int, default=12)
+    ap.add_argument("--cols", type=int, default=12)
+    ap.add_argument("--kind", type=str, choices=["grid", "hex"], default="grid")
+    ap.add_argument("--lam", type=float, default=0.60)
+    ap.add_argument("--delta", type=float, default=0.25)
+    ap.add_argument("--edge-thr", type=float, default=hma.EDGE_THR_DEFAULT)
+    ap.add_argument("--seeds", type=int, default=60)
+    ap.add_argument("--pytest-path", type=str, default="pytest")
+    ap.add_argument("--test-file", type=str, default="test_hybrid_mosaic_algo.py")
+    ap.add_argument("--out", type=str, default="raport.md")        # ścieżka do pliku .md (opcjonalnie)
+    ap.add_argument("--json-out", type=str, default="")   # ścieżka do pliku .json (opcjonalnie)
+    args = ap.parse_args()
+
+    cfg = dict(rows=args.rows, cols=args.cols, kind=args.kind, lam=args.lam, delta=args.delta,
+               edge_thr=args.edge_thr, seeds=args.seeds, test_file=args.test_file)
+
+    print("\n=== Hybrid AST⇄Mosaic — Test Runner ===\n")
+
+    # 1) PyTest
+    print("[1/3] Running PyTest…")
+    pytest_res = run_pytests(pytest_path=args.pytest_path, test_file=args.test_file)
+    print(f"    -> returncode={pytest_res['returncode']} summary={pytest_res['summary']}")
+
+    # 2) Demo metrics
+    print("[2/3] Collecting demo metrics…")
+    demo = collect_demo(rows=args.rows, cols=args.cols, kind=args.kind,
+                        lam=args.lam, delta=args.delta, edge_thr=args.edge_thr,
+                        seeds=args.seeds)
+    print("    -> baseline:", {k: round(v, 4) if isinstance(v, float) else v for k, v in demo["baseline"].items()})
+
+    # 3) Render report (Markdown + opcjonalny zapis)
+    print("[3/3] Rendering report…")
+    md = render_markdown(cfg, pytest_res, demo)
+    print("\n" + md)  # pokaż w konsoli
+
+    if args.out:
+        with open(args.out, "w", encoding="utf-8") as f:
+            f.write(md)
+        print(f"\n[Saved] Markdown report -> {args.out}")
+
+    if args.json_out:
+        bundle = dict(config=cfg, pytest=pytest_res, demo=demo)
+        with open(args.json_out, "w", encoding="utf-8") as f:
+            json.dump(bundle, f, indent=2)
+        print(f"[Saved] JSON results -> {args.json_out}")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/metarelation_scaling_test.py b/tests/metarelation_scaling_test.py
new file mode 100644
index 0000000..558855b
--- /dev/null
+++ b/tests/metarelation_scaling_test.py
@@ -0,0 +1,590 @@
+# -*- coding: utf-8 -*-
+"""
+demos/ast_mosaic_meta_evolution.py
+----------------------------------
+Interaktywny demo-lab:
+- dowolny kod Pythona -> AST (parsowanie na żywo z edytora)
+- wizualizacja AST (3D) w skali szarości, pozycje: detal → centroidy grup (λ)
+- mozaika 10x14 (3D bar chart) w skali szarości + ROI-A/ROI-B
+- wybór węzła AST i regionu -> fuzja metastruktury (jedna arytmetyka relacji)
+- przerywane linie dla relacji, jaskrawe kolory dla akcentów
+- „róża metryczna” (⟨L,S⟩, ⟨Sel,Stab⟩, ⟨Cau,H⟩) jako wynik fuzji
+
+Uruchom:
+    python demos/ast_mosaic_meta_evolution.py
+
+Wymaga:
+    Python 3.8+, tkinter, numpy, matplotlib
+"""
+
+from __future__ import annotations
+import ast
+import math
+import tkinter as tk
+from tkinter import ttk, messagebox
+
+from dataclasses import dataclass
+from typing import List, Tuple, Dict, Set, Optional
+
+import numpy as np
+import matplotlib
+matplotlib.use("TkAgg")
+import matplotlib.pyplot as plt
+from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
+
+
+# ─────────────────────────────────────────────────────────────
+# 1) Model danych
+# ─────────────────────────────────────────────────────────────
+
+@dataclass
+class AstNodeMeta:
+    name: str
+    kind: str
+    pos_det: Tuple[float, float, float]      # pozycja detalu (λ=0)
+    group: str                                # nazwa grupy (do centroidu przy λ→1)
+    meta: Tuple[float, float, float, float, float, float]  # (L,S,Sel,Stab,Cau,H) ∈ [0,1]^6
+
+    @property
+    def energy(self) -> float:
+        return float(np.linalg.norm(self.meta))
+
+    @property
+    def entropy(self) -> float:
+        return float(self.meta[-1])
+
+
+@dataclass
+class Mosaic:
+    rows: int
+    cols: int
+    edge: np.ndarray  # (rows*cols,) ∈ [0,1]
+    roiA: np.ndarray  # (rows*cols,) 0/1
+    roiB: np.ndarray  # (rows*cols,) 0/1
+
+
+# ─────────────────────────────────────────────────────────────
+# 2) Mozaika demo + regiony + cechy
+# ─────────────────────────────────────────────────────────────
+
+def build_demo_mosaic(rows=10, cols=14) -> Mosaic:
+    rng = np.random.default_rng(42)
+    yy, xx = np.mgrid[0:rows, 0:cols]
+    diag = 1.0 - np.abs(xx - yy) / max(rows, cols)
+    edge = np.clip(0.45 + 0.5 * diag + 0.06 * rng.standard_normal((rows, cols)), 0, 1).reshape(-1)
+
+    roiA = np.zeros(rows * cols)
+    roiB = np.zeros(rows * cols)
+    # ROI A – prostokąt po lewej
+    for r in range(int(0.25 * rows), int(0.65 * rows)):
+        for c in range(int(0.12 * cols), int(0.42 * cols)):
+            roiA[r * cols + c] = 1.0
+    # ROI B – prostokąt po prawej
+    for r in range(int(0.35 * rows), int(0.85 * rows)):
+        for c in range(int(0.55 * cols), int(0.90 * cols)):
+            roiB[r * cols + c] = 1.0
+    return Mosaic(rows, cols, edge, roiA, roiB)
+
+
+def region_indices(M: Mosaic, key: str) -> Set[int]:
+    if key == "ROI-A": return {i for i, v in enumerate(M.roiA) if v > 0.5}
+    if key == "ROI-B": return {i for i, v in enumerate(M.roiB) if v > 0.5}
+    return set(range(M.rows * M.cols))  # ALL
+
+
+def region_centroid(M: Mosaic, ids: Set[int]) -> Tuple[float, float, float]:
+    if not ids: return (M.cols * 0.5, M.rows * 0.5, 0.0)
+    cols = np.array([i % M.cols for i in ids], dtype=float)
+    rows = np.array([i // M.cols for i in ids], dtype=float)
+    z = np.array([2.0 * M.edge[i] + 0.1 for i in ids], dtype=float)
+    return float(cols.mean()), float(rows.mean()), float(z.mean())
+
+
+def region_feats(M: Mosaic, ids: Set[int]) -> np.ndarray:
+    """
+    ψ(region) → 6D, kompatybilne z (L,S,Sel,Stab,Cau,H)
+    """
+    if not ids: return np.zeros(6, dtype=float)
+    ed = np.array([M.edge[i] for i in ids])
+    fL   = float(1.0 - np.mean(ed))               # lokalność ↑, gdy gładko
+    fS   = float(0.5 + 0.5 * np.std(ed))          # skala ↑, gdy zmienność
+    fSel = float(np.mean(ed > 0.6))               # selektywność = udział krawędzi
+    fSt  = float(1.0 - np.std(ed))                # stabilność = 1 - wariancja
+    fC   = float(min(1.0, 0.3 + 0.7 * np.mean(ed)))  # kauzalność ~ „siła” regionu
+    fH   = float(0.4 + 0.5 * np.std(ed))          # entropia ~ niepewność
+    return np.array([fL, fS, fSel, fSt, fC, fH], dtype=float)
+
+
+def fuse_meta(node_meta: np.ndarray, reg_meta: np.ndarray, lam: float, beta: float = 1.0) -> np.ndarray:
+    """
+    Jedna arytmetyka jednej relacji:
+    m_fused(λ) = (1−λ)·m_node + λ·(β·ψ(region) ⊙ align)  ;  align = 1 (tu)
+    """
+    align = np.ones_like(node_meta)
+    return (1.0 - lam) * node_meta + lam * (beta * reg_meta * align)
+
+
+# ─────────────────────────────────────────────────────────────
+# 3) AST: parsowanie, pozycjonowanie, metahurystyki
+# ─────────────────────────────────────────────────────────────
+
+def _node_label(n: ast.AST) -> str:
+    if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
+        return f"def {n.name}"
+    if isinstance(n, ast.ClassDef):
+        return f"class {n.name}"
+    if isinstance(n, ast.Assign):
+        # first simple target
+        try:
+            t = n.targets[0]
+            if isinstance(t, ast.Name): return f"{t.id} = …"
+        except Exception:
+            pass
+        return "assign"
+    if isinstance(n, ast.Name):
+        return n.id
+    return type(n).__name__
+
+
+def _group_of(n: ast.AST) -> str:
+    """
+    Grupy do supergrafu:
+      - 'G:def:<fn>' dla węzłów wewnątrz funkcji,
+      - 'G:class:<cls>' dla węzłów wewnątrz klasy,
+      - 'G:top' dla top-level,
+      - dodatkowo kubełkowanie po głębokości: sufiks '/Dk'.
+    """
+    # śledzimy kontener (najbliższy FunctionDef/ClassDef)
+    parent_fn = getattr(n, "_parent_fn", None)
+    parent_cls = getattr(n, "_parent_cls", None)
+    if parent_fn: base = f"G:def:{parent_fn}"
+    elif parent_cls: base = f"G:class:{parent_cls}"
+    else: base = "G:top"
+    d = getattr(n, "_depth", 0)
+    return f"{base}/D{d//2}"  # kubełki co 2 poziomy
+
+
+def _attach_parents_and_depths(tree: ast.AST):
+    """
+    Wzbogacamy nody o: _parent, _depth, _parent_fn, _parent_cls
+    """
+    def walk(n, parent=None, depth=0, fn=None, cls=None):
+        setattr(n, "_parent", parent)
+        setattr(n, "_depth", depth)
+        setattr(n, "_parent_fn", fn)
+        setattr(n, "_parent_cls", cls)
+        if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
+            fn = n.name
+        if isinstance(n, ast.ClassDef):
+            cls = n.name
+        for _f, v in ast.iter_fields(n):
+            if isinstance(v, ast.AST):
+                walk(v, n, depth + 1, fn, cls)
+            elif isinstance(v, list):
+                for it in v:
+                    if isinstance(it, ast.AST):
+                        walk(it, n, depth + 1, fn, cls)
+    walk(tree)
+
+
+def _coords_for_tree(tree: ast.AST) -> Dict[ast.AST, Tuple[float, float, float]]:
+    """
+    Ustalamy pozycje 'detalu' (λ=0): x=indeks na poziomie, y=typ (bucket per type),
+    z=głębokość (poziom).
+    """
+    # poziomy
+    per_level: Dict[int, List[ast.AST]] = {}
+    type_bucket: Dict[str, int] = {}
+    def walk(n):
+        d = getattr(n, "_depth", 0)
+        per_level.setdefault(d, []).append(n)
+        for ch in ast.iter_child_nodes(n):
+            walk(ch)
+    walk(tree)
+
+    # bucketowanie typów
+    b = 0
+    for n in ast.walk(tree):
+        t = type(n).__name__
+        if t not in type_bucket:
+            type_bucket[t] = b
+            b += 1
+
+    # indeks na poziomie
+    order_on_level: Dict[ast.AST, int] = {}
+    for d, nds in per_level.items():
+        for i, n in enumerate(nds):
+            order_on_level[n] = i
+
+    coords: Dict[ast.AST, Tuple[float, float, float]] = {}
+    for n in ast.walk(tree):
+        x = 2.0 * order_on_level.get(n, 0)
+        y = 2.0 * type_bucket[type(n).__name__]
+        z = 2.0 * getattr(n, "_depth", 0)
+        coords[n] = (x, y, z)
+    return coords
+
+
+def _meta_for_node(n: ast.AST) -> Tuple[float, float, float, float, float, float]:
+    """
+    Heurystyki meta (L,S,Sel,Stab,Cau,H) ∈ [0,1] bazujące na typie/roli.
+    Tu prosto i deterministycznie: nadaje charakter.
+    """
+    rng = np.random.default_rng(abs(hash((type(n).__name__, getattr(n, "_depth", 0)))) % (2**32))
+    L, S, Sel, Stab, Cau, H = rng.uniform(0.30, 0.85, size=6)
+    if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
+        Stab = 0.85; H = 0.35; Sel = 0.55
+    if isinstance(n, ast.If):
+        Sel = 0.80; H = 0.55
+    if isinstance(n, ast.For):
+        S = 0.70; Cau = 0.60
+    if isinstance(n, ast.Call):
+        Sel = 0.65; Cau = 0.55
+    if isinstance(n, ast.Assign):
+        L = 0.55; Stab = 0.70
+    return float(L), float(S), float(Sel), float(Stab), float(Cau), float(H)
+
+
+def ast_nodes_from_code(code: str) -> List[AstNodeMeta]:
+    """
+    Parsuje kod -> AST -> lista węzłów z pozycją detalu, grupą i metą.
+    """
+    tree = ast.parse(code)
+    _attach_parents_and_depths(tree)
+    coords = _coords_for_tree(tree)
+
+    nodes: List[AstNodeMeta] = []
+    for n in ast.walk(tree):
+        # wybierz tylko 'istotne' nody (w celu listy do wyboru)
+        if isinstance(n, (ast.Module, ast.Load, ast.Store, ast.Del)):
+            continue
+        name = _node_label(n)
+        kind = type(n).__name__
+        group = _group_of(n)
+        nodes.append(
+            AstNodeMeta(
+                name=name,
+                kind=kind,
+                pos_det=coords[n],
+                group=group,
+                meta=_meta_for_node(n)
+            )
+        )
+    return nodes
+
+
+# ─────────────────────────────────────────────────────────────
+# 4) Geometria meta: λ → pozycje, centroidy grup
+# ─────────────────────────────────────────────────────────────
+
+def group_centroids(nodes: List[AstNodeMeta]) -> Dict[str, Tuple[float, float, float]]:
+    by_g: Dict[str, List[Tuple[float, float, float]]] = {}
+    for n in nodes:
+        by_g.setdefault(n.group, []).append(n.pos_det)
+    cents: Dict[str, Tuple[float, float, float]] = {}
+    for g, pts in by_g.items():
+        xs, ys, zs = list(zip(*pts))
+        cents[g] = (float(np.mean(xs)), float(np.mean(ys)), float(np.mean(zs)))
+    return cents
+
+
+def coords_for_lambda(nodes: List[AstNodeMeta], lam: float) -> Dict[str, Tuple[float, float, float]]:
+    cents = group_centroids(nodes)
+    pos: Dict[str, Tuple[float, float, float]] = {}
+    for n in nodes:
+        p = n.pos_det; q = cents[n.group]
+        pos[n.name] = (p[0] + (q[0] - p[0]) * lam,
+                       p[1] + (q[1] - p[1]) * lam,
+                       p[2] + (q[2] - p[2]) * lam)
+    return pos
+
+
+# ─────────────────────────────────────────────────────────────
+# 5) Rysowanie: AST, Mozaika, Fuzja
+# ─────────────────────────────────────────────────────────────
+
+def draw_ast(ax, nodes: List[AstNodeMeta], pos: Dict[str, Tuple[float, float, float]]):
+    cmap = plt.get_cmap("Greys")
+    for n in nodes:
+        x, y, z = pos[n.name]
+        h = 0.9 + 1.9 * (n.energy / np.sqrt(6))
+        c = cmap(0.35 + 0.55 * n.entropy)  # szarość zależna od H
+        ax.plot([x, x], [y, y], [z, z + h], color=c, lw=2.0, alpha=0.9)
+        ax.scatter([x], [y], [z + h], s=26, c=[c], edgecolors="black", depthshade=True)
+        ax.text(x, y, z + h + 0.35, n.name, fontsize=7, ha="center", color="black")
+
+
+def draw_mosaic(ax, M: Mosaic):
+    xs, ys, zs, dx, dy, dz, cols = [], [], [], [], [], [], []
+    for r in range(M.rows):
+        for c in range(M.cols):
+            i = r * M.cols + c
+            h = 2.0 * M.edge[i] + 0.1
+            xs.append(c); ys.append(r); zs.append(0.0)
+            dx.append(0.85); dy.append(0.85); dz.append(h)
+            g = M.edge[i]
+            cols.append((g, g, g, 0.92))  # skala szarości
+    ax.bar3d(xs, ys, zs, dx, dy, dz, color=cols, linewidth=0.1, shade=True)
+    ax.set_xlabel("cols"); ax.set_ylabel("rows"); ax.set_zlabel("edge→height")
+    ax.view_init(elev=25, azim=-58)
+
+
+def draw_region_frame(ax, M: Mosaic, key: str, z=2.45, color="lime"):
+    ids = region_indices(M, key)
+    if not ids: return
+    rr = np.array([i // M.cols for i in ids]); cc = np.array([i % M.cols for i in ids])
+    rmin, rmax = rr.min(), rr.max(); cmin, cmax = cc.min(), cc.max()
+    ax.plot([cmin, cmax, cmax, cmin, cmin],
+            [rmin, rmin, rmax, rmax, rmin],
+            [z, z, z, z, z], color=color, lw=1.6, linestyle="--")
+
+
+def draw_fusion(ax_ast, ax_mos,
+                node: AstNodeMeta, pos: Dict[str, Tuple[float, float, float]],
+                M: Mosaic, reg_key: str, lam: float, fused: np.ndarray):
+    # centroid regionu (punkt 0)
+    ids = region_indices(M, reg_key)
+    cx, cy, cz = region_centroid(M, ids)
+    colors_reg = {"ROI-A": "lime", "ROI-B": "magenta", "ALL": "orange"}
+    reg_color = colors_reg.get(reg_key, "orange")
+    ax_mos.scatter([cx], [cy], [cz + 0.05], s=52, c=reg_color,
+                   edgecolors="black", depthshade=True, zorder=10)
+
+    # wiązka node → centroid regionu (linia przerywana)
+    x0, y0, z0 = pos[node.name]
+    ax_ast.plot([x0, cx], [y0, cy], [z0, cz],
+                linestyle="--", color=reg_color, lw=1.6, alpha=0.95)
+
+    # róża metryczna (3 pary): ⟨L,S⟩, ⟨Sel,Stab⟩, ⟨Cau,H⟩
+    base = np.array([x0, y0, z0 + 0.28])
+    pairs = [(0, 1), (2, 3), (4, 5)]
+    rose_colors = ["cyan", "orange", "yellow"]
+    labels = ["⟨L,S⟩", "⟨Sel,Stab⟩", "⟨Cau,H⟩"]
+    scale = 1.2
+    for k, (i, j) in enumerate(pairs):
+        val = float(0.5 * (fused[i] + fused[j]))
+        vec = np.array([(1 if k == 0 else 0),
+                        (1 if k == 1 else 0),
+                        0.9])  # orty + lekko w górę
+        tip = base + scale * val * vec
+        ax_ast.plot([base[0], tip[0]], [base[1], tip[1]], [base[2], tip[2]],
+                    linestyle="--", color=rose_colors[k], lw=2.0)
+        ax_ast.text(tip[0], tip[1], tip[2] + 0.08, labels[k],
+                    fontsize=7, color=rose_colors[k])
+
+    # formuła
+    ax_ast.text(x0, y0, z0 - 0.6,
+                r"$m_{\mathrm{fused}}(\lambda)=(1-\lambda)\,m_{\mathrm{node}}+\lambda\,\beta\,\psi(\mathrm{region})$",
+                fontsize=7, ha="center", color="black")
+
+
+def draw_infographic(ax):
+    ax.axis("off")
+    ax.text(0.52, 2.25, "Infografika relacji", fontsize=11, weight="bold")
+    ax.text(0.52, 2.00, "■  Szarości: struktura bazowa (AST, Mozaika)", fontsize=9, color="black")
+    ax.text(0.52, 1.75, "◆  Centroid ROI: lime/magenta/orange", fontsize=9, color="lime")
+    ax.text(0.52, 1.50, "— —    przerywane: relacje node ↔ ROI & róża metryczna", fontsize=9, color="magenta")
+    ax.text(0.52, 1.25, "✦  Róża: pary ⟨L,S⟩, ⟨Sel,Stab⟩, ⟨Cau,H⟩ po FUZJI", fontsize=9, color="cyan")
+    ax.text(0.52, 1.00, "Jedna arytmetyka relacji:", fontsize=10, weight="bold")
+    ax.text(0.52, 0.75, "m_fused(λ) = (1−λ)·m_node + λ·β·ψ(region)", fontsize=9)
+    ax.text(0.52, 0.50, "λ skaluje meta–warstwę (detal → supergraf grup) bez zmiany mechaniki fuzji", fontsize=9)
+
+
+# ─────────────────────────────────────────────────────────────
+# 6) GUI (Tkinter + Matplotlib)
+# ─────────────────────────────────────────────────────────────
+
+DEFAULT_SNIPPET = """\
+# proste demo, edytuj i naciśnij [Render]
+def f(x):
+    y = x
+    if y > 0:
+        y = y - 1
+    return y + 1
+
+class K:
+    def __init__(self, a):
+        self.a = a
+
+def g(n):
+    s = 0
+    for i in range(n):
+        s += i
+    return s
+
+z = f(3) + g(4)
+"""
+
+class App(tk.Tk):
+    def __init__(self):
+        super().__init__()
+        self.title("AST ⟷ Mozaika — meta-evolution (λ) • one-relation arithmetic")
+        self.geometry("1380x900")
+
+        self.M = build_demo_mosaic()
+        self.nodes: List[AstNodeMeta] = []
+        self.pos: Dict[str, Tuple[float, float, float]] = {}
+        self.node_by_label: Dict[str, AstNodeMeta] = {}
+
+        # ——— układ: lewy (edytor + sterowanie), prawy (figura)
+        left = ttk.Frame(self); left.pack(side=tk.LEFT, fill=tk.BOTH, expand=False, padx=8, pady=8)
+        right = ttk.Frame(self); right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=8, pady=8)
+
+        # edytor
+        ttk.Label(left, text="Kod Pythona (Ctrl+Enter = Render):").pack(anchor="w")
+        self.txt = tk.Text(left, width=64, height=32, wrap="none", font=("Consolas", 10))
+        self.txt.pack(fill=tk.BOTH, expand=True)
+        self.txt.insert("1.0", DEFAULT_SNIPPET)
+        self.txt.bind("<Control-Return>", lambda e: self.render())
+
+        # sterowanie
+        ctrl = ttk.LabelFrame(left, text="Sterowanie")
+        ctrl.pack(fill=tk.X, pady=6)
+
+        # λ i β
+        row0 = ttk.Frame(ctrl); row0.pack(fill=tk.X, pady=2)
+        ttk.Label(row0, text="λ (meta skala)").pack(side=tk.LEFT)
+        self.s_lambda = tk.Scale(row0, from_=0.0, to=1.0, resolution=0.02, orient=tk.HORIZONTAL, length=220,
+                                 command=lambda _v: self.repaint())
+        self.s_lambda.set(0.0); self.s_lambda.pack(side=tk.LEFT, padx=6)
+
+        ttk.Label(row0, text="β (wzmocnienie regionu)").pack(side=tk.LEFT, padx=(10, 2))
+        self.s_beta = tk.Scale(row0, from_=0.2, to=2.0, resolution=0.1, orient=tk.HORIZONTAL, length=140,
+                               command=lambda _v: self.repaint())
+        self.s_beta.set(1.0); self.s_beta.pack(side=tk.LEFT)
+
+        # region
+        row1 = ttk.Frame(ctrl); row1.pack(fill=tk.X, pady=2)
+        ttk.Label(row1, text="Region").pack(side=tk.LEFT)
+        self.cmb_region = ttk.Combobox(row1, values=["ROI-A", "ROI-B", "ALL"], width=10, state="readonly")
+        self.cmb_region.set("ROI-A"); self.cmb_region.pack(side=tk.LEFT, padx=6)
+        self.cmb_region.bind("<<ComboboxSelected>>", lambda _e: self.repaint())
+
+        # węzeł AST
+        row2 = ttk.Frame(ctrl); row2.pack(fill=tk.X, pady=2)
+        ttk.Label(row2, text="Węzeł AST").pack(side=tk.LEFT)
+        self.cmb_node = ttk.Combobox(row2, values=[], width=32, state="readonly")
+        self.cmb_node.pack(side=tk.LEFT, padx=6)
+        self.cmb_node.bind("<<ComboboxSelected>>", lambda _e: self.repaint())
+
+        # przyciski
+        row3 = ttk.Frame(ctrl); row3.pack(fill=tk.X, pady=4)
+        ttk.Button(row3, text="Render", command=self.render).pack(side=tk.LEFT, padx=2)
+        ttk.Button(row3, text="Reset widoków", command=self.reset_views).pack(side=tk.LEFT, padx=6)
+        ttk.Button(row3, text="Aa+", command=lambda: self._font_step(+1)).pack(side=tk.RIGHT, padx=2)
+        ttk.Button(row3, text="Aa−", command=lambda: self._font_step(-1)).pack(side=tk.RIGHT, padx=2)
+
+        # figury
+        self.fig = plt.Figure(figsize=(9.6, 6.8))
+        gs = self.fig.add_gridspec(2, 2, height_ratios=[12, 1], width_ratios=[1, 1], hspace=0.25, wspace=0.25)
+        self.ax_ast = self.fig.add_subplot(gs[0, 0], projection="3d")
+        self.ax_mos = self.fig.add_subplot(gs[0, 1], projection="3d")
+        self.ax_inf = self.fig.add_subplot(gs[1, :])
+
+        self.canvas = FigureCanvasTkAgg(self.fig, master=right)
+        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
+        self.toolbar = NavigationToolbar2Tk(self.canvas, right)
+        self.toolbar.update()
+
+        # pierwszy render
+        self.render()
+
+    def _font_step(self, delta: int):
+        try:
+            f = self.txt["font"]
+            fam, size = f.split()[0], int(f.split()[1])
+        except Exception:
+            fam, size = "Consolas", 10
+        size = max(6, size + delta)
+        self.txt.configure(font=(fam, size))
+
+    # ——— logika
+    def render(self):
+        code = self.txt.get("1.0", "end-1c")
+        try:
+            self.nodes = ast_nodes_from_code(code)
+        except SyntaxError as e:
+            messagebox.showerror("Błąd składni", str(e))
+            return
+        except Exception as e:
+            messagebox.showerror("Błąd", f"Nie udało się sparsować AST: {e}")
+            return
+
+        # odśwież listę węzłów do wyboru
+        labels = [f"{n.name}  ·  [{n.kind}]" for n in self.nodes]
+        self.node_by_label = {lab: n for lab, n in zip(labels, self.nodes)}
+        self.cmb_node["values"] = labels
+        if labels:
+            cur = self.cmb_node.get()
+            if cur not in labels:
+                # heurystyka: wybierz „centralny” węzeł (największa energia)
+                pick = max(self.nodes, key=lambda nn: nn.energy)
+                # znajdź jego etykietę
+                for lab, nn in self.node_by_label.items():
+                    if nn is pick:
+                        self.cmb_node.set(lab); break
+
+        # inicjalne pozycje
+        self.repaint()
+
+    def reset_views(self):
+        self.ax_ast.view_init(elev=22, azim=-48)
+        self.ax_mos.view_init(elev=25, azim=-58)
+        self.canvas.draw_idle()
+
+    def repaint(self):
+        if not self.nodes:
+            return
+        lam = float(self.s_lambda.get())
+        beta = float(self.s_beta.get())
+        reg_key = self.cmb_region.get() or "ROI-A"
+
+        pos = coords_for_lambda(self.nodes, lam)
+        self.pos = pos
+
+        # czyszczenie osi
+        self.ax_ast.cla(); self.ax_mos.cla(); self.ax_inf.cla()
+
+        # rysuj AST i mozaikę
+        draw_ast(self.ax_ast, self.nodes, pos)
+        draw_mosaic(self.ax_mos, self.M)
+        draw_region_frame(self.ax_mos, self.M, "ROI-A", color="lime")
+        draw_region_frame(self.ax_mos, self.M, "ROI-B", color="magenta")
+        draw_infographic(self.ax_inf)
+
+        # wybór węzła
+        sel_label = self.cmb_node.get()
+        node = None
+        if sel_label and sel_label in self.node_by_label:
+            node = self.node_by_label[sel_label]
+        else:
+            node = self.nodes[0]
+
+        # fuzja meta
+        ids = region_indices(self.M, reg_key)
+        reg_vec = region_feats(self.M, ids)
+        fused = fuse_meta(np.array(node.meta), reg_vec, lam, beta=beta)
+        draw_fusion(self.ax_ast, self.ax_mos, node, pos, self.M, reg_key, lam, fused)
+
+        # limity osi AST
+        xs, ys, zs = zip(*pos.values())
+        self.ax_ast.set_xlim(min(xs) - 1, max(xs) + 1)
+        self.ax_ast.set_ylim(min(ys) - 1, max(ys) + 1)
+        self.ax_ast.set_zlim(min(zs) - 1, max(zs) + 3.5)
+        self.ax_ast.set_title(f"AST — λ={lam:.2f}  ·  node={node.name} [{node.kind}]  ·  reg={reg_key}  ·  β={beta:.1f}")
+
+        # odśwież
+        self.canvas.draw_idle()
+
+
+# ─────────────────────────────────────────────────────────────
+# 7) MAIN
+# ─────────────────────────────────────────────────────────────
+
+def main():
+    app = App()
+    app.mainloop()
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/mini_mosaic_ast.py b/tests/mini_mosaic_ast.py
new file mode 100644
index 0000000..9a019b6
--- /dev/null
+++ b/tests/mini_mosaic_ast.py
@@ -0,0 +1,241 @@
+# -*- coding: utf-8 -*-
+"""
+mini_mosaic_ast.py — lekki, czytelny szkic metaprzestrzeni (AST ⟷ Mozaika)
+Autor: GlitchLab (demo)
+
+Co pokazuje:
+- Minimalny AST (lista węzłów + rodzice).
+- Minimalna mozaika (siatka kafelków z cechą edge_density oraz warstwami: roi, ssim).
+- Φ (AST→Mozaika): prosty plan — Denoise w ~edges, Blur w edges, Repair tam gdzie ssim spada.
+- Ψ (Mozaika→AST): 1 reguła — jeśli dużo kafelków z niskim ssim, dołóż Repair(region=ssim<τ).
+- Inwarianty I1–I4: szybkie sprawdzenie/druk (pass/warn).
+- Wizualizacja: AST (2D radial) + mozaika (heatmapa SSIM) z konturem ROI i pasem krawędzi.
+
+Wymagania: numpy, matplotlib
+"""
+
+from __future__ import annotations
+import math, numpy as np
+import matplotlib.pyplot as plt
+from dataclasses import dataclass, field
+from typing import List, Dict, Optional, Set, Tuple
+
+# -------------------------------
+# 1) Minimalne modele
+# -------------------------------
+
+@dataclass
+class ASTNode:
+    id: int
+    kind: str                  # 'Load','EdgeMap','Denoise','Blur','Blend','Metric','Repair','ROI'
+    params: Dict = field(default_factory=dict)
+    parent: Optional[int] = None
+    children: List[int] = field(default_factory=list)
+
+@dataclass
+class Mosaic:
+    rows: int
+    cols: int
+    edge: np.ndarray           # (R*C,) edge_density in [0,1]
+    ssim: np.ndarray           # (R*C,) start=1.0
+    roi: np.ndarray            # (R*C,) 0/1
+    def ids(self) -> range: return range(self.rows*self.cols)
+
+# -------------------------------
+# 2) Budowa mini-świata
+# -------------------------------
+
+def build_mini_ast() -> Dict[int, ASTNode]:
+    # Proste drzewko: Load → EdgeMap → {Denoise, Blur} → Blend → Metric
+    nodes: Dict[int, ASTNode] = {}
+    def add(i, kind, parent=None, **params):
+        nodes[i] = ASTNode(i, kind, params, parent, [])
+        if parent is not None: nodes[parent].children.append(i)
+    add(0,'Load')
+    add(1,'EdgeMap', parent=0, method='Sobel', thresh=0.55)
+    add(2,'Denoise', parent=1, algo='NLM', strength=0.35, region='~edges')
+    add(3,'Blur',    parent=1, name='Gaussian', sigma=1.8, region='edges')
+    add(4,'Blend',   parent=0, alpha=0.5)           # traktujemy jako łącznik
+    add(5,'Metric',  parent=4, name='SSIM')
+    # symboliczne ROI (przyda się do I2 pokazowo)
+    add(6,'ROI',     parent=0, shape='rect', rect=(0.3,0.3,0.6,0.6))  # x0,y0,x1,y1 w [0,1]
+    return nodes
+
+def build_mini_mosaic(R=10, C=14, seed=7) -> Mosaic:
+    rng = np.random.default_rng(seed)
+    yy, xx = np.mgrid[0:R, 0:C]
+    diag = 1.0 - np.abs(xx-yy)/max(R,C)
+    edge = np.clip(0.45 + 0.5*diag + 0.06*rng.standard_normal((R,C)),0,1).reshape(-1)
+    ssim = np.ones(R*C)
+    roi  = np.zeros(R*C)
+    # prostokątny ROI (środek)
+    r0, r1 = int(0.3*R), int(0.6*R)
+    c0, c1 = int(0.3*C), int(0.6*C)
+    for r in range(r0,r1):
+        for c in range(c0,c1):
+            roi[r*C+c]=1.0
+    return Mosaic(R,C,edge,ssim,roi)
+
+# -------------------------------
+# 3) Φ: projekcja AST → mozaika
+# -------------------------------
+
+def region_to_ids(region:str, M:Mosaic, edge_thr=0.55) -> Set[int]:
+    region = (region or 'ALL').strip()
+    if region=='ALL': return set(M.ids())
+    if region=='edges':   return {i for i,v in enumerate(M.edge) if v>edge_thr}
+    if region=='~edges':  return {i for i,v in enumerate(M.edge) if v<=edge_thr}
+    if region=='roi':     return {i for i,v in enumerate(M.roi)  if v>0.5}
+    if region.startswith('ssim<'):
+        t=float(region.split('<',1)[1])
+        return {i for i,v in enumerate(M.ssim) if v<t}
+    return set()
+
+def phi_apply(nodes:Dict[int,ASTNode], M:Mosaic, edge_thr=0.55) -> List[str]:
+    """Symuluje wpływ węzłów na warstwę SSIM (lekka, czytelna heurystyka)."""
+    log=[]
+    for n in nodes.values():
+        if n.kind=='Denoise':
+            ids = region_to_ids(n.params.get('region','~edges'), M, edge_thr)
+            k   = n.params.get('strength',0.3)
+            for i in ids:
+                M.ssim[i] = np.clip(M.ssim[i] + 0.18*(1-M.edge[i])*k, 0,1)
+            log.append(f"Denoise @~edges (+SSIM)")
+        if n.kind=='Blur':
+            ids = region_to_ids(n.params.get('region','edges'), M, edge_thr)
+            sig = n.params.get('sigma',1.6)
+            for i in ids:
+                drop = 0.10*(M.edge[i])*sig/2
+                M.ssim[i] = np.clip(M.ssim[i] - drop + 0.05*M.roi[i], 0,1)
+            log.append(f"Blur @edges (-SSIM edge, feather in ROI)")
+        if n.kind=='Repair':
+            ids = region_to_ids(n.params.get('region','ssim<0.8'), M, edge_thr)
+            lim = n.params.get('limit',0.2)
+            for i in ids:
+                M.ssim[i] = np.clip(M.ssim[i] + min(lim, 0.25*(0.9-M.ssim[i])), 0,1)
+            log.append(f"Repair @ssim<thr (+SSIM)")
+    return log
+
+# -------------------------------
+# 4) Ψ: podnoszenie mozaiki → AST
+# -------------------------------
+
+def psi_suggest(M:Mosaic, thr=0.80, frac=0.18) -> Optional[ASTNode]:
+    low = [i for i,v in enumerate(M.ssim) if v<thr]
+    if len(low)/len(M.ssim) > frac:
+        return ASTNode(id=99, kind='Repair', params={'limit':0.25, 'region':f'ssim<{thr}'})
+    return None
+
+# -------------------------------
+# 5) Inwarianty / stałe strukturalne (I1–I4)
+# -------------------------------
+
+def invariants_report(nodes:Dict[int,ASTNode], M:Mosaic, edge_thr=0.55) -> List[str]:
+    rep=[]
+    # I1: operacje nie poza nośnikiem (tu: czy filtrowanie nie deklaruje regionu sprzecznego)
+    ok_I1=True
+    for n in nodes.values():
+        if n.kind in ('Denoise','Blur') and n.params.get('region') not in ('edges','~edges','roi',None):
+            ok_I1=False
+    rep.append(f"I1(types/regions): {'OK' if ok_I1 else 'WARN'}")
+    # I2: spójność — jeśli filtr działa na ROI, złagodź granice (tu: tylko sygnał)
+    edge_band = region_to_ids('edges', M, edge_thr)
+    roi_ids   = region_to_ids('roi', M, edge_thr)
+    boundary_overlap = len(edge_band & roi_ids)/max(1,len(roi_ids))
+    rep.append(f"I2(sheaf continuity @ROI boundary): boundary_overlap≈{boundary_overlap:.2f} (expect small leak)")
+    # I3: lokalność — denoise nie na krawędziach
+    denoise_ok = True
+    for n in nodes.values():
+        if n.kind=='Denoise':
+            sel = region_to_ids(n.params.get('region','~edges'), M, edge_thr)
+            denoise_ok &= all(M.edge[i]<=edge_thr for i in sel)
+    rep.append(f"I3(locality denoise/~edges): {'OK' if denoise_ok else 'WARN'}")
+    # I4: monotoniczność — metryka nie powinna spadać globalnie (sprawdzimy po Φ)
+    rep.append("I4(monotonicity SSIM): will check after Φ (Δglobal≥0)")
+    return rep
+
+# -------------------------------
+# 6) Wizualizacja
+# -------------------------------
+
+def plot_ast(nodes:Dict[int,ASTNode], ax):
+    # prosty layout radialny wg głębokości
+    def depth(nid):
+        d=0; p=nodes[nid].parent
+        while p is not None: d+=1; p=nodes[p].parent
+        return d
+    layers: Dict[int,List[int]]={}
+    for nid in nodes: layers.setdefault(depth(nid),[]).append(nid)
+    for d in layers: layers[d].sort()
+    pos: Dict[int,Tuple[float,float]]={}
+    for d, ids in layers.items():
+        R=0.8*(d+1)/max(1,len(layers))
+        for j,nid in enumerate(ids):
+            a=2*math.pi*j/max(1,len(ids))
+            pos[nid]=(0.5+R*math.cos(a), 0.5+R*math.sin(a))
+    # krawędzie
+    for n in nodes.values():
+        for ch in n.children:
+            x0,y0=pos[n.id]; x1,y1=pos[ch]
+            ax.plot([x0,x1],[y0,y1], color='0.7', lw=1.2, zorder=1)
+    # węzły + etykiety
+    for n in nodes.values():
+        x,y = pos[n.id]
+        ax.scatter([x],[y], s=80, c='white', edgecolors='black', zorder=2)
+        ax.text(x, y, n.kind, ha='center', va='center', fontsize=8, zorder=3)
+    ax.set_title("AST (radial 2D)")
+    ax.axis('off')
+
+def plot_mosaic(M:Mosaic, ax, title="Mosaic SSIM"):
+    img = M.ssim.reshape(M.rows, M.cols)
+    im  = ax.imshow(img, vmin=0.6, vmax=1.02, origin='upper')
+    ax.set_title(title)
+    # kontur ROI
+    roi = M.roi.reshape(M.rows,M.cols)
+    ax.contour(roi, levels=[0.5], colors='white', linewidths=1.2)
+    # pas krawędzi (edge>thr) jako półtransparentna maska
+    ax.imshow((M.edge.reshape(M.rows,M.cols)>0.55), alpha=0.12, cmap='Greys', origin='upper')
+    plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
+
+# -------------------------------
+# 7) Demo end-to-end (czytelne)
+# -------------------------------
+
+def main():
+    nodes = build_mini_ast()
+    M     = build_mini_mosaic(R=10, C=14)
+
+    print("== Invariants (before Φ) ==")
+    for line in invariants_report(nodes, M): print("  -", line)
+
+    ssim_before = M.ssim.copy()
+    log = phi_apply(nodes, M)         # Φ: zastosuj plan
+    d_ssim = float(M.ssim.mean() - ssim_before.mean())
+
+    print("\n== Φ log ==")
+    for l in log: print("  -", l)
+    print(f"Δ SSIM (global mean): {d_ssim:+.3f}")
+
+    patch = psi_suggest(M, thr=0.80, frac=0.18)  # Ψ
+    if patch:
+        print("\n== Ψ suggestion ==")
+        print(f"  - {patch.kind} with {patch.params} in region {patch.params.get('region')} (would be added to AST)")
+        # pokaż efekt hipotetycznie:
+        nodes_s = {**nodes, patch.id: patch}
+        phi_apply({patch.id: patch}, M)
+
+    # I4: sprawdź monotoniczność po Φ
+    ok_I4 = M.ssim.mean() >= ssim_before.mean() - 1e-6
+    print("\n== Invariants (after Φ) ==")
+    print(f"  - I4(monotonicity SSIM global): {'OK' if ok_I4 else 'WARN'}")
+
+    # Wykresy
+    fig, (ax1, ax2) = plt.subplots(1,2, figsize=(11,5))
+    plot_ast(nodes, ax1)
+    plot_mosaic(M, ax2, title="Mosaic SSIM (after Φ/Ψ)")
+    plt.suptitle("Metaprzestrzeń: AST ↔ Mozaika (lekki szkic)", y=0.98)
+    plt.tight_layout()
+    plt.show()
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/mosaic_ast_3d_demo.py b/tests/mosaic_ast_3d_demo.py
new file mode 100644
index 0000000..a0ae65c
--- /dev/null
+++ b/tests/mosaic_ast_3d_demo.py
@@ -0,0 +1,293 @@
+# -*- coding: utf-8 -*-
+"""
+demos/mosaic_ast_3d_demo.py
+---------------------------------
+GlitchLab – 3D demo metaprzestrzeni: AST ↔ Mozaika (+ projekcja Φ)
+
+Co pokazuje:
+- AST 3D ("kompas"): Z = głębokość, X/Y = układ radialny w obrębie warstwy.
+- Mozaika 3D: siatka R×C z kaflami jako słupki bar3d (wysokość/kolor = edge_density).
+- Projekcja Φ: "Denoise(~edges)" i "Blur(edges)" rysują wiązki z węzłów AST do (pod)zbiorów kafli.
+- Raport: szybkie inwarianty I1–I4 i metryki zgodności (d_AST, d_M, d_Φ).
+
+Jak to się ma do GlitchLab:
+- AST tutaj to abstrakt pipeline'u; w GlitchLab przechowywany jako JSON (cache["ast/json"]).
+- Mozaika to warstwa diagnostyczna; w GlitchLab trafia do cache jako mosaic/* (tiles, features, layers).
+- Φ/Ψ w repo idą do core.agent.phi / core.agent.psi; GUI (HUD/GraphView) tylko renderuje i przełącza warstwy.
+
+Autor: Zespół GlitchLab (demo edukacyjne)
+"""
+
+from __future__ import annotations
+import ast, math
+from dataclasses import dataclass, field
+from typing import Dict, List, Optional, Tuple, Set
+
+import numpy as np
+import matplotlib.pyplot as plt
+from mpl_toolkits.mplot3d import Axes3D  # noqa: F401  (import side-effect for 3D)
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 1) AST → struktura i pozycjonowanie 3D (kompas)
+# ────────────────────────────────────────────────────────────────────────────────
+
+@dataclass
+class AstNode:
+    id: int
+    label: str
+    depth: int
+    parent: Optional[int]
+    children: List[int] = field(default_factory=list)
+    pos3d: Tuple[float, float, float] = (0.0, 0.0, 0.0)
+
+EXAMPLE_SRC = r"""
+def pipeline(img):
+    # szkic – nie wykonujemy, tylko parsujemy
+    R = (120, 80, 200, 160)  # ROI
+    E = edges(img, method='Sobel', thresh=0.55)
+    D = denoise_nlm(img, strength=0.35)          # ~edges
+    B = gaussian_blur(img, sigma=1.8)            # edges
+    M = metric_ssim(img, blend(img, B, 0.5))
+    return blend(D, B, 0.5)
+"""
+
+def build_ast_3d(py_src: str) -> Dict[int, AstNode]:
+    root = ast.parse(py_src)
+    nodes: Dict[int, AstNode] = {}
+    nid = 0
+
+    def add(a: ast.AST, depth: int, parent: Optional[int]) -> int:
+        nonlocal nid
+        me = nid; nid += 1
+        lab = a.__class__.__name__
+        nodes[me] = AstNode(me, lab, depth, parent)
+        if parent is not None:
+            nodes[parent].children.append(me)
+        for ch in ast.iter_child_nodes(a):
+            add(ch, depth+1, me)
+        return me
+
+    add(root, 0, None)
+
+    # radial by depth: każdy poziom na pierścieniu, Z=depth
+    by_depth: Dict[int, List[int]] = {}
+    for i, n in nodes.items():
+        by_depth.setdefault(n.depth, []).append(i)
+
+    for d, ids in by_depth.items():
+        ids.sort()
+        R = 6.0 + d*2.0
+        for j, i in enumerate(ids):
+            a = 2*math.pi*j/max(1, len(ids))
+            x = R*math.cos(a)
+            y = R*math.sin(a)
+            z = d*2.0
+            nodes[i].pos3d = (x, y, z)
+
+    return nodes
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 2) Mozaika 3D (R×C słupków) + cechy
+# ────────────────────────────────────────────────────────────────────────────────
+
+@dataclass
+class Mosaic:
+    rows: int
+    cols: int
+    edge: np.ndarray   # (N,) w [0,1]
+    ssim: np.ndarray   # (N,) baseline = 1.0
+    roi:  np.ndarray   # (N,) 0/1
+
+def build_mosaic(rows=10, cols=14, seed=7) -> Mosaic:
+    rng = np.random.default_rng(seed)
+    yy, xx = np.mgrid[0:rows, 0:cols]
+    # pas krawędzi wzdłuż przekątnej
+    diag = 1.0 - np.abs(xx-yy)/max(rows, cols)
+    edge = np.clip(0.45 + 0.5*diag + 0.06*rng.standard_normal((rows, cols)), 0, 1).reshape(-1)
+    ssim = np.ones(rows*cols)
+    roi  = np.zeros(rows*cols)
+    r0, r1 = int(0.30*rows), int(0.62*rows)
+    c0, c1 = int(0.30*cols), int(0.62*cols)
+    for r in range(r0, r1):
+        for c in range(c0, c1):
+            roi[r*cols+c] = 1.0
+    return Mosaic(rows, cols, edge, ssim, roi)
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 3) Projekcja Φ (AST→Mozaika) – wybór kafli i logika linii
+# ────────────────────────────────────────────────────────────────────────────────
+
+def region_ids(region: str, M: Mosaic, edge_thr=0.55) -> Set[int]:
+    if region == 'ALL': return set(range(M.rows*M.cols))
+    if region == 'edges':   return {i for i,v in enumerate(M.edge) if v>edge_thr}
+    if region == '~edges':  return {i for i,v in enumerate(M.edge) if v<=edge_thr}
+    if region == 'roi':     return {i for i,v in enumerate(M.roi)  if v>0.5}
+    if region.startswith('ssim<'):
+        thr = float(region.split('<',1)[1])
+        return {i for i,v in enumerate(M.ssim) if v<thr}
+    return set()
+
+def ast_interest_nodes(nodes: Dict[int, AstNode]) -> Dict[str, int]:
+    """
+    Heurystycznie wskaż 3 węzły 'tematyczne' do połączenia z mozaiką.
+    (W realnym GlitchLab robi to parser AST pipeline'u i rejestr filtrów).
+    """
+    by_label = {}
+    for n in nodes.values():
+        by_label.setdefault(n.label, []).append(n.id)
+    # wybierz po 1 sztuce (gdy brak – None)
+    pick = lambda lbl: by_label.get(lbl, [None])[0]
+    return {
+        'Denoise': pick('Expr'),  # demo: Expr ~ denoise
+        'Blur':    pick('Expr'),  # drugi Expr ~ blur (tylko do wizualizacji)
+        'If':      pick('If'),
+        'Return':  pick('Return'),
+    }
+
+def phi_demo_plans(M: Mosaic) -> Dict[str, Set[int]]:
+    """Dwa regiony do pokazania projekcji: edges (dla blur) i ~edges (dla denoise)."""
+    return {
+        'denoise_region': region_ids('~edges', M),
+        'blur_region':    region_ids('edges',  M),
+        'roi_region':     region_ids('roi',    M),
+    }
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 4) Pseudometryki / inwarianty (lekkie)
+# ────────────────────────────────────────────────────────────────────────────────
+
+def d_ast(nodes: Dict[int, AstNode]) -> float:
+    E = sum(len(n.children) for n in nodes.values())
+    depth_pen = sum(n.depth**1.15 for n in nodes.values())
+    return float(E + 0.02*depth_pen)
+
+def d_mosaic(M: Mosaic) -> float:
+    return float(np.var(M.edge) + 0.5*np.var(M.ssim))
+
+def d_phi_cost(M: Mosaic, denoise_ids:Set[int], blur_ids:Set[int], thr=0.55) -> float:
+    # kara: denoise na krawędziach + blur na nie-krawędziach
+    cost  = sum(M.edge[i] for i in denoise_ids)*0.1
+    cost += sum(1.0-M.edge[i] for i in blur_ids)*0.1
+    return float(cost)
+
+def invariants_summary(M: Mosaic, denoise_ids:Set[int], blur_ids:Set[int], thr=0.55) -> Dict[str,str]:
+    I1 = "OK"  # w tym demo regio selekcje są poprawne typowo
+    I3 = "OK" if all(M.edge[i]<=thr for i in denoise_ids) else "WARN"
+    # granica ROI dotyka pas krawędzi? informacyjnie
+    roi_set   = set(region_ids('roi', M))
+    edges_set = set(region_ids('edges', M, thr))
+    overlap   = len(roi_set & edges_set)/max(1,len(roi_set))
+    I2 = f"boundary_overlap≈{overlap:.2f} (expect small leak control)"
+    I4 = "check after Φ (Δ mean SSIM ≥ 0)"
+    return {"I1":I1, "I2":I2, "I3":I3, "I4":I4}
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 5) Rysowanie 3D
+# ────────────────────────────────────────────────────────────────────────────────
+
+def draw_ast_3d(ax, nodes: Dict[int, AstNode], title="AST → Kompas 3D"):
+    # krawędzie
+    for n in nodes.values():
+        x0,y0,z0 = n.pos3d
+        for cid in n.children:
+            x1,y1,z1 = nodes[cid].pos3d
+            ax.plot([x0,x1],[y0,y1],[z0,z1], color="#7b8fa1", lw=1.0)
+    # węzły
+    for n in nodes.values():
+        x,y,z = n.pos3d
+        ax.scatter([x],[y],[z], s=20, c="white", edgecolors="black", depthshade=True)
+        if n.depth<=3:
+            ax.text(x, y, z+0.6, n.label, fontsize=8)
+    ax.set_title(title)
+    ax.set_xlabel("X"); ax.set_ylabel("Y"); ax.set_zlabel("Z (depth)")
+
+def draw_mosaic_3d(ax, M: Mosaic, title="Mosaic 3D (edge density)"):
+    R,C = M.rows, M.cols
+    xs, ys, zs, dx, dy, dz, colors = [], [], [], [], [], [], []
+    # słupek w (c,r) o wysokości proporcjonalnej do edge
+    for r in range(R):
+        for c in range(C):
+            i = r*C+c
+            h = 2.0*M.edge[i] + 0.1  # [0.1..2.1]
+            xs.append(c); ys.append(r); zs.append(0.0)
+            dx.append(0.85); dy.append(0.85); dz.append(h)
+            colors.append( (M.edge[i], 0.2, 1.0-M.edge[i], 0.9) )  # RGBA
+    ax.bar3d(xs, ys, zs, dx, dy, dz, shade=True, color=colors, linewidth=0.1)
+    # ROI kontur jako „rama” (drut)
+    roi = M.roi.reshape(R,C)
+    rr, cc = np.where(roi>0.5)
+    if len(rr)>0:
+        rmin,rmax = rr.min(), rr.max()
+        cmin,cmax = cc.min(), cc.max()
+        z = 2.3
+        ax.plot([cmin, cmax, cmax, cmin, cmin],
+                [rmin, rmin, rmax, rmax, rmin],
+                [z,z,z,z,z], color="white", lw=1.8, alpha=0.9)
+    ax.set_title(title)
+    ax.set_xlabel("cols"); ax.set_ylabel("rows"); ax.set_zlabel("edge→height")
+    ax.view_init(elev=25, azim=-60)
+
+def draw_phi_links(ax, src_pos: Tuple[float,float,float], M: Mosaic, tile_ids: Set[int], max_lines=50, color="#ff8a00"):
+    """Wiązki z jednego węzła AST do centów kafli (losowo–rzadko, by nie śmiecić)."""
+    R,C = M.rows, M.cols
+    ids = list(tile_ids)
+    if len(ids) > max_lines:
+        ids = list(np.random.default_rng(0).choice(ids, size=max_lines, replace=False))
+    x0,y0,z0 = src_pos
+    for i in ids:
+        r, c = divmod(i, C)
+        # centroid słupka (w mozaice)
+        x1 = c + 0.42
+        y1 = r + 0.42
+        z1 = 2.2  # nad wierzchołkiem
+        ax.plot([x0,x1], [y0,y1], [z0,z1], color=color, lw=0.7, alpha=0.7)
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 6) Main – spinamy całość
+# ────────────────────────────────────────────────────────────────────────────────
+
+def main():
+    # Buduj struktury
+    nodes = build_ast_3d(EXAMPLE_SRC)
+    M      = build_mosaic(rows=10, cols=14)
+    picks  = ast_interest_nodes(nodes)
+    plans  = phi_demo_plans(M)
+
+    # Raport
+    denoise_ids = plans['denoise_region']
+    blur_ids    = plans['blur_region']
+    inv = invariants_summary(M, denoise_ids, blur_ids)
+    print("== Invariants ==")
+    for k,v in inv.items(): print(f"  - {k}: {v}")
+    print(f"d_AST={d_ast(nodes):.3f} | d_M={d_mosaic(M):.3f} | d_Φ≈{d_phi_cost(M, denoise_ids, blur_ids):.3f}")
+
+    # Rysuj scenę 3D (2 osie: AST i Mozaika)
+    fig = plt.figure(figsize=(13,6))
+    ax_ast = fig.add_subplot(1,2,1, projection='3d')
+    ax_mos = fig.add_subplot(1,2,2, projection='3d')
+
+    draw_ast_3d(ax_ast, nodes)
+    draw_mosaic_3d(ax_mos, M)
+
+    # Projekcja Φ – linki z "denoise" (nie-krawędzie) i "blur" (krawędzie)
+    # (tu bierzemy dwa różne węzły Expr jako „uchwyty” – w realnym GL mapping jest po nazwie filtra)
+    expr_nodes = [n for n in nodes.values() if n.label=="Expr"]
+    if expr_nodes:
+        src_denoise = expr_nodes[0].pos3d
+        src_blur    = expr_nodes[-1].pos3d if len(expr_nodes)>1 else expr_nodes[0].pos3d
+        draw_phi_links(ax_ast, src_denoise, M, denoise_ids, color="#16a34a")  # zielone
+        draw_phi_links(ax_ast, src_blur,    M, blur_ids,    color="#e11d48")  # różowe
+
+    # Podpisz, by było jasne co oglądamy
+    fig.suptitle("GlitchLab – 3D metaprzestrzeń: AST (kompas) ↔ Mozaika (kratownica) + projekcja Φ", y=0.98)
+    plt.tight_layout()
+    plt.show()
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/mosaic_ast_metalegend_demo.py b/tests/mosaic_ast_metalegend_demo.py
new file mode 100644
index 0000000..78b6c34
--- /dev/null
+++ b/tests/mosaic_ast_metalegend_demo.py
@@ -0,0 +1,313 @@
+# -*- coding: utf-8 -*-
+"""
+demos/mosaic_ast_metalegend_demo.py
+-----------------------------------
+GlitchLab – "punkt 0" (możowanie) między AST i Mozaiką.
+Każdy węzeł AST ma *metastrukturę* (stałe strukturalne) → wektor w meta-przestrzeni.
+W punkcie 0 ten wektor "współgra" z mozaiką (region/warstwa), tworząc jedną, samopiszącą się strukturę.
+
+Wizualizacja:
+- 3D AST (kompas): Z = głębokość; na każdym węźle pionowy "meta-słupek" (wysokość=energia meta, kolor=entropia).
+- 3D Mozaika: kratownica R×C (bar3d); wysokość/kolor = edge_density; ROI jako rama.
+- "Punkt 0": dla każdego węzła liczymy centroid kafli, na których węzeł *działa* (region), i rysujemy wiązkę
+  AST_node → fusion_point (centroid na mozaice), a w fusion_point stawiamy świecący marker.
+- Legenda/infografika: komiksowe klocki z opisem meta-wymiarów oraz schemat Φ/Ψ i "punktu 0".
+
+Autor: GlitchLab (demo edukacyjne)
+"""
+
+from __future__ import annotations
+import ast, math
+from dataclasses import dataclass, field
+from typing import Dict, List, Optional, Tuple, Set
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.patches import FancyBboxPatch
+from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 (3D projection side-effect)
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 1) AST: struktura + meta-wymiary node'ów
+# ────────────────────────────────────────────────────────────────────────────────
+
+@dataclass
+class AstNode:
+    id: int
+    label: str
+    depth: int
+    parent: Optional[int]
+    children: List[int] = field(default_factory=list)
+    pos3d: Tuple[float, float, float] = (0.0, 0.0, 0.0)
+    # meta: 6-wymiarowy wektor stałych strukturalnych w [0,1]
+    # (locality, scale, selectivity, stability, causality, entropy)
+    meta: Tuple[float, float, float, float, float, float] = (0, 0, 0, 0, 0, 0)
+
+    @property
+    def meta_energy(self) -> float:
+        return float(np.linalg.norm(self.meta))
+
+    @property
+    def meta_entropy(self) -> float:
+        return float(self.meta[-1])
+
+
+EXAMPLE_SRC = r"""
+def pipeline(img):
+    R  = (120, 80, 200, 160)            # ROI
+    E  = edges(img, method='Sobel', thresh=0.55)
+    D  = denoise_nlm(img, strength=0.35)      # ~edges
+    B  = gaussian_blur(img, sigma=1.8)        # edges
+    Z  = blend(img, B, 0.5)
+    M  = metric_ssim(img, Z)
+    return blend(D, B, 0.5)
+"""
+
+
+def build_ast_with_meta(py_src: str) -> Dict[int, AstNode]:
+    """Buduje AST i przypisuje meta-wektory na podstawie typu węzła (heurystyki demo)."""
+    root = ast.parse(py_src)
+    nodes: Dict[int, AstNode] = {}
+    nid = 0
+
+    def add(a: ast.AST, depth: int, parent: Optional[int]) -> int:
+        nonlocal nid
+        me = nid;
+        nid += 1
+        lab = a.__class__.__name__
+        n = AstNode(me, lab, depth, parent)
+        nodes[me] = n
+        if parent is not None:
+            nodes[parent].children.append(me)
+        for ch in ast.iter_child_nodes(a):
+            add(ch, depth + 1, me)
+        return me
+
+    add(root, 0, None)
+
+    # Pozycjonowanie radialne
+    by_depth: Dict[int, List[int]] = {}
+    for i, n in nodes.items(): by_depth.setdefault(n.depth, []).append(i)
+    for d, ids in by_depth.items():
+        ids.sort()
+        R = 6.0 + d * 2.0
+        for j, i in enumerate(ids):
+            a = 2 * math.pi * j / max(1, len(ids))
+            nodes[i].pos3d = (R * math.cos(a), R * math.sin(a), d * 2.0)
+
+    # Meta-heurystyki: im "bardziej kontrolny" node, tym wyższa selectivity/causality itp.
+    rng = np.random.default_rng(42)
+    for n in nodes.values():
+        loc, sca, sel, stab, cau, ent = rng.uniform(0.25, 0.85, size=6)
+        if n.label in ("If", "Compare"):
+            sel, cau = 0.85, 0.80
+        if n.label in ("Expr", "Call"):
+            loc, sca = 0.65, 0.55
+        if n.label in ("Return",):
+            stab = 0.9
+        if n.label in ("Assign",):
+            sel = 0.7
+        # delikatna normalizacja
+        nodes[n.id].meta = (loc, sca, sel, stab, cau, ent)
+
+    return nodes
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 2) Mozaika: kratownica 3D (edge/ROI/SSIM)
+# ────────────────────────────────────────────────────────────────────────────────
+
+@dataclass
+class Mosaic:
+    rows: int
+    cols: int
+    edge: np.ndarray  # (N,) [0,1]
+    ssim: np.ndarray  # (N,) [0,1] (baseline 1)
+    roi: np.ndarray  # (N,) 0/1
+
+
+def build_mosaic(rows=10, cols=14, seed=7) -> Mosaic:
+    rng = np.random.default_rng(seed)
+    yy, xx = np.mgrid[0:rows, 0:cols]
+    diag = 1.0 - np.abs(xx - yy) / max(rows, cols)
+    edge = np.clip(0.45 + 0.5 * diag + 0.06 * rng.standard_normal((rows, cols)), 0, 1).reshape(-1)
+    ssim = np.ones(rows * cols)
+    roi = np.zeros(rows * cols)
+    r0, r1 = int(0.3 * rows), int(0.62 * rows)
+    c0, c1 = int(0.3 * cols), int(0.62 * cols)
+    for r in range(r0, r1):
+        for c in range(c0, c1):
+            roi[r * cols + c] = 1.0
+    return Mosaic(rows, cols, edge, ssim, roi)
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 3) Regiony/Φ: do jakich kafli "celuje" dany węzeł (symbolicznie)
+# ────────────────────────────────────────────────────────────────────────────────
+
+def region_for_node(n: AstNode, M: Mosaic, edge_thr=0.55) -> Set[int]:
+    """Symboliczna mapa: część Expr'ów traktujemy jak Denoise(~edges) / Blur(edges)."""
+    if n.label == "Assign":  # ROI
+        return {i for i, v in enumerate(M.roi) if v > 0.5}
+    if n.label == "Expr":
+        # heurystyka: parzyste → blur(edges), nieparzyste → denoise(~edges)
+        if (n.id % 2) == 0:
+            return {i for i, v in enumerate(M.edge) if v > edge_thr}
+        else:
+            return {i for i, v in enumerate(M.edge) if v <= edge_thr}
+    if n.label in ("Return", "If"):
+        return set(range(M.rows * M.cols))  # global
+    return set()
+
+
+def centroid_of_tiles(ids: Set[int], M: Mosaic) -> Tuple[float, float, float]:
+    """Centroid w przestrzeni mozaiki (x:kolumna, y:wiersz, z: 'edge-height')."""
+    if not ids:
+        return (M.cols * 0.5, M.rows * 0.5, 0.0)
+    rows, cols = M.rows, M.cols
+    cs = np.array([i % cols for i in ids], dtype=float)
+    rs = np.array([i // cols for i in ids], dtype=float)
+    zs = np.array([2.0 * M.edge[i] + 0.1 for i in ids], dtype=float)
+    return (float(cs.mean() + 0.42), float(rs.mean() + 0.42), float(zs.mean()))
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 4) Rysowanie – AST 3D, Mozaika 3D, wiązki i „punkty 0”, legenda-infografika
+# ────────────────────────────────────────────────────────────────────────────────
+
+def draw_ast_3d(ax, nodes: Dict[int, AstNode]):
+    # krawędzie
+    for n in nodes.values():
+        x0, y0, z0 = n.pos3d
+        for cid in n.children:
+            x1, y1, z1 = nodes[cid].pos3d
+            ax.plot([x0, x1], [y0, y1], [z0, z1], color="#7b8fa1", lw=1.0)
+    # węzły jako "meta-słupki"
+    cmap = plt.get_cmap("plasma")
+    for n in nodes.values():
+        x, y, z = n.pos3d
+        h = 1.2 + 2.2 * (n.meta_energy / np.sqrt(6))  # norm meta max≈√6
+        c = cmap(n.meta_entropy)  # kolor = entropia
+        ax.plot([x, x], [y, y], [z, z + h], color=c, lw=3.0)  # słupek
+        ax.scatter([x], [y], [z + h], s=25, c=[c], edgecolors="black", depthshade=True)
+        if n.depth <= 3:
+            ax.text(x, y, z + h + 0.4, n.label, fontsize=8, ha="center")
+    ax.set_title("AST → Kompas 3D z metaglifami")
+    ax.set_xlabel("X");
+    ax.set_ylabel("Y");
+    ax.set_zlabel("Z (depth/meta)")
+
+
+def draw_mosaic_3d(ax, M: Mosaic):
+    R, C = M.rows, M.cols
+    xs, ys, zs, dx, dy, dz, colors = [], [], [], [], [], [], []
+    for r in range(R):
+        for c in range(C):
+            i = r * C + c
+            h = 2.0 * M.edge[i] + 0.1
+            xs.append(c);
+            ys.append(r);
+            zs.append(0.0)
+            dx.append(0.85);
+            dy.append(0.85);
+            dz.append(h)
+            colors.append((M.edge[i], 0.2, 1.0 - M.edge[i], 0.95))
+    ax.bar3d(xs, ys, zs, dx, dy, dz, color=colors, linewidth=0.1, shade=True)
+    # ROI jako rama
+    roi = M.roi.reshape(R, C)
+    rr, cc = np.where(roi > 0.5)
+    if len(rr) > 0:
+        rmin, rmax = rr.min(), rr.max()
+        cmin, cmax = cc.min(), cc.max()
+        z = 2.4
+        ax.plot([cmin, cmax, cmax, cmin, cmin], [rmin, rmin, rmax, rmax, rmin], [z, z, z, z, z], color="white", lw=1.8)
+    ax.set_title("Mozaika 3D (edge density)")
+    ax.set_xlabel("cols");
+    ax.set_ylabel("rows");
+    ax.set_zlabel("edge→height")
+    ax.view_init(elev=24, azim=-58)
+
+
+def draw_fusion_links(ax_ast, ax_mos, nodes: Dict[int, AstNode], M: Mosaic):
+    """Rysuje wiązki AST→punkt0 oraz markery punktów 0 na mozaice."""
+    rng = np.random.default_rng(0)
+    for n in nodes.values():
+        ids = region_for_node(n, M)
+        if not ids: continue
+        # punkt 0 (centroid)
+        cx, cy, cz = centroid_of_tiles(ids, M)
+        # „świat mozaiki” jest w innych jednostkach – narysuj marker na osi mozaiki:
+        ax_mos.scatter([cx], [cy], [cz + 0.05], s=35, c="#ffd166", edgecolors="black", depthshade=True, zorder=10)
+        # wiązka z AST: cienka linia (kolor od entropii)
+        c = plt.get_cmap("plasma")(n.meta_entropy)
+        x0, y0, z0 = n.pos3d
+        # aby było wyraźnie, końcówkę linii pozycjonujemy w *ramce AST*, ale w kierunku mozaiki:
+        # ułóż "pseudo-most": AST→(średni wektor w stronę sceny mozaiki)
+        # (prosto: przeskaluj koord. mozaiki do chmury wokół AST)
+        x1, y1, z1 = x0 + 0.15 * (cx - M.cols * 0.5), y0 + 0.15 * (cy - M.rows * 0.5), z0 + 0.3
+        ax_ast.plot([x0, x1], [y0, y1], [z0, x1 * 0 + z1], color=c, lw=0.9, alpha=0.85)
+
+
+def draw_infographic(ax):
+    """Infografika – klocki znaczeń, nie 'lista'."""
+    ax.axis("off")
+    # bloki (rounded) + krótkie hasła
+    blocks = [
+        ("Locality (L)", "gdzie działa\n(ROI / ~edges / global)"),
+        ("Scale (S)", "na jakiej skali\n(tile / multi-scale)"),
+        ("Selectivity (Sel)", "jak wybiera\n(progi, reguły)"),
+        ("Stability (Stab)", "czy utrzymuje\nspójność (I2)"),
+        ("Causality (Cau)", "wpływ na resztę\n(sterowanie Ψ)"),
+        ("Entropy (H)", "stopień wolności\n/ niepewność"),
+    ]
+    x0, y0, dx, dy = 0.05, 0.55, 0.28, 0.12
+    for i, (title, desc) in enumerate(blocks):
+        xi = x0 + (i % 3) * dx
+        yi = y0 - (i // 3) * dy
+        box = FancyBboxPatch((xi, yi), dx - 0.02, dy - 0.02, boxstyle="round,pad=0.02,rounding_size=0.02",
+                             linewidth=1.2, edgecolor="#334155", facecolor="#e2e8f0")
+        ax.add_patch(box)
+        ax.text(xi + 0.01, yi + dy - 0.05, title, fontsize=10, weight="bold", color="#0f172a")
+        ax.text(xi + 0.01, yi + 0.02, desc, fontsize=9, color="#1f2937")
+    # Schemat Φ / Ψ + „punkt 0”
+    ax.text(0.05, 0.40, "Φ: AST → Mozaika", fontsize=11, weight="bold", color="#0f766e")
+    ax.text(0.05, 0.35, "node.meta  ⟶  selektor(region)  ⟶  centroid tiles  =  punkt 0", fontsize=9)
+    ax.text(0.05, 0.28, "Ψ: Mozaika → AST", fontsize=11, weight="bold", color="#7c2d12")
+    ax.text(0.05, 0.23, "warstwy/metryki  ⟶  reguły podnoszenia  ⟶  nowy/zmieniony node", fontsize=9)
+    # Wzór energii / kolorystyki meta-glifu
+    ax.text(0.05, 0.12, "Metaglif węzła:", fontsize=11, weight="bold")
+    ax.text(0.05, 0.08, "wysokość = ‖(L,S,Sel,Stab,Cau,H)‖   |   kolor = H (entropia)", fontsize=9)
+    # I1–I4 piktogramy
+    ax.text(0.62, 0.40, "Inwarianty:", fontsize=11, weight="bold")
+    ax.text(0.62, 0.34, "I1  typy/nośniki  ✓", fontsize=9)
+    ax.text(0.62, 0.29, "I2  spójność (sheaf)  ⇄", fontsize=9)
+    ax.text(0.62, 0.24, "I3  lokalność/leak ≤ δ", fontsize=9)
+    ax.text(0.62, 0.19, "I4  monotoniczność celu", fontsize=9)
+
+
+# ────────────────────────────────────────────────────────────────────────────────
+# 5) Main
+# ────────────────────────────────────────────────────────────────────────────────
+
+def main():
+    nodes = build_ast_with_meta(EXAMPLE_SRC)
+    M = build_mosaic(rows=10, cols=14)
+
+    # Scena: 3 panele – AST 3D, Mozaika 3D, infografika
+    fig = plt.figure(figsize=(14, 6))
+    ax_ast = fig.add_subplot(1, 3, 1, projection="3d")
+    ax_mos = fig.add_subplot(1, 3, 2, projection="3d")
+    ax_inf = fig.add_subplot(1, 3, 3)
+
+    draw_ast_3d(ax_ast, nodes)
+    draw_mosaic_3d(ax_mos, M)
+    draw_fusion_links(ax_ast, ax_mos, nodes, M)
+    draw_infographic(ax_inf)
+
+    fig.suptitle("GlitchLab – Punkt 0: możowanie metastruktur AST z mozaiką", y=0.98)
+    plt.tight_layout()
+    plt.show()
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/mosaic_ast_to3d_point0.py b/tests/mosaic_ast_to3d_point0.py
new file mode 100644
index 0000000..424a530
--- /dev/null
+++ b/tests/mosaic_ast_to3d_point0.py
@@ -0,0 +1,467 @@
+# -*- coding: utf-8 -*-
+"""
+GlitchLab – Punkt 0 w 3D: AST ⇄ Mozaika (hex 12×12 – stykające się bokami) ⇄ Lattice BCC (14-NN ~ truncated octahedra)
+
+• AST 3D: metaglif (wysokość = ||meta||, kolor = entropia).
+• Mozaika HEX 12×12: axial (q,r), pointy-top, spacing gwarantujący STYK BOKÓW.
+• Lattice 3D (Voronoi BCC): centra komórek + krawędzie 14-sąsiedztwa (aproksymacja ściętych ośmiościanów).
+• Φ (AST→Mozaika), Ψ (Mozaika→AST), „punkt 0” (centroid regionu).
+• Miary: CR_AST (Merkle), CR_TO (snap do komórek BCC), Align3D, J_phi.
+
+Wymagania: numpy, matplotlib
+Uruchom:  python demos/mosaic_ast_to3d_point0.py
+"""
+
+from __future__ import annotations
+import ast, math, hashlib, json
+from dataclasses import dataclass, field
+from typing import Dict, List, Tuple, Optional, Set
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.patches import RegularPolygon
+from mpl_toolkits.mplot3d import Axes3D  # noqa
+
+
+# ─────────────────────────────────────────────
+# 0) AST: parsowanie, metaglif, Merkle
+# ─────────────────────────────────────────────
+
+@dataclass
+class AstNode:
+    id: int
+    kind: str
+    label: str
+    depth: int
+    parent: Optional[int]
+    children: List[int] = field(default_factory=list)
+    meta: Tuple[float,float,float,float,float,float] = (0,0,0,0,0,0)
+    pos3d: Tuple[float,float,float] = (0.0,0.0,0.0)
+    h: str = ""
+
+    @property
+    def energy(self) -> float:  # ||meta||
+        return float(np.linalg.norm(self.meta))
+
+    @property
+    def entropy(self) -> float:  # H
+        return float(self.meta[-1])
+
+EXAMPLE = r"""
+def pipeline(img):
+    R  = (120, 80, 200, 160)
+    E  = edges(img, method='Sobel', thresh=0.55)
+    D  = denoise_nlm(img, strength=0.35)
+    B  = gaussian_blur(img, sigma=1.8)
+    Z  = blend(img, B, 0.5)
+    M  = metric_ssim(img, Z)
+    return blend(D, B, 0.5)
+"""
+
+def _label(n: ast.AST) -> str:
+    if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)): return f"def {n.name}"
+    if isinstance(n, ast.ClassDef): return f"class {n.name}"
+    if isinstance(n, ast.Assign):
+        t = n.targets[0] if n.targets else None
+        return f"{getattr(t,'id','assign')} = …"
+    if isinstance(n, ast.Name): return n.id
+    return type(n).__name__
+
+def build_ast(src: str) -> Dict[int, AstNode]:
+    root = ast.parse(src)
+    nodes: Dict[int, AstNode] = {}
+    nid = 0
+    def add(a: ast.AST, d: int, p: Optional[int]):
+        nonlocal nid
+        me = nid; nid += 1
+        nodes[me] = AstNode(me, a.__class__.__name__, _label(a), d, p)
+        if p is not None: nodes[p].children.append(me)
+        for ch in ast.iter_child_nodes(a): add(ch, d+1, me)
+    add(root, 0, None)
+
+    # pozycjonowanie radialne (kompas); Z = depth*2
+    by_d: Dict[int,List[int]] = {}
+    for i,n in nodes.items(): by_d.setdefault(n.depth,[]).append(i)
+    for d, ids in by_d.items():
+        ids.sort()
+        R = 6.0 + 2.0*d
+        for j,i in enumerate(ids):
+            a = 2*math.pi*j/max(1,len(ids))
+            nodes[i].pos3d = (R*math.cos(a), R*math.sin(a), 2.0*d)
+
+    # meta – deterministyczne heurystyki (stabilne)
+    for n in nodes.values():
+        L=S=Sel=Stab=Cau=H = 0.55
+        if n.kind in ("If","Compare"): Sel, Cau, H = 0.85, 0.80, 0.60
+        if n.kind in ("Expr","Call"):  L, S = 0.65, 0.58
+        if n.kind in ("Return",):      Stab = 0.90
+        if n.kind in ("Assign",):      Sel = 0.70
+        nodes[n.id].meta = (L,S,Sel,Stab,Cau,H)
+
+    # Merkle (hash poddrzew)
+    def merkle(i:int)->str:
+        ch = "".join(sorted(merkle(c) for c in nodes[i].children))
+        s = f"{nodes[i].kind}|{nodes[i].label}|{ch}"
+        h = hashlib.sha256(s.encode()).hexdigest()[:16]
+        nodes[i].h = h; return h
+    _ = merkle(0)
+    return nodes
+
+
+# ─────────────────────────────────────────────
+# 1) HEX 12×12 – stykające (axial q,r; pointy-top)
+# ─────────────────────────────────────────────
+
+HEX_R = 1.0  # radius to VERTEX (pointy-top). Apothegm = √3/2 * R.
+# DYSTANSE DLA STYKU BOKAMI (pointy-top):
+# Δx = √3 * R ; Δy = 1.5 * R  (dokładnie te wartości → brak szczelin)
+def axial_to_xy(q:int, r:int, R:float=HEX_R)->Tuple[float,float]:
+    return ( (math.sqrt(3.0)*R)*(q + 0.5*(r&1)) , (1.5*R)*r )
+
+@dataclass
+class Hex:
+    q:int; r:int
+    center: Tuple[float,float]
+    edge: float
+    roi: int
+
+@dataclass
+class Mosaic:
+    rows:int; cols:int
+    hexes: List[Hex]
+
+def build_hex_mosaic(rows=12, cols=12)->Mosaic:
+    hexes: List[Hex] = []
+    # ciągła „tekstura” edge – zależna tylko od (x,y), bez aliasingu
+    for r in range(rows):
+        for q in range(cols):
+            x,y = axial_to_xy(q,r,HEX_R)
+            edge = 0.50 + 0.45*math.tanh(0.17*x - 0.15*y)  # płynne pole
+            hexes.append(Hex(q,r,(x,y), edge, 0))
+    # ROI: centralny romb
+    xs = np.array([h.center[0] for h in hexes]); ys = np.array([h.center[1] for h in hexes])
+    x0,x1 = np.quantile(xs,[0.35,0.65]); y0,y1 = np.quantile(ys,[0.35,0.65])
+    for h in hexes:
+        h.roi = int(x0<=h.center[0]<=x1 and y0<=h.center[1]<=y1)
+    return Mosaic(rows, cols, hexes)
+
+
+# ─────────────────────────────────────────────
+# 2) Lattice 3D: Voronoi BCC (14-NN ~ truncated octahedra)
+# ─────────────────────────────────────────────
+
+BCC_HEX = [(+1,+1,+1),(+1,+1,-1),(+1,-1,+1),(+1,-1,-1),
+           (-1,+1,+1),(-1,+1,-1),(-1,-1,+1),(-1,-1,-1)]
+BCC_SQR = [(+2,0,0),(-2,0,0),(0,+2,0),(0,-2,0),(0,0,+2),(0,0,-2)]
+
+@dataclass
+class Cell:
+    xyz: Tuple[int,int,int]
+    center: Tuple[float,float,float]
+
+@dataclass
+class BCC:
+    cells: List[Cell]
+    index: Dict[Tuple[int,int,int], int]
+    neighbors: Dict[int, List[int]]
+
+def build_bcc(nx=6, ny=6, nz=4, scale=1.0)->BCC:
+    cells=[]; index={}
+    def to_center(x,y,z): return (scale*x/2.0, scale*y/2.0, scale*z/2.0)
+    k=0
+    for z in range(-nz,nz+1):
+        for y in range(-ny,ny+1):
+            for x in range(-nx,nx+1):
+                if (x+y+z)%2==0:
+                    cells.append(Cell((x,y,z), to_center(x,y,z)))
+                    index[(x,y,z)] = k; k+=1
+    neigh: Dict[int,List[int]]={}
+    for i,c in enumerate(cells):
+        x,y,z = c.xyz
+        ids=[]
+        for dx,dy,dz in (BCC_HEX + BCC_SQR):
+            j = index.get((x+dx,y+dy,z+dz))
+            if j is not None: ids.append(j)
+        neigh[i]=ids
+    return BCC(cells,index,neigh)
+
+
+# ─────────────────────────────────────────────
+# 3) Φ / Ψ / „punkt 0” / metryki
+# ─────────────────────────────────────────────
+
+def region_ids_for_node(n: AstNode, M: Mosaic, thr=0.6) -> Set[int]:
+    ids=set()
+    for i,h in enumerate(M.hexes):
+        if n.kind=="Assign":
+            if h.roi: ids.add(i)
+        elif n.kind in ("Expr","Call"):
+            # parzyste → „edges”, nieparzyste → „~edges”
+            if (n.id%2)==0 and h.edge>thr: ids.add(i)
+            if (n.id%2)==1 and h.edge<=thr: ids.add(i)
+        elif n.kind in ("Return","If"):
+            ids.add(i)
+    return ids
+
+def centroid_hex(ids:Set[int], M:Mosaic)->Tuple[float,float,float]:
+    if not ids:
+        # środek sceny mozaiki
+        xs = [h.center[0] for h in M.hexes]; ys = [h.center[1] for h in M.hexes]
+        return (float(np.mean(xs)), float(np.mean(ys)), 0.0)
+    xs=[M.hexes[i].center[0] for i in ids]
+    ys=[M.hexes[i].center[1] for i in ids]
+    zs=[0.10 + 2.0*M.hexes[i].edge for i in ids]
+    return (float(np.mean(xs)), float(np.mean(ys)), float(np.mean(zs)))
+
+def phi_ast_to_hex(nodes:Dict[int,AstNode], M:Mosaic, lam=0.35, gamma=0.7,
+                   boost:Optional[int]=None, eta=0.0)->np.ndarray:
+    # raster ciepła: węzły → najbliższe centra hex po przesunięciu w kierunku centroidu warstwy
+    # 1) centroidy warstw depth
+    by_d: Dict[int,List[int]] = {}
+    for i,n in nodes.items(): by_d.setdefault(n.depth,[]).append(i)
+    layer_centroid = {d: (float(np.mean([nodes[i].pos3d[0] for i in ids])),
+                          float(np.mean([nodes[i].pos3d[1] for i in ids])))
+                      for d,ids in by_d.items()}
+    centers = np.array([h.center for h in M.hexes])
+    heat = np.zeros(len(M.hexes), float)
+    for i,n in nodes.items():
+        cx,cy = layer_centroid[n.depth]
+        X = (1.0-lam)*n.pos3d[0] + lam*cx
+        Y = (1.0-lam)*n.pos3d[1] + lam*cy
+        j = int(np.argmin((centers[:,0]-X)**2 + (centers[:,1]-Y)**2))
+        w = 0.6*np.linalg.norm(n.meta) + 0.4*n.entropy
+        if boost is not None and boost==i: w *= (1.0+max(0.0,eta))
+        heat[j] += w
+    # normalizacja + blend z polem edge (γ)
+    if heat.max()>1e-12:
+        heat = (heat-heat.min())/(heat.max()-heat.min())
+    base = np.array([h.edge for h in M.hexes])
+    return (1.0-gamma)*base + gamma*heat
+
+def psi_hex_to_ast(nodes:Dict[int,AstNode], M:Mosaic, delta=0.2):
+    # miękki feedback: ROI vs ~ROI → poprawki meta wektorów
+    ids_roi = {i for i,h in enumerate(M.hexes) if h.roi}
+    ids_bg  = set(range(len(M.hexes))) - ids_roi
+    def feats(ids:Set[int])->np.ndarray:
+        if not ids: return np.zeros(6,float)
+        ed = np.array([M.hexes[i].edge for i in ids])
+        fL   = 1.0-ed.mean()
+        fS   = 0.5+0.5*ed.std()
+        fSel = ( ed>0.6 ).mean()
+        fSt  = 1.0-ed.std()
+        fC   = min(1.0, 0.35+0.6*ed.mean())
+        fH   = 0.45+0.5*ed.std()
+        return np.array([fL,fS,fSel,fSt,fC,fH], float)
+    m_roi, m_bg = feats(ids_roi), feats(ids_bg)
+    for n in nodes.values():
+        target = m_roi if (n.id%3==0) else m_bg
+        m = np.array(n.meta, float)
+        nodes[n.id].meta = tuple((1.0-delta)*m + delta*target)
+
+def merkle_compression(nodes:Dict[int,AstNode])->float:
+    from collections import Counter
+    cnt = Counter(n.h for n in nodes.values())
+    return len(nodes)/max(1,len(cnt))  # CR_AST
+
+def snap_ast_to_bcc(nodes:Dict[int,AstNode], L:BCC)->Tuple[Dict[int,int], float, float]:
+    centers = np.array([c.center for c in L.cells])
+    occ: Dict[int,int] = {}
+    assign: Dict[int,int] = {}
+    for i,n in nodes.items():
+        p = np.array([n.pos3d[0], n.pos3d[1], n.pos3d[2]])
+        j = int(np.argmin(np.sum((centers-p)**2, axis=1)))
+        assign[i]=j; occ[j]=occ.get(j,0)+1
+    CR_TO = len(nodes)/max(1, len(occ))
+    # Align3D – wariancja occupancy po 14-NN
+    var_local=[]
+    for j,c in enumerate(L.cells):
+        vals = [occ.get(t,0) for t in L.neighbors[j]] + [occ.get(j,0)]
+        if vals: var_local.append(np.var(vals))
+    Align3D = float(np.mean(var_local)) if var_local else 0.0
+    return assign, CR_TO, Align3D
+
+def phi_cost(M:Mosaic, ast_comp:np.ndarray)->float:
+    # kara: mocny wkład na krawędziach (ryzyko blur/denoise konfliktu) + zbieżność do pola bazowego
+    edges = np.array([h.edge for h in M.hexes])
+    ids_e = np.where(edges>0.6)[0]
+    ids_n = np.where(edges<=0.6)[0]
+    leak = float(ast_comp[ids_e].mean())              # zbyt duży wkład w pasie krawędzi
+    miss = float((1.0-ast_comp[ids_n]).mean())        # zbyt mały wkład gdzie „~edges”
+    align = float(np.mean((ast_comp-edges)**2))       # niespójność z bazą
+    return 0.4*leak + 0.3*miss + 0.3*align
+
+
+# ─────────────────────────────────────────────
+# 4) Rysowanie (3 panele)
+# ─────────────────────────────────────────────
+
+def draw_ast(ax, nodes:Dict[int,AstNode]):
+    # krawędzie
+    for n in nodes.values():
+        x0,y0,z0 = n.pos3d
+        for cid in n.children:
+            x1,y1,z1 = nodes[cid].pos3d
+            ax.plot([x0,x1],[y0,y1],[z0,z1], color="#7b8fa1", lw=1.0)
+    # metaglif
+    cmap = plt.get_cmap("plasma")
+    for n in nodes.values():
+        x,y,z = n.pos3d
+        h = 1.1 + 2.1*(n.energy/np.sqrt(6))
+        c = cmap(n.entropy)
+        ax.plot([x,x],[y,y],[z,z+h], color=c, lw=3.0)
+        ax.scatter([x],[y],[z+h], s=24, c=[c], edgecolors="black", depthshade=True)
+        if n.depth<=3: ax.text(x,y,z+h+0.35, n.kind, fontsize=8, ha="center")
+    ax.set_title("AST 3D – metaglif")
+    ax.set_xlabel("X"); ax.set_ylabel("Y"); ax.set_zlabel("Z")
+
+def draw_hex(ax, M: Mosaic, ast_comp: Optional[np.ndarray] = None):
+    # heksy pointy-top, ORIENTATION=0 rad, PROMIEŃ = HEX_R → styk BOKÓW
+    vals = np.array([h.edge for h in M.hexes])
+    vmin, vmax = float(vals.min()), float(vals.max())
+
+    def norm(v):
+        if vmax - vmin < 1e-12:
+            return 0.0
+        return (v - vmin) / (vmax - vmin)
+
+    # rysowanie heksów
+    for i, h in enumerate(M.hexes):
+        cx, cy = h.center
+        base = norm(h.edge)
+        face = (base, 0.2, 1.0 - base, 0.95)
+        ealpha = 0.28 if ast_comp is None else 0.25 + 0.65 * float(ast_comp[i])
+
+        # ⬇⬇⬇ KLUCZOWA ZMIANA: wszystkie parametry nazwane
+        poly = RegularPolygon(
+            xy=(cx, cy),
+            numVertices=6,
+            radius=HEX_R,
+            orientation=0.0,
+            facecolor=face,
+            edgecolor=(0, 0, 0, ealpha),
+            linewidth=1.0,
+            antialiased=True,
+            snap=True,
+        )
+        ax.add_patch(poly)
+
+        if h.roi:
+            ring = RegularPolygon(
+                xy=(cx, cy),
+                numVertices=6,
+                radius=HEX_R * 0.86,
+                orientation=0.0,
+                facecolor=(0, 0, 0, 0),
+                edgecolor=(1, 1, 1, 0.55),
+                linewidth=0.6,
+                antialiased=True,
+                snap=True,
+            )
+            ax.add_patch(ring)
+
+    # zakresy bez „oddechu” osi (żeby nie wprowadzać wizualnych przerw)
+    xs = np.array([h.center[0] for h in M.hexes], dtype=float)
+    ys = np.array([h.center[1] for h in M.hexes], dtype=float)
+    ax.set_xlim(xs.min() - HEX_R * 1.05, xs.max() + HEX_R * 1.05)
+    ax.set_ylim(ys.min() - HEX_R * 1.05, ys.max() + HEX_R * 1.05)
+
+    # geometrycznie „sztywno” – brak odkształceń
+    ax.set_aspect("equal", adjustable="box")
+    ax.margins(0.0)
+    ax.autoscale(enable=False)
+
+    ax.set_title("Mozaika HEX 12×12 – stykające się bokami")
+    ax.set_xlabel("x")
+    ax.set_ylabel("y")
+def draw_bcc(ax, L:BCC, assign:Optional[Dict[int,int]]=None):
+    # krawędzie 14-NN
+    for j,c in enumerate(L.cells):
+        x0,y0,z0 = c.center
+        for t in L.neighbors[j]:
+            x1,y1,z1 = L.cells[t].center
+            ax.plot([x0,x1],[y0,y1],[z0,z1], color="#9aa5b1", lw=0.45, alpha=0.7)
+    # centra; jeśli mamy przypisania węzłów AST, dociąż kolor
+    occ = {}
+    if assign:
+        for nid,cid in assign.items(): occ[cid]=occ.get(cid,0)+1
+    for j,c in enumerate(L.cells):
+        k = occ.get(j,0)
+        ax.scatter([c.center[0]],[c.center[1]],[c.center[2]],
+                   s=10+6*k, c=[(0.15,0.5,1.0,0.85)], edgecolors="black", depthshade=True)
+    ax.set_title("Lattice 3D – Voronoi BCC (14-NN)")
+    ax.set_xlabel("X"); ax.set_ylabel("Y"); ax.set_zlabel("Z")
+    ax.view_init(elev=22, azim=-48)
+
+
+# ─────────────────────────────────────────────
+# 5) MAIN (spięcie + protokół)
+# ─────────────────────────────────────────────
+
+def main():
+    # AST
+    nodes = build_ast(EXAMPLE)
+
+    # Lattice 3D
+    L = build_bcc(nx=6,ny=6,nz=4)
+    assign, CR_TO, Align3D = snap_ast_to_bcc(nodes, L)
+
+    # HEX mozaika – gwarancja styku boków (axial, pointy-top)
+    M = build_hex_mosaic(12,12)
+
+    # Φ i Ψ
+    ast_comp = phi_ast_to_hex(nodes, M, lam=0.35, gamma=0.7)
+    psi_hex_to_ast(nodes, M, delta=0.18)
+    ast_comp = phi_ast_to_hex(nodes, M, lam=0.42, gamma=0.7)
+
+    # Miary
+    CR_AST = merkle_compression(nodes)
+    J_phi  = phi_cost(M, ast_comp)
+    scores = {
+        "CR_AST": float(CR_AST),
+        "CR_TO":  float(CR_TO),
+        "Align3D": float(Align3D),
+        "J_phi": float(J_phi),
+        "J_total": float(0.5*J_phi + 0.25/CR_AST + 0.25/CR_TO)
+    }
+    print(json.dumps(scores, indent=2))
+
+    # Protokół kontekstu (gotowe do cache)
+    proto = {
+        "version": "v5-to3d-hex",
+        "ast": {"nodes":[{
+            "id":n.id,"kind":n.kind,"label":n.label,"depth":n.depth,
+            "parent":n.parent,"children":n.children,"hash":n.h,
+            "meta":list(map(float,n.meta)),"pos3d":list(map(float,n.pos3d))
+        } for n in nodes.values()]},
+        "mosaic": {
+            "hex_centers":[h.center for h in M.hexes],
+            "edge":[float(h.edge) for h in M.hexes],
+            "roi":[int(h.roi) for h in M.hexes],
+            "axial":"pointy-top", "hex_R": HEX_R,
+            "spacing":{"dx": math.sqrt(3.0)*HEX_R, "dy": 1.5*HEX_R}
+        },
+        "bcc": {
+            "cells":[{"xyz":c.xyz, "center":c.center} for c in L.cells],
+            "neighbors": L.neighbors,
+            "assign": assign
+        },
+        "phi":{"ast_component": ast_comp.tolist()},
+        "metrics": scores
+    }
+
+    # Rysunek (3 panele)
+    fig = plt.figure(figsize=(15,6))
+    ax1 = fig.add_subplot(1,3,1, projection="3d")
+    ax2 = fig.add_subplot(1,3,2)
+    ax3 = fig.add_subplot(1,3,3, projection="3d")
+
+    draw_ast(ax1, nodes)
+    draw_hex(ax2, M, ast_comp=ast_comp)
+    draw_bcc(ax3, L, assign=assign)
+
+    fig.suptitle("GlitchLab – Punkt 0 (3D): AST ⇄ HEX (stykające) ⇄ BCC/TO lattice", y=0.98)
+    plt.tight_layout(); plt.show()
+    return proto
+
+if __name__=="__main__":
+    main()
diff --git a/tests/raport.md b/tests/raport.md
new file mode 100644
index 0000000..a3483c1
--- /dev/null
+++ b/tests/raport.md
@@ -0,0 +1,117 @@
+# Hybrid AST⇄Mosaic — Test Report
+
+_generated: 2025-09-19 15:36:48Z_
+
+## Setup
+
+```json
+{
+  "rows": 12,
+  "cols": 12,
+  "kind": "hex",
+  "lam": 0.6,
+  "delta": 0.25,
+  "edge_thr": 0.55,
+  "seeds": 60,
+  "test_file": "test_hybrid_mosaic_algo.py"
+}
+```
+
+## PyTest Summary
+
+```text
+.......................................................                  [100%]
+55 passed in 629.74s (0:10:29)
+```
+
+**Parsed summary:** {"passed": 55, "failed": 0, "skipped": 0, "xpassed": 0, "xfailed": 0, "errors": 0}
+
+## Baseline
+
+```json
+{
+  "J_phi1": 135.82047953692538,
+  "J_phi2": 127.1291955643227,
+  "J_phi3": 135.82047953692538,
+  "Align": 0.5861236802413273,
+  "CR_AST": 1.0377358490566038,
+  "CR_TO": 10.999999999999995,
+  "S": 15,
+  "H": 36,
+  "Z": 2,
+  "alpha": 0.29411764705882354,
+  "beta": 0.7058823529411765
+}
+```
+
+## Sweep λ×Δ (skrócone)
+
+```
+λ    | Δ    | Align | J_phi2   | CR_AST | CR_TO  | α    | β    | S  | H  | Z
+-----+------+-------+----------+--------+--------+------+------+----+----+--
+0.00 | 0.00 | 0.715 | 127.1292 | 1.000  | 11.000 | 0.30 | 0.70 | 16 | 38 | 0
+0.00 | 0.25 | 0.715 | 127.1292 | 1.000  | 11.000 | 0.30 | 0.70 | 16 | 38 | 0
+0.00 | 0.50 | 0.715 | 127.1292 | 1.000  | 11.000 | 0.30 | 0.70 | 16 | 38 | 0
+0.25 | 0.00 | 0.637 | 127.1292 | 1.019  | 11.000 | 0.30 | 0.70 | 16 | 37 | 1
+0.25 | 0.25 | 0.637 | 127.1292 | 1.019  | 11.000 | 0.30 | 0.70 | 16 | 37 | 1
+0.25 | 0.50 | 0.637 | 127.1292 | 1.019  | 11.000 | 0.30 | 0.70 | 16 | 37 | 1
+0.50 | 0.00 | 0.586 | 127.1292 | 1.038  | 11.000 | 0.29 | 0.71 | 15 | 36 | 2
+0.50 | 0.25 | 0.586 | 127.1292 | 1.038  | 11.000 | 0.29 | 0.71 | 15 | 36 | 2
+0.50 | 0.50 | 0.586 | 127.1292 | 1.038  | 11.000 | 0.29 | 0.71 | 15 | 36 | 2
+0.75 | 0.00 | 0.603 | 127.1292 | 1.078  | 11.000 | 0.29 | 0.71 | 14 | 35 | 2
+0.75 | 0.25 | 0.603 | 127.1292 | 1.078  | 11.000 | 0.29 | 0.71 | 14 | 35 | 2
+0.75 | 0.50 | 0.603 | 127.1292 | 1.078  | 11.000 | 0.29 | 0.71 | 14 | 35 | 2
+```
+
+### Mini-wykresy (ASCII)
+
+**Align (trend):**
+
+```
+•••         
+            
+            
+   •••      
+         •••
+      •••   
+```
+
+**J_phi2 (średnia — mniejsze lepsze):**
+
+```
+████████████████████████████████  (1.000)
+```
+
+**CR_AST (średnia — większa kompresja lepsza):**
+
+```
+████████████████████████████████  (1.000)
+```
+
+## Sign test: Φ2 vs Φ1
+
+```json
+{
+  "wins": 46,
+  "losses": 14,
+  "ties": 0,
+  "mean_diff": 4.671946961557583,
+  "median_diff": 4.9296613822465645,
+  "p_sign": 2.1118522811339885e-05
+}
+```
+
+## Wnioski (skrót)
+
+- Średni Align (sweep): **0.635**; mediana **0.620**.
+
+- Średni J_phi2 (sweep): **127.129** (niżej lepiej).
+
+- Średni CR_AST (sweep): **1.034** (wyżej = większa kompresja).
+
+- Sign test (Φ2 lepsze od Φ1): **wins=46**, **losses=14**, **ties=0**, p≈**2.11e-05**.
+
+
+---
+
+_End of report._
diff --git a/tests/scratch.py b/tests/scratch.py
new file mode 100644
index 0000000..1f6573d
--- /dev/null
+++ b/tests/scratch.py
@@ -0,0 +1,45 @@
+# scratch.py — minimalny prototyp metryki mozaiki (D_M)
+
+import numpy as np
+import itertools
+import math
+
+# ---- mozaika 5x5 ----
+R, C = 5, 5
+rng = np.random.default_rng(0)
+edge = rng.random(R * C)  # edge density per tile in [0,1]
+roi = np.zeros(R * C, dtype=float)
+for r in range(1, 4):
+    for c in range(1, 4):
+        roi[r * C + c] = 1.0  # środkowy kwadrat jako ROI
+
+
+def tile_dist(i: int, j: int, alpha=1.0, beta=1.0, gamma=1.0) -> float:
+    """Pseudodystans między kaflami: geo + różnica cech + kara za różne etykiety."""
+    x1, y1 = i % C, i // C
+    x2, y2 = j % C, j // C
+    geo = math.hypot(x1 - x2, y1 - y2)
+    feat_diff = abs(float(edge[i]) - float(edge[j]))
+    label_pen = 1.0 if ((edge[i] > 0.5) != (edge[j] > 0.5)) else 0.0
+    return alpha * geo + beta * feat_diff + gamma * label_pen
+
+
+def D_M(S, S2, alpha=1.0, beta=1.0, gamma=1.0) -> float:
+    """Earth-mover-like dopasowanie dla dwóch zbiorów o tej samej liczności."""
+    if len(S) != len(S2):
+        raise ValueError("Zbiory muszą mieć tę samą liczność.")
+    best = float("inf")
+    for perm in itertools.permutations(S2):
+        cost = 0.0
+        for i, j in zip(S, perm):
+            cost += tile_dist(i, j, alpha, beta, gamma)
+        best = min(best, cost)
+    return best
+
+
+# ---- przykładowe regiony ----
+ROI = [6, 7, 8]  # 3 kafle ze środka (r=1..3, c=1..3) – uproszczony przykład
+TOP = [0, 1, 2]  # górny rząd
+
+print("D_M(ROI, ROI) =", D_M(ROI, ROI))
+print("D_M(ROI, TOP) =", D_M(ROI, TOP))
diff --git a/tests/scratch2.py b/tests/scratch2.py
new file mode 100644
index 0000000..facb92f
--- /dev/null
+++ b/tests/scratch2.py
@@ -0,0 +1,357 @@
+# scratch2.py — PROTOTYP: AST⇄Mozaika z ΔS/ΔH/ΔZ, λ-kompresją i kosztem J
+# Python 3.9+, dependencies: only numpy (standard lib: ast, math, dataclasses, itertools, json)
+
+from __future__ import annotations
+import ast, math, json, itertools
+from dataclasses import dataclass, field
+from typing import List, Dict, Tuple, Optional, Set
+import numpy as np
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 0) USTAWIENIA (możesz zmieniać)
+# ───────────────────────────────────────────────────────────────────────────────
+R, C = 6, 6  # rozmiar mozaiki (grid demo; hexy w kolejnej iteracji GUI)
+EDGE_THR = 0.55  # próg krawędzi: edges vs ~edges
+LAMBDA = 0.6  # λ: poziom kompresji AST (0=pełny detal, 1=grupy/supergraf)
+DELTA = 0.25  # Δ: siła feedbacku Ψ (Mozaika→AST; modyfikuje meta-wektory)
+W = dict(wS=1.0, wH=1.0, wZ=0.4)  # wagi dystansu α/β/Z
+
+RNG = np.random.default_rng(0)
+
+# Przykładowy kod (możesz podmienić)
+EXAMPLE_SRC = r"""
+import os, sys
+from pathlib import Path
+
+def hello(msg: str) -> str:
+    x = msg.upper()
+    print(x)
+    return x
+
+def main():
+    p = Path('.')
+    s = hello("Hi")
+    if p.exists():
+        print(s)
+    return 0
+
+if __name__ == "__main__":
+    main()
+"""
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 1) AST → ΔS/ΔH/ΔZ i meta-węzły
+# ───────────────────────────────────────────────────────────────────────────────
+
+@dataclass
+class AstNode:
+    id: int
+    label: str
+    depth: int
+    parent: Optional[int]
+    children: List[int] = field(default_factory=list)
+    meta: np.ndarray = field(default_factory=lambda: np.zeros(6, dtype=float))  # (L,S,Sel,Stab,Cau,H)
+
+
+@dataclass
+class AstSummary:
+    S: int;
+    H: int;
+    Z: int;
+    maxZ: int
+    alpha: float;
+    beta: float
+    nodes: Dict[int, AstNode];
+    labels: List[str]
+
+
+def _meta_for(label: str, depth: int, seed: int) -> np.ndarray:
+    # Heurystyki meta (stabilne deterministycznie)
+    rng = np.random.default_rng(seed & 0xFFFFFFFF)
+    L, S, Sel, Stab, Cau, H = rng.uniform(0.35, 0.85, size=6)
+    if label in ("FunctionDef", "ClassDef"): Stab = max(Stab, 0.8); Sel = max(Sel, 0.6)
+    if label in ("If", "While", "For"):      Sel = max(Sel, 0.75); Cau = max(Cau, 0.7)
+    if label in ("Call", "Expr"):            L = max(L, 0.6)
+    if label in ("Assign",):                 Stab = max(Stab, 0.7)
+    return np.array([L, S, Sel, Stab, Cau, H], dtype=float)
+
+
+def ast_deltas(src: str) -> AstSummary:
+    tree = ast.parse(src)
+    nodes: Dict[int, AstNode] = {}
+    nid = 0
+    S = H = Z = 0
+    maxZ = 0
+
+    def add(a: ast.AST, depth: int, parent: Optional[int]) -> int:
+        nonlocal nid, S, H, Z, maxZ
+        i = nid;
+        nid += 1
+        lab = a.__class__.__name__
+        node = AstNode(i, lab, depth, parent)
+        node.meta = _meta_for(lab, depth, seed=hash((lab, depth)))
+        nodes[i] = node
+        if parent is not None:
+            nodes[parent].children.append(i)
+
+        # Δ-reguły (szkic z Twojej tabeli)
+        if isinstance(a, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
+            S += 1;
+            H += 1;
+            Z += 1;
+            maxZ = max(maxZ, depth)
+        elif isinstance(a, (ast.If, ast.For, ast.While, ast.With, ast.Try)):
+            S += 1;
+            Z += 1;
+            maxZ = max(maxZ, depth)
+        elif isinstance(a, ast.Assign):
+            S += 1;
+            H += 1
+        elif isinstance(a, ast.Call):
+            S += 1;
+            H += 2  # ref do f + uses argów (przybliżenie)
+        elif isinstance(a, (ast.Import, ast.ImportFrom)):
+            S += 1;
+            H += len(a.names)
+        elif isinstance(a, ast.Name):
+            H += 1
+        else:
+            # drobnica… minimalny wkład semantyczny
+            H += 0
+
+        for ch in ast.iter_child_nodes(a):
+            add(ch, depth + 1, i)
+        if isinstance(a, (
+        ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.If, ast.For, ast.While, ast.With, ast.Try)):
+            Z -= 1  # exit scope
+        return i
+
+    add(tree, 0, None)
+    maxZ = max(maxZ, 0)
+
+    S = int(S);
+    H = int(H);
+    Z = int(max(Z, 0))
+    tot = max(1, S + H)
+    alpha = S / tot;
+    beta = H / tot
+    labels = [n.label for n in nodes.values()]
+    return AstSummary(S, H, Z, maxZ, alpha, beta, nodes, labels)
+
+
+# λ-kompresja (uogólnienie): redukujemy „detal” w S/H zgodnie z λ
+def compress_ast(summary: AstSummary, lam: float) -> AstSummary:
+    # model: S' = S - lam * S_leaf_est, H' = H - lam * H_leaf_est, Z' = round((1-lam)*Z + lam*ceil(Z/2))
+    # estymacja „liści”: przybliżenie proporcją Name/Constant/Load/Store
+    labels = summary.labels
+    leaf_ratio = max(0.0, min(1.0, labels.count("Name") / max(1, len(labels)) + labels.count("Constant") / max(1,
+                                                                                                               len(labels))))
+    S_leaf = int(summary.S * 0.35 * leaf_ratio)
+    H_leaf = int(summary.H * 0.35 * leaf_ratio)
+    S2 = max(0, summary.S - int(round(lam * S_leaf)))
+    H2 = max(0, summary.H - int(round(lam * H_leaf)))
+    Z2 = int(round((1 - lam) * summary.Z + lam * math.ceil(max(1, summary.maxZ) / 2)))
+    tot = max(1, S2 + H2)
+    return AstSummary(S2, H2, Z2, summary.maxZ, S2 / tot, H2 / tot, summary.nodes, summary.labels)
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 2) Mozaika (grid demo) + regiony + D_M
+# ───────────────────────────────────────────────────────────────────────────────
+
+@dataclass
+class Mosaic:
+    rows: int;
+    cols: int
+    edge: np.ndarray  # (N,) in [0,1]
+    ssim: np.ndarray  # (N,)
+    roi: np.ndarray  # (N,)
+
+
+def build_mosaic(rows=R, cols=C, seed=7) -> Mosaic:
+    rng = np.random.default_rng(seed)
+    yy, xx = np.mgrid[0:rows, 0:cols]
+    diag = 1.0 - np.abs(xx - yy) / max(rows, cols)
+    edge = np.clip(0.45 + 0.5 * diag + 0.06 * rng.standard_normal((rows, cols)), 0, 1).reshape(-1)
+    ssim = np.ones(rows * cols)
+    roi = np.zeros(rows * cols)
+    r0, r1 = int(0.30 * rows), int(0.62 * rows)
+    c0, c1 = int(0.30 * cols), int(0.62 * cols)
+    for r in range(r0, r1):
+        for c in range(c0, c1):
+            roi[r * cols + c] = 1.0
+    return Mosaic(rows, cols, edge, ssim, roi)
+
+
+def region_ids(M: Mosaic, kind: str, thr=EDGE_THR) -> List[int]:
+    if kind == "edges":   return [i for i, v in enumerate(M.edge) if v > thr]
+    if kind == "~edges":  return [i for i, v in enumerate(M.edge) if v <= thr]
+    if kind == "roi":     return [i for i, v in enumerate(M.roi) if v > 0.5]
+    if kind == "all":     return list(range(M.rows * M.cols))
+    return []
+
+
+def tile_dist(i: int, j: int, M: Mosaic, alpha=1.0, beta=0.7, gamma=0.5) -> float:
+    x1, y1 = i % M.cols, i // M.cols
+    x2, y2 = j % M.cols, j // M.cols
+    geo = math.hypot(x1 - x2, y1 - y2)
+    feat = abs(float(M.edge[i]) - float(M.edge[j]))
+    label_pen = 1.0 if ((M.edge[i] > EDGE_THR) != (M.edge[j] > EDGE_THR)) else 0.0
+    return alpha * geo + beta * feat + gamma * label_pen
+
+
+def D_M(S: List[int], T: List[int], M: Mosaic) -> float:
+    if not S or not T: return 0.0
+    if len(S) != len(T):
+        # dopasuj rozmiary przez próbkowanie z powtórzeniami najbliższych
+        k = min(len(S), len(T))
+        S = S[:k];
+        T = T[:k]
+    best = float("inf")
+    for perm in itertools.permutations(T):
+        cost = 0.0
+        for i, j in zip(S, perm):
+            cost += tile_dist(i, j, M)
+        best = min(best, cost)
+        if best == 0.0: break
+    return best
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 3) Sprzężenia Φ/Ψ
+# ───────────────────────────────────────────────────────────────────────────────
+
+# Reguły Φ: przypisanie typów węzłów do regionów (heurystyka)
+def phi_region_for(label: str) -> str:
+    if label in ("Call", "Expr"):            return "edges"
+    if label in ("Assign",):                 return "~edges"
+    if label in ("If", "For", "While", "With", "Return"): return "all"
+    if label in ("FunctionDef", "ClassDef"):  return "roi"
+    return "~edges"
+
+
+def centroid(ids: List[int], M: Mosaic) -> Tuple[float, float]:
+    if not ids:
+        return (M.cols * 0.5, M.rows * 0.5)
+    xs = np.array([i % M.cols for i in ids], dtype=float)
+    ys = np.array([i // M.cols for i in ids], dtype=float)
+    return float(xs.mean()), float(ys.mean())
+
+
+def phi_cost(ast: AstSummary, M: Mosaic) -> Tuple[float, Dict[int, Dict]]:
+    # dla każdego węzła oblicz punkt 0 i koszt dopasowania do „własnego” regionu
+    details: Dict[int, Dict] = {}
+    total = 0.0
+    for n in ast.nodes.values():
+        kind = phi_region_for(n.label)
+        ids = region_ids(M, kind)
+        if not ids:
+            details[n.id] = dict(kind=kind, cost=0.0, centroid=(None, None));
+            continue
+        # dopasowanie: porównaj centroid bieżącego regionu z centroidem „sąsiedniego” (kontrola separacji)
+        cx, cy = centroid(ids, M)
+        # budujemy „kontr-region” jako komplement o tej samej wielkości (używamy prostego doboru)
+        alt = region_ids(M, "edges" if kind == "~edges" else "~edges")
+        alt = alt[:len(ids)] if len(alt) >= len(ids) else alt + ids[:len(ids) - len(alt)]
+        # koszt Φ jako earth-mover-like między regionem a alternatywą (im dalej, tym lepiej rozdzielone klasy)
+        cost = max(0.0, D_M(ids, alt, M))
+        details[n.id] = dict(kind=kind, cost=cost, centroid=(cx, cy))
+        total += cost
+    # normalizacja przez liczbę węzłów
+    N = max(1, len(ast.nodes))
+    return total / float(N), details
+
+
+# Ψ: feedback – podbij meta zależnie od regionu (np. gdy region „edges”, rośnie selektywność i kauzalność)
+def psi_feedback(ast: AstSummary, M: Mosaic, delta: float) -> AstSummary:
+    if delta <= 1e-9: return ast
+    nodes = ast.nodes
+    for n in nodes.values():
+        kind = phi_region_for(n.label)
+        ids = region_ids(M, kind)
+        if not ids: continue
+        ed = np.array([M.edge[i] for i in ids], dtype=float)
+        # prosty ψ(region): [L,S,Sel,Stab,Cau,H]
+        psi = np.array([
+            float(1.0 - ed.mean()),  # L: mniej krawędzi → większa lokalność
+            float(0.5 + 0.5 * ed.std()),  # S: wariancja → „skala”/złożoność
+            float(min(1.0, 0.5 + ed.mean())),  # Sel: więcej edge → większa selektywność
+            float(1.0 - ed.std()),  # Stab: niski rozrzut → większa stabilność
+            float(min(1.0, 0.3 + 0.7 * ed.mean())),  # Cau: krawędzie dają efekt
+            float(0.4 + 0.5 * ed.std())  # H: entropia ~ rozrzut
+        ], dtype=float)
+        n.meta = (1.0 - delta) * n.meta + delta * psi
+    # ΔS/ΔH/ΔZ nie zmieniamy tu (to miękkie meta), ale możemy przeliczyć α/β dla wizualnych decyzji
+    S, H, Z = ast.S, ast.H, ast.Z
+    tot = max(1, S + H)
+    return AstSummary(S, H, Z, ast.maxZ, S / tot, H / tot, nodes, ast.labels)
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 4) Dystanse i koszty zbieżności
+# ───────────────────────────────────────────────────────────────────────────────
+
+def mosaic_profile(M: Mosaic) -> Tuple[int, int, int, float, float]:
+    # syntetyczny profil mozaiki w (S,H,Z): S~liczba spójnych bloków (tu: rząd/kolumna), H~udział edges, Z~1
+    # to tylko „profil analityczny” na potrzeby wspólnej metryki α/β/Z
+    S = R + C
+    H = int(np.sum(M.edge > EDGE_THR))
+    Z = 1
+    tot = max(1, S + H)
+    return S, H, Z, S / tot, H / tot
+
+
+def distance_ast_mosaic(ast: AstSummary, M: Mosaic, w=W) -> float:
+    _, _, _, alphaM, betaM = mosaic_profile(M)
+    return (w['wS'] * abs(ast.alpha - alphaM) +
+            w['wH'] * abs(ast.beta - betaM) +
+            w['wZ'] * abs(ast.Z / max(1, ast.maxZ) - 0.0))  # Z: docelowo różne bucket’y; tu prosty target=0
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 5) GŁÓWNY PRZEBIEG
+# ───────────────────────────────────────────────────────────────────────────────
+
+def main():
+    # AST → Δ
+    ast_raw = ast_deltas(EXAMPLE_SRC)
+    ast_l = compress_ast(ast_raw, LAMBDA)
+
+    # Mozaika
+    M = build_mosaic(R, C, seed=7)
+
+    # Φ: koszt i szczegóły
+    J_phi, phi_details = phi_cost(ast_l, M)
+
+    # Ψ: feedback (miękki update meta)
+    ast_after = psi_feedback(ast_l, M, DELTA)
+
+    # Align / Całkowity koszt
+    Align3D = 1.0 - min(1.0, distance_ast_mosaic(ast_after, M))  # im większy, tym lepiej
+    J_total = 0.5 * J_phi + 0.5 * (1.0 - Align3D)
+
+    # „kompresja” (wskaźnik informacyjny)
+    CR_AST = (ast_raw.S + ast_raw.H + max(1, ast_raw.Z)) / max(1, ast_l.S + ast_l.H + max(1, ast_l.Z))
+    # topologia mozaiki (im większa dominanta klasy edges vs ~edges, tym większy CR_TO)
+    p_edge = float(np.mean(M.edge > EDGE_THR))
+    CR_TO = (1.0 / max(1e-6, min(p_edge, 1 - p_edge))) - 1.0  # rośnie gdy klasa dominuje
+
+    out = {
+        "AST_raw": dict(S=ast_raw.S, H=ast_raw.H, Z=ast_raw.Z, alpha=ast_raw.alpha, beta=ast_raw.beta),
+        "AST_lambda": dict(S=ast_l.S, H=ast_l.H, Z=ast_l.Z, alpha=ast_l.alpha, beta=ast_l.beta),
+        "CR_AST": CR_AST,
+        "CR_TO": CR_TO,
+        "Align3D": Align3D,
+        "J_phi": J_phi,
+        "J_total": J_total,
+        "sample_phi": {k: {"kind": v["kind"], "cost": round(v["cost"], 3),
+                           "centroid": tuple(round(c, 2) if c is not None else None for c in v["centroid"])}
+                       for k, v in list(phi_details.items())[:8]},
+    }
+
+    print(json.dumps(out, indent=2))
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/scratch3.py b/tests/scratch3.py
new file mode 100644
index 0000000..f778dbb
--- /dev/null
+++ b/tests/scratch3.py
@@ -0,0 +1,431 @@
+# scratch3.py — DOWODOWY PROTOTYP: AST ⇄ Mozaika z ΔS/ΔH/ΔZ, λ/Δ-sweep,
+#                wieloma wariantami Φ i testami własności metrycznych/inwariantów
+# Python 3.9+, deps: numpy
+
+from __future__ import annotations
+import ast, math, json, itertools, statistics as stats
+from dataclasses import dataclass, field
+from typing import List, Dict, Tuple, Optional
+import numpy as np
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 0) PARAMS
+# ───────────────────────────────────────────────────────────────────────────────
+R, C = 6, 6
+EDGE_THR = 0.55
+W = dict(wS=1.0, wH=1.0, wZ=0.4)  # wagi dystansu dla Align
+RNG = np.random.default_rng(0)
+
+EXAMPLE_SRC = r"""
+import os, sys
+from pathlib import Path
+
+def hello(msg: str) -> str:
+    x = msg.upper()
+    print(x)
+    return x
+
+def main():
+    p = Path('.')
+    s = hello("Hi")
+    if p.exists():
+        print(s)
+    return 0
+
+if __name__ == "__main__":
+    main()
+"""
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 1) AST → ΔS/ΔH/ΔZ
+# ───────────────────────────────────────────────────────────────────────────────
+@dataclass
+class AstNode:
+    id: int
+    label: str
+    depth: int
+    parent: Optional[int]
+    children: List[int] = field(default_factory=list)
+    meta: np.ndarray = field(default_factory=lambda: np.zeros(6, dtype=float))  # L,S,Sel,Stab,Cau,H
+
+
+@dataclass
+class AstSummary:
+    S: int;
+    H: int;
+    Z: int;
+    maxZ: int
+    alpha: float;
+    beta: float
+    nodes: Dict[int, AstNode]
+    labels: List[str]
+
+
+def _meta_for(label: str, depth: int, seed: int) -> np.ndarray:
+    rng = np.random.default_rng(seed & 0xFFFFFFFF)
+    L, S, Sel, Stab, Cau, H = rng.uniform(0.35, 0.85, size=6)
+    if label in ("FunctionDef", "ClassDef"): Stab = max(Stab, 0.8); Sel = max(Sel, 0.6)
+    if label in ("If", "While", "For"):       Sel = max(Sel, 0.75); Cau = max(Cau, 0.7)
+    if label in ("Call", "Expr"):            L = max(L, 0.6)
+    if label in ("Assign",):                Stab = max(Stab, 0.7)
+    return np.array([L, S, Sel, Stab, Cau, H], dtype=float)
+
+
+def ast_deltas(src: str) -> AstSummary:
+    tree = ast.parse(src)
+    nodes: Dict[int, AstNode] = {}
+    S = H = Z = 0;
+    maxZ = 0;
+    nid = 0
+
+    def add(a: ast.AST, depth: int, parent: Optional[int]) -> int:
+        nonlocal nid, S, H, Z, maxZ
+        i = nid;
+        nid += 1
+        lab = a.__class__.__name__
+        n = AstNode(i, lab, depth, parent)
+        n.meta = _meta_for(lab, depth, seed=hash((lab, depth)))
+        nodes[i] = n
+        if parent is not None: nodes[parent].children.append(i)
+
+        # Δ-reguły (skrócone)
+        if isinstance(a, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
+            S += 1; H += 1; Z += 1; maxZ = max(maxZ, depth)
+        elif isinstance(a, (ast.If, ast.For, ast.While, ast.With, ast.Try)):
+            S += 1; Z += 1;   maxZ = max(maxZ, depth)
+        elif isinstance(a, ast.Assign):
+            S += 1; H += 1
+        elif isinstance(a, ast.Call):
+            S += 1; H += 2
+        elif isinstance(a, (ast.Import, ast.ImportFrom)):
+            S += 1; H += len(a.names)
+        elif isinstance(a, ast.Name):
+            H += 1
+
+        for ch in ast.iter_child_nodes(a): add(ch, depth + 1, i)
+        if isinstance(a, (
+        ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.If, ast.For, ast.While, ast.With, ast.Try)):
+            Z -= 1
+        return i
+
+    add(tree, 0, None)
+    S = int(S);
+    H = int(H);
+    Z = int(max(Z, 0))
+    tot = max(1, S + H)
+    alpha = S / tot;
+    beta = H / tot
+    return AstSummary(S, H, Z, maxZ, alpha, beta, nodes, [n.label for n in nodes.values()])
+
+
+def compress_ast(summary: AstSummary, lam: float) -> AstSummary:
+    labels = summary.labels
+    leaf_ratio = (labels.count("Name") + labels.count("Constant")) / max(1, len(labels))
+    S_leaf = int(summary.S * 0.35 * leaf_ratio)
+    H_leaf = int(summary.H * 0.35 * leaf_ratio)
+    S2 = max(0, summary.S - int(round(lam * S_leaf)))
+    H2 = max(0, summary.H - int(round(lam * H_leaf)))
+    Z2 = int(round((1 - lam) * summary.Z + lam * math.ceil(max(1, summary.maxZ) / 2)))
+    tot = max(1, S2 + H2)
+    return AstSummary(S2, H2, Z2, summary.maxZ, S2 / tot, H2 / tot, summary.nodes, summary.labels)
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 2) Mozaika i metryka D_M
+# ───────────────────────────────────────────────────────────────────────────────
+@dataclass
+class Mosaic:
+    rows: int;
+    cols: int
+    edge: np.ndarray
+    ssim: np.ndarray
+    roi: np.ndarray
+
+
+def build_mosaic(rows=R, cols=C, seed=7) -> Mosaic:
+    rng = np.random.default_rng(seed)
+    yy, xx = np.mgrid[0:rows, 0:cols]
+    diag = 1.0 - np.abs(xx - yy) / max(rows, cols)
+    edge = np.clip(0.45 + 0.5 * diag + 0.06 * rng.standard_normal((rows, cols)), 0, 1).reshape(-1)
+    ssim = np.ones(rows * cols)
+    roi = np.zeros(rows * cols)
+    r0, r1 = int(0.30 * rows), int(0.62 * rows);
+    c0, c1 = int(0.30 * cols), int(0.62 * cols)
+    for r in range(r0, r1):
+        for c in range(c0, c1):
+            roi[r * cols + c] = 1.0
+    return Mosaic(rows, cols, edge, ssim, roi)
+
+
+def region_ids(M: Mosaic, kind: str, thr=EDGE_THR) -> List[int]:
+    if kind == "edges":  return [i for i, v in enumerate(M.edge) if v > thr]
+    if kind == "~edges": return [i for i, v in enumerate(M.edge) if v <= thr]
+    if kind == "roi":    return [i for i, v in enumerate(M.roi) if v > 0.5]
+    if kind == "all":    return list(range(M.rows * M.cols))
+    return []
+
+
+def tile_dist(i: int, j: int, M: Mosaic, alpha=1.0, beta=0.7, gamma=0.5) -> float:
+    x1, y1 = i % M.cols, i // M.cols;
+    x2, y2 = j % M.cols, j // M.cols
+    geo = math.hypot(x1 - x2, y1 - y2)
+    feat = abs(float(M.edge[i]) - float(M.edge[j]))
+    label_pen = 1.0 if ((M.edge[i] > EDGE_THR) != (M.edge[j] > EDGE_THR)) else 0.0
+    return alpha * geo + beta * feat + gamma * label_pen
+
+
+def D_M(S: List[int], T: List[int], M: Mosaic, max_match: int = 8) -> float:
+    if not S and not T: return 0.0
+    if not S or not T:  return float('inf')  # brak porównania
+    k = min(len(S), len(T), max_match)  # bezpiecznik na permutacje
+    S2, T2 = S[:k], T[:k]
+    best = float('inf')
+    for perm in itertools.permutations(T2):
+        cost = 0.0
+        for i, j in zip(S2, perm): cost += tile_dist(i, j, M)
+        if cost < best: best = cost
+        if best == 0.0: break
+    return best
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 3) Φ/Ψ — TRZY METODY Φ do porównania + Ψ feedback
+# ───────────────────────────────────────────────────────────────────────────────
+def phi_region_for(label: str) -> str:
+    if label in ("Call", "Expr"):            return "edges"
+    if label in ("Assign",):                return "~edges"
+    if label in ("If", "For", "While", "With", "Return"): return "all"
+    if label in ("FunctionDef", "ClassDef"): return "roi"
+    return "~edges"
+
+
+def phi_region_for_balanced(label: str, M: Mosaic) -> str:
+    # wariant Φ2: balansuje klasy wg proporcji globalnych
+    p_edge = float(np.mean(M.edge > EDGE_THR))
+    if label in ("Call", "Expr"):            return "edges" if p_edge <= 0.65 else "~edges"
+    if label in ("Assign",):                return "~edges" if p_edge >= 0.35 else "edges"
+    if label in ("FunctionDef", "ClassDef"): return "roi"
+    return "all"
+
+
+def phi_region_for_entropy(label: str, M: Mosaic) -> str:
+    # wariant Φ3: gdy granica nieostra (blisko progu), daj "all"
+    def near_thr(x): return abs(x - EDGE_THR) <= 0.05
+
+    fuzzy = float(np.mean([near_thr(v) for v in M.edge])) > 0.25
+    if fuzzy: return "all"
+    return phi_region_for(label)
+
+
+def centroid(ids: List[int], M: Mosaic) -> Tuple[float, float]:
+    if not ids: return (M.cols * 0.5, M.rows * 0.5)
+    xs = np.array([i % M.cols for i in ids], float);
+    ys = np.array([i // M.cols for i in ids], float)
+    return float(xs.mean()), float(ys.mean())
+
+
+def phi_cost(ast: AstSummary, M: Mosaic, selector) -> Tuple[float, Dict[int, Dict]]:
+    details = {};
+    total = 0.0
+    for n in ast.nodes.values():
+        kind = selector(n.label, M) if selector.__code__.co_argcount == 2 else selector(n.label)
+        ids = region_ids(M, kind)
+        if not ids:
+            details[n.id] = dict(kind=kind, cost=0.0, centroid=(None, None));
+            continue
+        alt = region_ids(M, "edges" if kind == "~edges" else "~edges")
+        if not alt: alt = ids[:]  # unik
+        alt = alt[:len(ids)] if len(alt) >= len(ids) else (alt + ids[:len(ids) - len(alt)])
+        cost = max(0.0, D_M(ids, alt, M))
+        details[n.id] = dict(kind=kind, cost=cost, centroid=centroid(ids, M))
+        total += cost
+    N = max(1, len(ast.nodes))
+    return total / float(N), details
+
+
+def psi_feedback(ast: AstSummary, M: Mosaic, delta: float) -> AstSummary:
+    if delta <= 1e-9: return ast
+    nodes = ast.nodes
+    for n in nodes.values():
+        kind = phi_region_for(n.label)
+        ids = region_ids(M, kind)
+        if not ids: continue
+        ed = np.array([M.edge[i] for i in ids], float)
+        psi = np.array([
+            float(1.0 - ed.mean()),
+            float(0.5 + 0.5 * ed.std()),
+            float(min(1.0, 0.5 + ed.mean())),
+            float(1.0 - ed.std()),
+            float(min(1.0, 0.3 + 0.7 * ed.mean())),
+            float(0.4 + 0.5 * ed.std())
+        ])
+        n.meta = (1.0 - delta) * n.meta + delta * psi
+    S, H, Z = ast.S, ast.H, ast.Z
+    tot = max(1, S + H)
+    return AstSummary(S, H, Z, ast.maxZ, S / tot, H / tot, nodes, ast.labels)
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 4) Align/Costs + testy „dowodowe”
+# ───────────────────────────────────────────────────────────────────────────────
+def mosaic_profile(M: Mosaic) -> Tuple[int, int, int, float, float]:
+    S = R + C
+    H = int(np.sum(M.edge > EDGE_THR))
+    Z = 1
+    tot = max(1, S + H)
+    return S, H, Z, S / tot, H / tot
+
+
+def distance_ast_mosaic(ast: AstSummary, M: Mosaic, w=W) -> float:
+    _, _, _, aM, bM = mosaic_profile(M)
+    return (w['wS'] * abs(ast.alpha - aM) +
+            w['wH'] * abs(ast.beta - bM) +
+            w['wZ'] * abs(ast.Z / max(1, ast.maxZ) - 0.0))
+
+
+def invariants_check(astA: AstSummary, astB: AstSummary, M: Mosaic) -> Dict[str, bool]:
+    # I1: α+β≈1 dla obu stanów
+    I1A = abs(astA.alpha + astA.beta - 1.0) < 1e-9
+    I1B = abs(astB.alpha + astB.beta - 1.0) < 1e-9
+    # I2: metryka D_M: nieujemna, symetryczna, identyczność rozróżnialnych
+    roi = region_ids(M, "roi");
+    top = region_ids(M, "all")
+    I2a = D_M(roi, roi, M) == 0.0
+    I2b = D_M(roi, top[:len(roi)], M) >= 0.0
+    I2c = abs(D_M(roi, top[:len(roi)], M) - D_M(top[:len(roi)], roi, M)) < 1e-9
+    # I3: kompresja nie zwiększa sumy (S+H+Z)
+    sumA = astA.S + astA.H + max(1, astA.Z)
+    sumB = astB.S + astB.H + max(1, astB.Z)
+    I3 = sumB <= sumA
+    return {
+        "I1_alpha_plus_beta_eq_1": (I1A and I1B),
+        "I2_metric_nonneg_sym_identity": (I2a and I2b and I2c),
+        "I3_compression_monotone": I3
+    }
+
+
+def nice_row(cols, widths):
+    return " | ".join(str(c).ljust(w) for c, w in zip(cols, widths))
+
+
+# ───────────────────────────────────────────────────────────────────────────────
+# 5) MAIN: porównania metod, sweep, testy
+# ───────────────────────────────────────────────────────────────────────────────
+def run_once(lam: float, delta: float) -> Dict[str, float]:
+    ast_raw = ast_deltas(EXAMPLE_SRC)
+    ast_l = compress_ast(ast_raw, lam)
+    M = build_mosaic(R, C, seed=7)
+    # trzy warianty Φ
+    J1, _ = phi_cost(ast_l, M, selector=phi_region_for)
+    J2, _ = phi_cost(ast_l, M, selector=phi_region_for_balanced)
+    J3, _ = phi_cost(ast_l, M, selector=phi_region_for_entropy)
+    ast_after = psi_feedback(ast_l, M, delta)
+    Align = 1.0 - min(1.0, distance_ast_mosaic(ast_after, M))
+    p_edge = float(np.mean(M.edge > EDGE_THR))
+    CR_AST = (ast_raw.S + ast_raw.H + max(1, ast_raw.Z)) / max(1, ast_l.S + ast_l.H + max(1, ast_l.Z))
+    CR_TO = (1.0 / max(1e-6, min(p_edge, 1 - p_edge))) - 1.0
+    return dict(J_phi1=J1, J_phi2=J2, J_phi3=J3, Align=Align, CR_AST=CR_AST, CR_TO=CR_TO,
+                S=ast_l.S, H=ast_l.H, Z=ast_l.Z, alpha=ast_l.alpha, beta=ast_l.beta)
+
+
+def main():
+    print("\n=== PROTOKÓŁ DOWODOWY: AST ⇄ Mozaika (Φ/Ψ, ΔS/ΔH/ΔZ, λ/Δ-sweep) ===\n")
+
+    # 1) Jedno przebiegnięcie referencyjne
+    lam0, del0 = 0.60, 0.25
+    res0 = run_once(lam0, del0)
+    print("[BASELINE] λ=%.2f, Δ=%.2f" % (lam0, del0))
+    print(json.dumps(res0, indent=2))
+
+    # 2) Testy metryczne/inwarianty
+    astA = ast_deltas(EXAMPLE_SRC)
+    astB = compress_ast(astA, lam0)
+    M = build_mosaic(R, C, seed=7)
+    inv = invariants_check(astA, astB, M)
+    print("\n[TESTY INWARIANTÓW / METRYK]")
+    for k, v in inv.items():
+        print(f"  - {k}: {'PASS' if v else 'FAIL'}")
+
+    # 3) Porównanie metod Φ (mniejsze J_phi lepsze)
+    print("\n[PORÓWNANIE METOD Φ] (Φ1=heur, Φ2=balanced, Φ3=entropy-fuzzy)")
+    J1, _ = phi_cost(compress_ast(astA, lam0), M, selector=phi_region_for)
+    J2, _ = phi_cost(compress_ast(astA, lam0), M, selector=phi_region_for_balanced)
+    J3, _ = phi_cost(compress_ast(astA, lam0), M, selector=phi_region_for_entropy)
+    print(f"  Φ1 (heur):   J_phi = {J1:.6f}")
+    print(f"  Φ2 (bal):    J_phi = {J2:.6f}  (improvement vs Φ1: {((J1 - J2) / max(1e-9, J1)) * 100:.2f}%)")
+    print(f"  Φ3 (fuzzy):  J_phi = {J3:.6f}  (degradation vs Φ1: {((J3 - J1) / max(1e-9, J1)) * 100:.2f}%)")
+
+    # 4) Sweep po λ i Δ
+    lams = [0.0, 0.25, 0.5, 0.75]
+    dels = [0.0, 0.25, 0.5]
+    print("\n[SWEEP λ × Δ]  (Align↑ lepiej, J_phi↓ lepiej, CR_AST↑ = większa kompresja)")
+    header = ["λ", "Δ", "Align", "J_phi1", "J_phi2", "J_phi3", "CR_AST", "CR_TO", "α", "β", "S", "H", "Z"]
+    widths = [4, 4, 7, 8, 8, 8, 8, 8, 5, 5, 4, 4, 3]
+    print(nice_row(header, widths))
+    print("-" * sum(widths) + "-" * (len(widths) - 1))
+    for lam in lams:
+        for de in dels:
+            r = run_once(lam, de)
+            row = [f"{lam:.2f}", f"{de:.2f}", f"{r['Align']:.3f}",
+                   f"{r['J_phi1']:.4f}", f"{r['J_phi2']:.4f}", f"{r['J_phi3']:.4f}",
+                   f"{r['CR_AST']:.3f}", f"{r['CR_TO']:.3f}",
+                   f"{r['alpha']:.2f}", f"{r['beta']:.2f}",
+                   r['S'], r['H'], r['Z']]
+            print(nice_row(row, widths))
+
+    # 5) Test operacyjny (100 seedów): czy Φ2 poprawia J_phi vs Φ1?
+    print("\n[TEST OPERACYJNY] 100 losowych seedów mozaiki — czy Φ2 (balanced) poprawia J_phi vs Φ1?")
+    diffs = []
+    wins = 0
+    losses = 0
+    zeros = 0
+    for seed in range(100):
+        Mx = build_mosaic(R, C, seed=seed)
+        aL = compress_ast(astA, lam0)
+        J1, _ = phi_cost(aL, Mx, selector=phi_region_for)
+        J2, _ = phi_cost(aL, Mx, selector=phi_region_for_balanced)
+        d = J1 - J2
+        diffs.append(d)
+        if d > 0:
+            wins += 1
+        elif d < 0:
+            losses += 1
+        else:
+            zeros += 1
+        if (seed + 1) % 10 == 0:
+            print(f"  progress: {seed + 1}/100  | running wins={wins}, losses={losses}, ties={zeros}", flush=True)
+
+    mean_diff = float(np.mean(diffs))
+    med_diff = float(np.median(diffs))
+
+    # prosta p-wartość testu znaku (binomial, p=0.5)
+    from math import comb
+    # używamy tylko rozstrzygnięć (bez remisów) – klasyczny test znaku
+    n_eff = wins + losses
+    if n_eff == 0:
+        p_sign = 1.0
+    else:
+        k = max(wins, losses)  # "co najmniej tyle zwycięstw" dla strony dominującej
+        p_sign = sum(comb(n_eff, t) for t in range(k, n_eff + 1)) / (2 ** n_eff)
+
+    print(f"  mean(J1-J2) = {mean_diff:.6f}  | median = {med_diff:.6f}")
+    print(f"  wins Φ2: {wins}/{n_eff} (ties={zeros}) | sign-test p≈{p_sign:.3g}")
+    # prosta p-wartość znaku (binomial, p=0.5)
+    from math import comb
+    p = sum(comb(100, k) for k in range(pos, 101)) / (2 ** 100)
+    print(f"  sign-test p≈{p:.3g}  (mniejsze → istotne na korzyść Φ2)")
+
+    # 6) Podsumowanie (JSON pod CI)
+    print("\n[SUMMARY JSON]")
+    print(json.dumps(dict(
+        baseline=dict(lam=lam0, delta=del0, **res0),
+        invariants=inv,
+        sweep=dict(lams=lams, deltas=dels),
+        hypothesis=dict(mean_improvement=mean_diff, median_improvement=med_diff,
+                        wins=pos, losses=neg, sign_test_p=p)
+    ), indent=2))
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/test1.py b/tests/test1.py
new file mode 100644
index 0000000..01b6450
--- /dev/null
+++ b/tests/test1.py
@@ -0,0 +1,461 @@
+# make_glitchlab_scenarios.py
+# tworzy glitchlab_scenarios.zip z gotowymi scenariuszami (40 funkcji + impl parse_kv_pairs)
+
+import os, json, time, zipfile
+
+BASE = os.path.abspath(".")
+OUTDIR = os.path.join(BASE, "glitchlab_scenarios")
+os.makedirs(OUTDIR, exist_ok=True)
+
+README = """# GlitchLab – gotowe scenariusze (A)
+Zawartość:
+- `templates.py` – kompletny słownik `_TEMPLATES` (40 funkcji) do wklejenia tam, gdzie masz `generate_code(...)`.
+- `parse_kv_pairs_impl.py` – implementacja `_impl_parse_kv_pairs()` (spójna z Twoją propozycją).
+- `HOWTO.md` – krótka instrukcja podmiany.
+- `version.json` – metadane paczki.
+
+## Szybki start
+1) Otwórz moduł z `generate_code(...)`.
+2) Podmień cały `_TEMPLATES = {...}` zawartością z `templates.py`.
+3) (Opcj.) jeśli masz helper `_impl_parse_kv_pairs()`, podmień go wersją z `parse_kv_pairs_impl.py`.
+4) Odpal benchmark:
+   python -m glitchlab.gui.bench.ab_pilot --tasks "tasks/*.json" --json
+"""
+
+HOWTO = """# HOWTO
+- **Cel**: wyeliminować `NotImplementedError` w trybie A (A1/A2) i umożliwić realne testy Align/J_phi/czas.
+- **Wklej**: zawartość `_TEMPLATES` do modułu z `generate_code(...)`.
+- **Zgodność**: implementacje są deterministyczne i proste (pasują do podanych zadań).
+"""
+
+TEMPLATES = r'''_TEMPLATES = {
+    "reverse_str": """\
+def reverse_str(s: str) -> str:
+    return s[::-1]
+""",
+    "fib": """\
+def fib(n: int) -> int:
+    a, b = 0, 1
+    for _ in range(int(n)):
+        a, b = b, a + b
+    return a
+""",
+    "sum_csv_numbers": """\
+def sum_csv_numbers(csv_text: str) -> int:
+    parts = [p.strip() for p in (csv_text or "").split(",") if p.strip()]
+    return sum(int(p) for p in parts)
+""",
+    "moving_sum": """\
+def moving_sum(x: list, k: int = None) -> list:
+    if k is None:
+        out = []
+        s = 0
+        for v in x:
+            s += v
+            out.append(s)
+        return out
+    if k <= 0 or len(x) < k:
+        return []
+    out = []
+    s = sum(x[:k])
+    out.append(s)
+    for i in range(k, len(x)):
+        s += x[i] - x[i - k]
+        out.append(s)
+    return out
+""",
+    "is_palindrome": """\
+import re
+def is_palindrome(s: str) -> bool:
+    t = re.sub(r"[^A-Za-z0-9]", "", (s or "")).lower()
+    return t == t[::-1]
+""",
+    "count_vowels": """\
+def count_vowels(s: str) -> int:
+    if not s:
+        return 0
+    V = set("aeiouAEIOU")
+    return sum(1 for ch in s if ch in V)
+""",
+    "factorial": """\
+def factorial(n: int) -> int:
+    n = int(n)
+    if n < 0:
+        raise ValueError("n<0")
+    res = 1
+    for i in range(2, n+1):
+        res *= i
+    return res
+""",
+    "unique_sorted": """\
+def unique_sorted(xs: list) -> list:
+    return sorted(set(xs))
+""",
+    "flatten_once": """\
+def flatten_once(xs: list) -> list:
+    out = []
+    for v in xs:
+        if isinstance(v, (list, tuple)):
+            out.extend(v)
+        else:
+            out.append(v)
+    return out
+""",
+    "dot_product": """\
+def dot_product(a: list, b: list) -> int:
+    return sum(x*y for x, y in zip(a, b))
+""",
+    "anagrams": """\
+def anagrams(a: str, b: str) -> bool:
+    if a is None or b is None:
+        return False
+    return sorted(a.replace(" ", "").lower()) == sorted(b.replace(" ", "").lower())
+""",
+    "gcd": """\
+import math
+def gcd(a: int, b: int) -> int:
+    return math.gcd(int(a), int(b))
+""",
+    "lcm": """\
+import math
+def lcm(a: int, b: int) -> int:
+    a, b = int(a), int(b)
+    return 0 if a == 0 or b == 0 else abs(a*b)//math.gcd(a,b)
+""",
+    "two_sum": """\
+def two_sum(nums: list, target: int):
+    seen = {}
+    for i, v in enumerate(nums):
+        j = seen.get(target - v)
+        if j is not None:
+            return (j, i)
+        seen[v] = i
+    return None
+""",
+    "transpose": """\
+def transpose(mat: list) -> list:
+    if not mat:
+        return []
+    return [list(row) for row in zip(*mat)]
+""",
+    "matmul": """\
+def matmul(A: list, B: list) -> list:
+    if not A or not B:
+        return []
+    n, m, p = len(A), len(A[0]), len(B[0])
+    res = [[0]*p for _ in range(n)]
+    for i in range(n):
+        for k in range(m):
+            aik = A[i][k]
+            if aik == 0:
+                continue
+            for j in range(p):
+                res[i][j] += aik * B[k][j]
+    return res
+""",
+    "to_snake_case": """\
+import re
+def to_snake_case(s):
+    if isinstance(s, (list, tuple)):
+        s = " ".join(str(t) for t in s)
+    s = s or ""
+    s = re.sub(r"([a-z0-9])([A-Z])", r"\\1_\\2", s)
+    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\\1_\\2", s)
+    s = re.sub(r"[^A-Za-z0-9]+", "_", s)
+    s = s.strip("_").lower()
+    s = re.sub(r"_+", "_", s)
+    return s
+""",
+    "to_camel_case": """\
+import re
+def to_camel_case(x):
+    if isinstance(x, (list, tuple)):
+        tokens = [str(t) for t in x]
+    else:
+        x = x or ""
+        tokens = re.split(r"[^A-Za-z0-9]+|_", x)
+    tokens = [t for t in tokens if t]
+    if not tokens:
+        return ""
+    head = tokens[0].lower()
+    tail = [t[:1].upper() + t[1:].lower() for t in tokens[1:]]
+    return head + "".join(tail)
+""",
+    "rle_compress": """\
+def rle_compress(s: str) -> str:
+    if not s:
+        return ""
+    out = []
+    prev = s[0]
+    cnt = 1
+    for ch in s[1:]:
+        if ch == prev:
+            cnt += 1
+        else:
+            out.append(f"{prev}{cnt}")
+            prev, cnt = ch, 1
+    out.append(f"{prev}{cnt}")
+    return "".join(out)
+""",
+    "rle_decompress": """\
+import re
+def rle_decompress(s: str) -> str:
+    if not s:
+        return ""
+    out = []
+    for m in re.finditer(r"(.)((?:\\d)+)", s):
+        ch = m.group(1)
+        n = int(m.group(2))
+        out.append(ch * n)
+    return "".join(out)
+""",
+    "rotate_list": """\
+def rotate_list(xs: list, k: int) -> list:
+    n = len(xs)
+    if n == 0:
+        return []
+    k %= n
+    return xs[-k:] + xs[:-k] if k else xs[:]
+""",
+    "most_common_char": """\
+from collections import Counter
+def most_common_char(s: str):
+    if not s:
+        return None
+    cnt = Counter(s)
+    best = None
+    best_n = -1
+    seen = set()
+    for ch in s:
+        if ch in seen:
+            continue
+        seen.add(ch)
+        n = cnt[ch]
+        if n > best_n:
+            best = ch
+            best_n = n
+    return best
+""",
+    "merge_intervals": """\
+def merge_intervals(intervals: list) -> list:
+    if not intervals:
+        return []
+    intervals = sorted(intervals, key=lambda x: (x[0], x[1]))
+    out = [intervals[0][:]]
+    for s, e in intervals[1:]:
+        ls, le = out[-1]
+        if s <= le:
+            out[-1][1] = max(le, e)
+        else:
+            out.append([s, e])
+    return out
+""",
+    "balanced_brackets": """\
+def balanced_brackets(s: str) -> bool:
+    pairs = {')':'(', ']':'[', '}':'{'}
+    st = []
+    for ch in s or "":
+        if ch in "([{":
+            st.append(ch)
+        elif ch in ")]}":
+            if not st or st[-1] != pairs[ch]:
+                return False
+            st.pop()
+    return not st
+""",
+    "median_of_list": """\
+def median_of_list(xs: list):
+    if not xs:
+        return None
+    ys = sorted(xs)
+    n = len(ys)
+    m = n // 2
+    if n % 2 == 1:
+        return ys[m]
+    return (ys[m-1] + ys[m]) / 2
+""",
+    "second_largest": """\
+def second_largest(xs: list):
+    uniq = sorted(set(xs))
+    return None if len(uniq) < 2 else uniq[-2]
+""",
+    "chunk_list": """\
+def chunk_list(xs: list, size: int) -> list:
+    if size <= 0:
+        return []
+    return [xs[i:i+size] for i in range(0, len(xs), size)]
+""",
+    "count_words": """\
+import re
+def count_words(s: str) -> dict:
+    if not s:
+        return {}
+    words = re.findall(r"[A-Za-z0-9]+", s.lower())
+    out = {}
+    for w in words:
+        out[w] = out.get(w, 0) + 1
+    return out
+""",
+    "remove_dups_preserve": """\
+def remove_dups_preserve(xs: list) -> list:
+    seen = set()
+    out = []
+    for v in xs:
+        if v not in seen:
+            seen.add(v)
+            out.append(v)
+    return out
+""",
+    "sum_of_primes": """\
+def _is_prime_p(n: int) -> bool:
+    if n < 2: return False
+    if n % 2 == 0: return n == 2
+    d = 3
+    while d*d <= n:
+        if n % d == 0:
+            return False
+        d += 2
+    return True
+def sum_of_primes(n: int) -> int:
+    n = int(n)
+    return sum(i for i in range(2, n+1) if _is_prime_p(i))
+""",
+    "is_prime": """\
+def is_prime(n: int) -> bool:
+    n = int(n)
+    if n < 2: return False
+    if n % 2 == 0: return n == 2
+    d = 3
+    while d*d <= n:
+        if n % d == 0:
+            return False
+        d += 2
+    return True
+""",
+    "binary_search": """\
+def binary_search(arr: list, target) -> int:
+    lo, hi = 0, len(arr) - 1
+    while lo <= hi:
+        mid = (lo + hi) // 2
+        if arr[mid] == target:
+            return mid
+        if arr[mid] < target:
+            lo = mid + 1
+        else:
+            hi = mid - 1
+    return -1
+""",
+    "prefix_sums": """\
+def prefix_sums(xs: list) -> list:
+    out = []
+    s = 0
+    for v in xs:
+        s += v
+        out.append(s)
+    return out
+""",
+    "longest_common_prefix": """\
+def longest_common_prefix(strs: list) -> str:
+    if not strs:
+        return ""
+    s = min(strs)
+    e = max(strs)
+    i = 0
+    while i < len(s) and i < len(e) and s[i] == e[i]:
+        i += 1
+    return s[:i]
+""",
+    "hamming_distance": """\
+def hamming_distance(a: str, b: str) -> int:
+    if a is None or b is None or len(a) != len(b):
+        raise ValueError("strings must be same length")
+    return sum(ch1 != ch2 for ch1, ch2 in zip(a, b))
+""",
+    "rotate_matrix_90": """\
+def rotate_matrix_90(mat: list) -> list:
+    if not mat:
+        return []
+    return [list(row)[::-1] for row in zip(*mat)]
+""",
+    "staircase": """\
+def staircase(n: int) -> list:
+    n = int(n)
+    if n <= 0: return []
+    return ["#" * i for i in range(1, n+1)]
+""",
+    "merge_sorted_lists": """\
+def merge_sorted_lists(a: list, b: list) -> list:
+    i = j = 0
+    out = []
+    while i < len(a) and j < len(b):
+        if a[i] <= b[j]:
+            out.append(a[i]); i += 1
+        else:
+            out.append(b[j]); j += 1
+    out.extend(a[i:]); out.extend(b[j:])
+    return out
+""",
+    "parse_kv_pairs": r"""\
+import re
+_INT = re.compile(r"^[+-]?\d+$")
+def parse_kv_pairs(s: str) -> dict:
+    out = {}
+    if not s:
+        return out
+    for p in (part for part in s.split(';') if part.strip()):
+        if '=' in p:
+            k, v = p.split('=', 1)
+            k, v = k.strip(), v.strip()
+            if _INT.match(v):
+                try:
+                    out[k] = int(v)
+                except Exception:
+                    out[k] = v
+            else:
+                out[k] = v
+    return out
+""",
+    "sum_diagonal": """\
+def sum_diagonal(mat: list) -> int:
+    n = min(len(mat), len(mat[0]) if mat else 0)
+    return sum(mat[i][i] for i in range(n))
+""",
+}'''
+
+IMPL = r'''def _impl_parse_kv_pairs() -> str:
+    return r"""\
+import re
+_INT = re.compile(r"^[+-]?\d+$")
+def parse_kv_pairs(s: str) -> dict:
+    out = {}
+    if not s:
+        return out
+    for p in (part for part in s.split(';') if part.strip()):
+        if '=' in p:
+            k, v = p.split('=', 1)
+            k, v = k.strip(), v.strip()
+            if _INT.match(v):
+                try:
+                    out[k] = int(v)
+                except Exception:
+                    out[k] = v
+            else:
+                out[k] = v
+    return out
+"""'''
+
+open(os.path.join(OUTDIR, "README.md"), "w", encoding="utf-8").write(README)
+open(os.path.join(OUTDIR, "HOWTO.md"), "w", encoding="utf-8").write(HOWTO)
+open(os.path.join(OUTDIR, "templates.py"), "w", encoding="utf-8").write(TEMPLATES)
+open(os.path.join(OUTDIR, "parse_kv_pairs_impl.py"), "w", encoding="utf-8").write(IMPL)
+open(os.path.join(OUTDIR, "version.json"), "w", encoding="utf-8").write(
+    json.dumps({"package":"glitchlab_scenarios","created_ts":int(time.time()),
+                "files":["templates.py","parse_kv_pairs_impl.py","README.md","HOWTO.md","version.json"]}, indent=2)
+)
+
+ZIP = os.path.join(BASE, "glitchlab_scenarios.zip")
+with zipfile.ZipFile(ZIP, "w", compression=zipfile.ZIP_DEFLATED) as z:
+    for name in os.listdir(OUTDIR):
+        z.write(os.path.join(OUTDIR, name), arcname=f"glitchlab_scenarios/{name}")
+
+print(f"OK -> {ZIP}")
diff --git a/tests/test_hybrid_mosaic_algo.py b/tests/test_hybrid_mosaic_algo.py
new file mode 100644
index 0000000..83e9cf2
--- /dev/null
+++ b/tests/test_hybrid_mosaic_algo.py
@@ -0,0 +1,169 @@
+# -*- coding: utf-8 -*-
+"""
+tests/test_hybrid_mosaic_algo.py
+Zestaw testów własnościowych i regresyjnych dla hybrydowego algorytmu AST⇄Mozaika.
+Uruchom:
+  pytest -q
+"""
+
+from __future__ import annotations
+import math
+from typing import List
+
+import numpy as np
+import pytest
+
+import glitchlab.gui.mosaic.hybrid_ast_mosaic as hma
+
+EDGE_THR = hma.EDGE_THR_DEFAULT  # spójny próg z modułem
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# FIXTURES
+# ──────────────────────────────────────────────────────────────────────────────
+
+@pytest.fixture(scope="module")
+def ast_raw():
+    return hma.ast_deltas(hma.EXAMPLE_SRC)
+
+@pytest.fixture(scope="module", params=[0.0, 0.25, 0.5, 0.75])
+def lam(request):
+    return request.param
+
+@pytest.fixture(scope="module")
+def ast_l(ast_raw, lam):
+    return hma.compress_ast(ast_raw, lam)
+
+@pytest.fixture(scope="module", params=[("grid", 12, 12), ("hex", 12, 12)])
+def mosaic(request):
+    kind, R, C = request.param
+    return hma.build_mosaic(rows=R, cols=C, seed=7, kind=kind, edge_thr=EDGE_THR)
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# INWARIANTY I WŁAŚCIWOŚCI METRYK
+# ──────────────────────────────────────────────────────────────────────────────
+
+def test_I1_I3_via_invariants_check(ast_raw, lam, mosaic):
+    aL = hma.compress_ast(ast_raw, lam)
+    inv = hma.invariants_check(ast_raw, aL, mosaic, EDGE_THR)
+    assert inv["I1_alpha_plus_beta_eq_1"]
+    assert inv["I3_compression_monotone"]
+
+def test_I2_metric_D_M_basic(mosaic):
+    roi = hma.region_ids(mosaic, "roi", EDGE_THR)
+    top = hma.region_ids(mosaic, "all", EDGE_THR)[:len(roi)] if len(roi) else []
+    # nieujemność + tożsamość
+    assert hma.D_M(roi, roi, mosaic, EDGE_THR) == 0.0
+    if roi and top:
+        d1 = hma.D_M(roi, top, mosaic, EDGE_THR)
+        d2 = hma.D_M(top, roi, mosaic, EDGE_THR)
+        assert d1 >= 0.0 and d2 >= 0.0
+        assert abs(d1 - d2) < 1e-9
+
+def test_CR_AST_monotone_in_lambda(ast_raw):
+    # CR_AST(λ) powinno być niemalejące (większa kompresja przy większym λ)
+    lams = [0.0, 0.25, 0.5, 0.75]
+    vals: List[float] = []
+    for lam in lams:
+        L = hma.compress_ast(ast_raw, lam)
+        cr = (ast_raw.S + ast_raw.H + max(1, ast_raw.Z)) / max(1, L.S + L.H + max(1, L.Z))
+        vals.append(cr)
+    assert all(vals[i] <= vals[i+1] + 1e-9 for i in range(len(vals)-1))
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# ZACHOWANIE Φ / Ψ
+# ──────────────────────────────────────────────────────────────────────────────
+
+@pytest.mark.parametrize("kind", ["heur", "balanced", "entropy"])
+def test_phi_cost_defined(ast_l, mosaic, kind):
+    sel = dict(
+        heur=hma.phi_region_for,
+        balanced=hma.phi_region_for_balanced,
+        entropy=hma.phi_region_for_entropy,
+    )[kind]
+    J, det = hma.phi_cost(ast_l, mosaic, EDGE_THR, selector=sel)
+    assert isinstance(J, float) and J >= 0.0
+    assert isinstance(det, dict) and len(det) > 0
+
+def test_phi2_not_worse_than_phi1_on_average(ast_raw, mosaic):
+    lam = 0.60
+    aL = hma.compress_ast(ast_raw, lam)
+    J1, _ = hma.phi_cost(aL, mosaic, EDGE_THR, selector=hma.phi_region_for)
+    J2, _ = hma.phi_cost(aL, mosaic, EDGE_THR, selector=hma.phi_region_for_balanced)
+    # nie gwarantujemy przewagi w danym M, ale zwykle J2 ≤ J1
+    assert J2 <= J1 or math.isclose(J1, J2, rel_tol=1e-3, abs_tol=1e-6)
+
+def test_psi_feedback_changes_meta(ast_l, mosaic):
+    before = {i: n.meta.copy() for i, n in ast_l.nodes.items()}
+    after = hma.psi_feedback(ast_l, mosaic, delta=0.25, thr=EDGE_THR)
+    changed = sum(int(np.linalg.norm(after.nodes[i].meta - before[i]) > 1e-9) for i in before.keys())
+    assert changed > 0
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# ALIGN / DISTANCE
+# ──────────────────────────────────────────────────────────────────────────────
+
+def test_align_in_0_1(ast_l, mosaic):
+    ast_after = hma.psi_feedback(ast_l, mosaic, delta=0.25, thr=EDGE_THR)
+    align = 1.0 - min(1.0, hma.distance_ast_mosaic(ast_after, mosaic, EDGE_THR))
+    assert 0.0 <= align <= 1.0
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# HEX PACKING — sanity (jeśli dostępny)
+# ──────────────────────────────────────────────────────────────────────────────
+
+def test_hex_packing_two_neighbor_scales():
+    M = hma.build_mosaic(rows=8, cols=8, seed=3, kind="hex", edge_thr=EDGE_THR)
+    centers = getattr(M, "hex_centers", None)
+    if centers is None:
+        pytest.skip("Brak metadanych hex_centers — test pominięty.")
+    # wybierz środek siatki (indeks ≈ wiersz 3, kol 3)
+    mid_idx = 3 * M.cols + 3
+    x0, y0 = centers[mid_idx]
+    # policz odległości do najbliższych sąsiadów (pierwsze ~8-10)
+    dists = []
+    for i, (x, y) in enumerate(centers):
+        if i == mid_idx:
+            continue
+        d = math.hypot(x - x0, y - y0)
+        if d > 0:
+            dists.append(d)
+    dists = sorted(dists)[:12]
+    # zgrupuj odległości z tolerancją — spodziewamy się ~2 klastrów (kolumnowy i wierszowy kierunek)
+    def bucketize(vals, tol=1e-6):
+        groups = []
+        for v in vals:
+            placed = False
+            for g in groups:
+                if abs(g[0] - v) < 1e-6:
+                    g[1].append(v); placed = True; break
+            if not placed:
+                groups.append([v, [v]])
+        return [ (g[0], len(g[1])) for g in groups ]
+    groups = bucketize(dists)
+    # powinny być co najmniej 2 wyraźne grupy
+    assert len(groups) >= 2
+
+
+# ──────────────────────────────────────────────────────────────────────────────
+# OPERACYJNY TEST ZNAKU (zredukowany)
+# ──────────────────────────────────────────────────────────────────────────────
+
+def test_sign_test_small_sample(ast_raw):
+    lam = 0.60
+    wins = losses = 0
+    for seed in range(20):
+        M = hma.build_mosaic(rows=12, cols=12, seed=seed, kind="grid", edge_thr=EDGE_THR)
+        aL = hma.compress_ast(ast_raw, lam)
+        j1, _ = hma.phi_cost(aL, M, EDGE_THR, selector=hma.phi_region_for)
+        j2, _ = hma.phi_cost(aL, M, EDGE_THR, selector=hma.phi_region_for_balanced)
+        if j1 > j2:
+            wins += 1
+        elif j1 < j2:
+            losses += 1
+    # nie dowód statystyczny, ale w małej próbce spodziewamy się wins >= losses
+    assert wins >= losses
diff --git a/tests/test_layer_viewer_manual.py b/tests/test_layer_viewer_manual.py
new file mode 100644
index 0000000..c3ed73a
--- /dev/null
+++ b/tests/test_layer_viewer_manual.py
@@ -0,0 +1,255 @@
+# -*- coding: utf-8 -*-
+"""
+RĘCZNY TEST widoku: LayerCanvas (+ opcjonalnie LayersPanel).
+Uruchomienie:
+  python -m glitchlab.tests.test_layer_viewer_manual [ścieżka_do_obrazka]
+
+Co sprawdza:
+  • Czy obraz jest widoczny na LayerCanvas (pojedynczy Canvas).
+  • Pan/zoom (LPM-drag + kółko myszy).
+  • Crosshair (linia h/v za kursorem).
+  • Kilka warstw (podstawowa + nakładka przesunięta).
+  • Integracja z LayersPanel (jeśli zainstalowany): add/remove/reorder/visible/opacity/blend.
+  • EventBus – loguje emitowane eventy do konsoli.
+
+Skróty:
+  F  – Fit to window
+  C  – Center
+  +  – Zoom in (x1.1)
+  -  – Zoom out (x/1.1)
+  1/2 – Ustaw warstwę aktywną (0..n-1)
+  V  – Toggle visibility aktywnej warstwy
+  Strzałki – Nudge offset aktywnej warstwy (±5 px)
+"""
+
+from __future__ import annotations
+
+import os
+import sys
+import tkinter as tk
+from tkinter import ttk
+from typing import Any, Dict, Optional
+
+# Pillow do generowania prostych obrazów testowych
+try:
+    from PIL import Image, ImageDraw, ImageOps
+except Exception:
+    Image = ImageDraw = ImageOps = None  # type: ignore
+
+# Spróbuj pobrać LayerCanvas i opcjonalny LayersPanel
+try:
+    from glitchlab.gui.widgets.layer_canvas import LayerCanvas  # type: ignore
+except Exception as e:
+    print("[FATAL] Brak LayerCanvas:", e)
+    raise
+
+try:
+    from glitchlab.gui.views.layer_panel import LayersPanel  # type: ignore
+except Exception:
+    LayersPanel = None  # type: ignore
+
+
+# ───────────────────────────── prosty EventBus do logowania ──────────────────
+class _Bus:
+    def __init__(self, root: tk.Misc) -> None:
+        self._handlers: Dict[str, list] = {}
+        self.root = root
+
+    def publish(self, topic: str, payload: Dict[str, Any]) -> None:
+        print(f"[BUS] {topic} {payload}")
+        for fn in self._handlers.get(topic, []):
+            try:
+                fn(topic, payload)
+            except Exception as e:
+                print("[BUS handler error]", e)
+
+    def subscribe(self, topic: str, fn) -> None:
+        self._handlers.setdefault(topic, []).append(fn)
+
+
+# ───────────────────────────── obrazy testowe ─────────────────────────────────
+def _make_checker(size=(1024, 768), cell=64):
+    assert Image is not None
+    w, h = size
+    im = Image.new("RGB", size, (235, 235, 235))
+    draw = ImageDraw.Draw(im)
+    c1 = (210, 210, 210); c2 = (245, 245, 245)
+    for y in range(0, h, cell):
+        for x in range(0, w, cell):
+            c = c1 if ((x // cell + y // cell) % 2 == 0) else c2
+            draw.rectangle([x, y, x + cell - 1, y + cell - 1], fill=c)
+    # ramka
+    draw.rectangle([0, 0, w - 1, h - 1], outline=(60, 60, 60), width=3)
+    return im
+
+def _make_overlay(size=(1024, 768)):
+    assert Image is not None
+    w, h = size
+    im = Image.new("RGB", size, (0, 0, 0))
+    draw = ImageDraw.Draw(im)
+    # kilka kolorowych kształtów do łatwego rozróżnienia
+    draw.ellipse([w//4, h//4, w//4 + 240, h//4 + 240], outline=(255, 64, 64), width=8)
+    draw.rectangle([w//2 - 160, h//2 - 100, w//2 + 160, h//2 + 100], outline=(64, 160, 255), width=8)
+    draw.line([0, 0, w, h], fill=(64, 200, 64), width=6)
+    draw.text((20, 20), "Overlay", fill=(255, 128, 0))
+    return im
+
+
+# ───────────────────────────── main UI ────────────────────────────────────────
+def main():
+    root = tk.Tk()
+    root.title("GlitchLab – manualny test LayerCanvas")
+
+    # layout: viewer po lewej, (opcjonalnie) panel warstw po prawej
+    pw = ttk.Panedwindow(root, orient="horizontal")
+    pw.pack(fill="both", expand=True)
+
+    bus = _Bus(root)
+    left = ttk.Frame(pw); left.rowconfigure(0, weight=1); left.columnconfigure(0, weight=1)
+    viewer = LayerCanvas(left, bus=bus)
+    viewer.grid(row=0, column=0, sticky="nsew")
+    pw.add(left, weight=70)
+
+    right = ttk.Frame(pw)
+    panel = None
+    if LayersPanel is not None:
+        panel = LayersPanel(right, bus=bus)
+        panel.pack(fill="both", expand=True)
+        pw.add(right, weight=30)
+
+    # wejście: ścieżka lub generowany checker
+    img_path = sys.argv[1] if len(sys.argv) > 1 else None
+    if Image is None:
+        raise RuntimeError("Pillow jest wymagany dla testu.")
+
+    if img_path and os.path.exists(img_path):
+        base = ImageOps.exif_transpose(Image.open(img_path)).convert("RGB")
+    else:
+        base = _make_checker((1024, 768))
+
+    overlay = _make_overlay(base.size)
+
+    # ustaw 2 warstwy (druga przesunięta)
+    viewer.set_layers([base, overlay], names=["Background", "Overlay"])
+    viewer.set_layer_offset(1, 120, 80)
+    viewer.zoom_fit()
+
+    # jeśli mamy panel warstw, karm go snapshotem (symulacja App)
+    def _push_snapshot(_topic=None, _payload=None):
+        if panel is None:
+            return
+        # minimalny snapshot dla panelu
+        layers = []
+        for i, nm in enumerate(["Background", "Overlay"]):
+            layers.append({
+                "id": str(i),
+                "name": nm,
+                "visible": True,
+                "opacity": 1.0,
+                "blend": "normal",
+            })
+        panel.set_snapshot(layers, active="0")
+
+    _push_snapshot()
+
+    # Klawisze testowe
+    def zoom_in(_e=None):
+        viewer.set_zoom(viewer.get_zoom() * 1.1)
+
+    def zoom_out(_e=None):
+        viewer.set_zoom(viewer.get_zoom() / 1.1)
+
+    def fit(_e=None):
+        viewer.zoom_fit()
+
+    def center(_e=None):
+        viewer.center()
+
+    def set_active(idx: int):
+        def _inner(_e=None):
+            viewer.set_active_layer(idx)
+            print("[TEST] active layer =", viewer.get_active_layer())
+        return _inner
+
+    def toggle_vis(_e=None):
+        idx = viewer.get_active_layer()
+        if idx is None:
+            return
+        # odczyt widoczności z wewnętrznej listy (tylko do testu)
+        visible = True
+        try:
+            visible = bool(viewer._LayerCanvas__dict__)  # trigger NameError – zostawiamy fallback niżej
+        except Exception:
+            pass
+        try:
+            visible = viewer._LayerCanvas__layers[idx].visible  # pyright: ignore
+        except Exception:
+            # nie ma dostępu – zrobimy heurystykę: spróbuj przełączyć zawsze na odwrotność
+            pass
+        # bezpiecznie toggluj
+        try:
+            viewer.set_layer_visible(idx, not visible)
+        except Exception:
+            viewer.set_layer_visible(idx, False)
+
+    def nudge(dx: int, dy: int):
+        def _inner(_e=None):
+            idx = viewer.get_active_layer()
+            if idx is None:
+                return
+            try:
+                # Pobierz aktualny offset przez „screen_to_image” na (0,0)? Nie – wewnętrzny stan mamy przez API
+                # więc róbmy inkrementalnie: najpierw nic nie wiemy – zatem przesuń o +/− i zostaw rysunek
+                # (dla demo wystarczy).
+                viewer.set_layer_offset(idx, dx + 0, dy + 0)  # inkrementy – jeżeli chcesz kumulować, rozbuduj API
+            except Exception:
+                pass
+        return _inner
+
+    # mapowanie klawiszy
+    root.bind("+", zoom_in)
+    root.bind("=", zoom_in)
+    root.bind("-", zoom_out)
+    root.bind("_", zoom_out)
+    root.bind("f", fit)
+    root.bind("F", fit)
+    root.bind("c", center)
+    root.bind("C", center)
+    root.bind("1", set_active(0))
+    root.bind("2", set_active(1))
+    root.bind("v", toggle_vis)
+    root.bind("V", toggle_vis)
+
+    # strzałki – drobne przesunięcia (5 px w układzie obrazu → przeskalowane automatycznie)
+    def _arrow(dx, dy):
+        def _h(_e=None):
+            idx = viewer.get_active_layer()
+            if idx is None:
+                return
+            # odczytaj stary offset (prywatny – do testu)
+            old = (0, 0)
+            try:
+                old = viewer._LayerCanvas__layers[idx].offset  # type: ignore
+            except Exception:
+                try:
+                    old = viewer._layers[idx].offset  # type: ignore
+                except Exception:
+                    pass
+            viewer.set_layer_offset(idx, old[0] + dx, old[1] + dy)
+        return _h
+
+    root.bind("<Left>", _arrow(-5, 0))
+    root.bind("<Right>", _arrow(5, 0))
+    root.bind("<Up>", _arrow(0, -5))
+    root.bind("<Down>", _arrow(0, 5))
+
+    print("== Manualny test LayerCanvas ==")
+    print("Klawisze: F=Fit, C=Center, +/-=Zoom, 1/2=aktywna warstwa, V=toggle visible, Strzałki=nudge")
+    print("Jeśli nie widzisz obrazu: sprawdź, czy masz Pillow; odpal bez ścieżki aby użyć obrazów testowych.")
+
+    root.geometry("1200x800")
+    root.mainloop()
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/test_tools_registry.py b/tests/test_tools_registry.py
new file mode 100644
index 0000000..72f089c
--- /dev/null
+++ b/tests/test_tools_registry.py
@@ -0,0 +1,82 @@
+# tests/test_tools_registry.py
+# -*- coding: utf-8 -*-
+"""
+Testy rejestru narzędzi canvasa + tryb "demo" z widocznym outputem.
+
+Uruchomienia:
+- Jako test (polecane):        pytest -q
+- Z widocznymi printami:       pytest -s -q
+- Jako samodzielny skrypt:     python tests/test_tools_registry.py
+"""
+
+import importlib
+import types
+import sys
+
+
+def _load_registry():
+    mod = importlib.import_module("glitchlab.gui.widgets.tools.__init__")
+    assert isinstance(mod, types.ModuleType)
+    return mod
+
+
+def test_available_and_default(capsys=None):
+    tools = _load_registry()
+    names = tools.available()
+    # PRINT dla czytelności (widoczny z pytest -s)
+    print("[tools.available]", names)
+
+    assert isinstance(names, list) and len(names) >= 1
+    assert all(isinstance(n, str) for n in names)
+
+    default_name = getattr(tools, "DEFAULT_TOOL")
+    print("[DEFAULT_TOOL]", default_name)
+    assert default_name in names
+
+
+def test_get_tool_known_unknown():
+    tools = _load_registry()
+    for candidate in ("rect", "ellipse", "view"):
+        ToolCls = tools.get_tool(candidate)
+        print(f"[get_tool('{candidate}')] ->", getattr(ToolCls, "__name__", str(ToolCls)))
+        assert isinstance(ToolCls, type), f"{candidate} nie zwrócił klasy"
+
+    ToolUnknown = tools.get_tool("nope-nope-123")
+    ToolDefault = tools.get_tool(getattr(tools, "DEFAULT_TOOL"))
+    print("[get_tool('nope-nope-123')] -> fallback:", getattr(ToolUnknown, "__name__", str(ToolUnknown)))
+    assert ToolUnknown is ToolDefault
+
+
+def test_debug_errors_contract():
+    tools = _load_registry()
+    errs = tools.debug_errors()
+    print("[debug_errors]", errs)
+    assert isinstance(errs, dict)
+
+
+# ───────────────────────────── tryb samodzielny ─────────────────────────────
+if __name__ == "__main__":
+    # Pozwala szybko zobaczyć wynik bez pytesta.
+    try:
+        tools = _load_registry()
+        names = tools.available()
+        default_name = getattr(tools, "DEFAULT_TOOL")
+        errs = tools.debug_errors()
+
+        print("=== tools registry demo ===")
+        print("available:", names)
+        print("DEFAULT_TOOL:", default_name)
+        print("get_tool('rect'):", getattr(tools.get_tool("rect"), "__name__", "<?>"))
+        print("get_tool('ellipse'):", getattr(tools.get_tool("ellipse"), "__name__", "<?>"))
+        print("get_tool('view'):", getattr(tools.get_tool("view"), "__name__", "<?>"))
+        print("get_tool('<unknown>') ->", getattr(tools.get_tool("___"), "__name__", "<?>"), "(fallback)")
+        print("import errors:", errs if errs else "{}")
+
+        # Minimalne asercje w trybie standalone, by nie przeoczyć problemów:
+        assert isinstance(names, list) and len(names) >= 1, "Brak jakichkolwiek narzędzi w registry"
+        assert default_name in names, "DEFAULT_TOOL nie wskazuje istniejącego narzędzia"
+        print("\nOK: registry wygląda zdrowo.")
+        sys.exit(0)
+    except Exception as ex:
+        print("ERROR:", type(ex).__name__, ex)
+        sys.exit(1)
-- 
2.45.1.windows.1


From dec9fa94e191a8086b5446b17be4a7f8aad6acc8 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 02:55:08 +0200
Subject: [PATCH 3/9] commit 56: TEST

---
 VERSION.json  | 2 +-
 core/graph.py | 1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/VERSION.json b/VERSION.json
index 7e6c325..f769ef4 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0022", "sha": "2c8f5b1449177c7678a505739359b28ddde50d31", "updated_at": "2025-09-28T00:22:10Z"}
+{"app": "glitchlab", "version": "2025.09.28-0055", "sha": "3cc2f1b814c7aaff36b1833e2b88d90e6a9275b2", "updated_at": "2025-09-28T00:55:08Z"}
diff --git a/core/graph.py b/core/graph.py
index 7a74123..c586d69 100644
--- a/core/graph.py
+++ b/core/graph.py
@@ -1,6 +1,5 @@
 # glitchlab/core/graph.py
 """
----
 version: 2
 kind: module
 id: "core-graph"
-- 
2.45.1.windows.1


From 94f69e18c1b8e7c53e2256ac68f8f11713996c43 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 03:10:53 +0200
Subject: [PATCH 4/9] commit 58: TEST Commit 2

---
 VERSION.json  | 2 +-
 core/graph.py | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/VERSION.json b/VERSION.json
index f769ef4..ec5eb89 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0055", "sha": "3cc2f1b814c7aaff36b1833e2b88d90e6a9275b2", "updated_at": "2025-09-28T00:55:08Z"}
+{"app": "glitchlab", "version": "2025.09.28-0110", "sha": "dec9fa94e191a8086b5446b17be4a7f8aad6acc8", "updated_at": "2025-09-28T01:10:53Z"}
diff --git a/core/graph.py b/core/graph.py
index c586d69..7014c60 100644
--- a/core/graph.py
+++ b/core/graph.py
@@ -6,7 +6,7 @@ id: "core-graph"
 created_at: "2025-09-11"
 name: "glitchlab.core.graph"
 author: "GlitchLab v2"
-role: "DAG Builder & Metrics Aggregator"
+role: " DAG Builder & Metrics Aggregator"
 description: >
   Buduje liniowy DAG (nodes/edges) na podstawie steps oraz metryk zapisanych w ctx.cache
   przez pipeline. Agreguje czasy, metryki in/out, diff_stats i wylicza delty (out−in).
-- 
2.45.1.windows.1


From 2c1d2a865285b9af1936319f04a5f0618f8e4558 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 03:37:57 +0200
Subject: [PATCH 5/9] commit 59: TEST Commit 3

---
 VERSION.json  | 2 +-
 core/graph.py | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/VERSION.json b/VERSION.json
index ec5eb89..052c48f 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0110", "sha": "dec9fa94e191a8086b5446b17be4a7f8aad6acc8", "updated_at": "2025-09-28T01:10:53Z"}
+{"app": "glitchlab", "version": "2025.09.28-0137", "sha": "94f69e18c1b8e7c53e2256ac68f8f11713996c43", "updated_at": "2025-09-28T01:37:58Z"}
diff --git a/core/graph.py b/core/graph.py
index 7014c60..c586d69 100644
--- a/core/graph.py
+++ b/core/graph.py
@@ -6,7 +6,7 @@ id: "core-graph"
 created_at: "2025-09-11"
 name: "glitchlab.core.graph"
 author: "GlitchLab v2"
-role: " DAG Builder & Metrics Aggregator"
+role: "DAG Builder & Metrics Aggregator"
 description: >
   Buduje liniowy DAG (nodes/edges) na podstawie steps oraz metryk zapisanych w ctx.cache
   przez pipeline. Agreguje czasy, metryki in/out, diff_stats i wylicza delty (out−in).
-- 
2.45.1.windows.1


From 7593a735758a25257f1e8710a79cac3ccf56ebbf Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 03:42:02 +0200
Subject: [PATCH 6/9] commit 60: TEST Commit 4

---
 VERSION.json   | 2 +-
 core/astmap.py | 1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/VERSION.json b/VERSION.json
index 052c48f..a8f78b5 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0137", "sha": "94f69e18c1b8e7c53e2256ac68f8f11713996c43", "updated_at": "2025-09-28T01:37:58Z"}
+{"app": "glitchlab", "version": "2025.09.28-0142", "sha": "2c1d2a865285b9af1936319f04a5f0618f8e4558", "updated_at": "2025-09-28T01:42:03Z"}
diff --git a/core/astmap.py b/core/astmap.py
index 1ce4e6e..c8a0149 100644
--- a/core/astmap.py
+++ b/core/astmap.py
@@ -1,6 +1,5 @@
 # glitchlab/core/astmap.py
 """
----
 version: 2
 kind: module
 id: "core-astmap"
-- 
2.45.1.windows.1


From 8286b4723ff794b4146b3690b3f493abb55f94b2 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 05:33:46 +0200
Subject: [PATCH 7/9] commit 61: TEST Commit 5

---
 VERSION.json   |  2 +-
 core/astmap.py | 29 +++++++++++++++++++----------
 2 files changed, 20 insertions(+), 11 deletions(-)

diff --git a/VERSION.json b/VERSION.json
index a8f78b5..f3076a5 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0142", "sha": "2c1d2a865285b9af1936319f04a5f0618f8e4558", "updated_at": "2025-09-28T01:42:03Z"}
+{"app": "glitchlab", "version": "2025.09.28-0333", "sha": "7593a735758a25257f1e8710a79cac3ccf56ebbf", "updated_at": "2025-09-28T03:33:47Z"}
diff --git a/core/astmap.py b/core/astmap.py
index c8a0149..d161690 100644
--- a/core/astmap.py
+++ b/core/astmap.py
@@ -5,7 +5,7 @@ kind: module
 id: "core-astmap"
 created_at: "2025-09-11"
 name: "glitchlab.core.astmap"
-author: "GlitchLab v2"
+author: "GlitchLab v2" [LINUX][REPO][REFRESH]
 role: "Python AST → Graph & Mosaic Projector"
 description: >
   Parsuje źródło Pythona do AST, buduje lekki graf semantyczny (funkcje/klasy/połączenia)
@@ -59,6 +59,7 @@ __all__ = [
     "export_ast_json",
 ]
 
+
 # --------------------------------------------------------------------------------------
 # AST build
 # --------------------------------------------------------------------------------------
@@ -81,9 +82,11 @@ class _DefRef:
     kind: str
     ast_node: ast.AST
 
+
 def _fqname(stack: List[str], name: str) -> str:
     return ".".join([*stack, name]) if stack else name
 
+
 def _count_subtree_metrics(n: ast.AST) -> Tuple[int, int]:
     """Zwraca (weight, branching) w poddrzewie: weight = liczba node'ów, branching = liczba {If,For,While,Try}."""
     w = 0
@@ -94,6 +97,7 @@ def _count_subtree_metrics(n: ast.AST) -> Tuple[int, int]:
             b += 1
     return w, b
 
+
 def ast_to_graph(tree: ast.AST) -> Dict[str, Any]:
     """
     Buduje lekki graf:
@@ -230,6 +234,7 @@ def _mosaic_label_raster(mosaic: Mapping[str, Any]) -> np.ndarray:
         raise ValueError("project_ast_to_mosaic: invalid mosaic['raster']")
     return lab
 
+
 def _normalize_values(vals: List[float]) -> Tuple[float, float]:
     if not vals:
         return 0.0, 1.0
@@ -239,6 +244,7 @@ def _normalize_values(vals: List[float]) -> Tuple[float, float]:
         vmax = vmin + 1.0
     return vmin, vmax
 
+
 def _fill_cell(overlay: np.ndarray, lab: np.ndarray, cid: int, color01: Tuple[float, float, float]) -> None:
     mask = (lab == cid)
     if not np.any(mask):
@@ -248,11 +254,12 @@ def _fill_cell(overlay: np.ndarray, lab: np.ndarray, cid: int, color01: Tuple[fl
     b = int(np.clip(color01[2] * 255.0 + 0.5, 0, 255))
     overlay[mask] = (r, g, b)
 
+
 def project_ast_to_mosaic(
-    graph: Mapping[str, Any],
-    mosaic: Mapping[str, Any],
-    *,
-    map_spec: Optional[Mapping[str, Tuple[str, Tuple[float, float]]]] = None,
+        graph: Mapping[str, Any],
+        mosaic: Mapping[str, Any],
+        *,
+        map_spec: Optional[Mapping[str, Tuple[str, Tuple[float, float]]]] = None,
 ) -> np.ndarray:
     """
     Projektuje metryki węzłów AST na komórki mozaiki (1 węzeł -> 1 komórka, w kolejności).
@@ -314,15 +321,16 @@ def project_ast_to_mosaic(
 # --------------------------------------------------------------------------------------
 
 def export_ast_json(
-    graph: Mapping[str, Any],
-    ctx_like: Optional[Mapping[str, Any]] = None,
-    *,
-    cache_key: str = "ast/json",
+        graph: Mapping[str, Any],
+        ctx_like: Optional[Mapping[str, Any]] = None,
+        *,
+        cache_key: str = "ast/json",
 ) -> Dict[str, Any]:
     """
     Zwraca dict gotowy do serializacji JSON. Jeśli ctx_like posiada 'cache' (dict),
     zapisuje kopię pod kluczem cache_key.
     """
+
     # JSON-friendly kopia (upewnij się, że typy są serializowalne)
     def _jsonify(obj: Any) -> Any:
         if isinstance(obj, (str, int, float, type(None), bool)):
@@ -341,7 +349,8 @@ def export_ast_json(
     }
 
     if ctx_like is not None:
-        cache = getattr(ctx_like, "cache", None) if hasattr(ctx_like, "cache") else ctx_like.get("cache")  # type: ignore
+        cache = getattr(ctx_like, "cache", None) if hasattr(ctx_like, "cache") else ctx_like.get(
+            "cache")  # type: ignore
         if isinstance(cache, dict):
             cache[cache_key] = data
     return data
-- 
2.45.1.windows.1


From 90a0f2253e6fd8fdcecfe0a62a3500b006511488 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 05:33:58 +0200
Subject: [PATCH 8/9] commit 61: TEST Commit 5

---
 .env         | 7 +++----
 VERSION.json | 2 +-
 2 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/.env b/.env
index 3d13a2c..637d5c0 100644
--- a/.env
+++ b/.env
@@ -1,8 +1,7 @@
 GLX_SMTP_HOST=smtp.gmail.com
 GLX_SMTP_PORT=587
-GLX_SMTP_USER=ghglitchla@gmail.com
-GLX_SMTP_PASS=19A6C38024FC838884172E7AB7EE14E8
-GLX_MAIL_TO=ghglitchla@gmail.com
-
+GLX_SMTP_USER=ghglitchlab@gmail.com
+GLX_SMTP_PASS=uclknokijtakgqmj
+GLX_MAIL_TO=ghglitchlab@gmail.com
 GLX_PROJECT=glitchlab
 GLX_BRANCH=main
diff --git a/VERSION.json b/VERSION.json
index f3076a5..9624b25 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0333", "sha": "7593a735758a25257f1e8710a79cac3ccf56ebbf", "updated_at": "2025-09-28T03:33:47Z"}
+{"app": "glitchlab", "version": "2025.09.28-0333", "sha": "8286b4723ff794b4146b3690b3f493abb55f94b2", "updated_at": "2025-09-28T03:33:58Z"}
-- 
2.45.1.windows.1


From 59bddb535748a47080932c59647051cfbae1481c Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Sun, 28 Sep 2025 05:56:43 +0200
Subject: [PATCH 9/9] Remove .env from repo, keep in .gitignore

---
 .env         | 7 -------
 VERSION.json | 2 +-
 2 files changed, 1 insertion(+), 8 deletions(-)
 delete mode 100644 .env

diff --git a/.env b/.env
deleted file mode 100644
index 637d5c0..0000000
--- a/.env
+++ /dev/null
@@ -1,7 +0,0 @@
-GLX_SMTP_HOST=smtp.gmail.com
-GLX_SMTP_PORT=587
-GLX_SMTP_USER=ghglitchlab@gmail.com
-GLX_SMTP_PASS=uclknokijtakgqmj
-GLX_MAIL_TO=ghglitchlab@gmail.com
-GLX_PROJECT=glitchlab
-GLX_BRANCH=main
diff --git a/VERSION.json b/VERSION.json
index 9624b25..15d19ee 100644
--- a/VERSION.json
+++ b/VERSION.json
@@ -1 +1 @@
-{"app": "glitchlab", "version": "2025.09.28-0333", "sha": "8286b4723ff794b4146b3690b3f493abb55f94b2", "updated_at": "2025-09-28T03:33:58Z"}
+{"app": "glitchlab", "version": "2025.09.28-0356", "sha": "90a0f2253e6fd8fdcecfe0a62a3500b006511488", "updated_at": "2025-09-28T03:56:44Z"}
-- 
2.45.1.windows.1

