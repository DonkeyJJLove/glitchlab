From 3a5cebedf6bc8cba076af54633a7935dd8712473 Mon Sep 17 00:00:00 2001
From: d2j3 <donkeyjjlove@protonmail.com>
Date: Mon, 29 Sep 2025 18:54:42 +0200
Subject: [PATCH] =?UTF-8?q?2=20file(s)=20staged:=20[=CE=94]=20Zakres=20-?=
 =?UTF-8?q?=20files:=202=20(hybrid=5Fast=5Fmosaic.py,=20structure.md)=20-?=
 =?UTF-8?q?=20typ:=20auto=20(pre-diff)?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

[Φ/Ψ] Mozaika (semantyka kodu)
- Align(mean .py): 0.41
- Hint: brak wpływu na strukturę sąsiednich kafli

[AST] Deltas (staged .py)
- S: 696  H: 2699
- uwagi: wartości przybliżone (heurystyki)

[Dokumentacja]
- decyzja: NO-OP

Meta
- Generated-by: pre-diff/AST-mosaic @ 2025-09-29 16:54:42Z

…
---
 gui/mosaic/hybrid_ast_mosaic.py | 248 +++++++++++++++++++++++---------
 structure.md                    | 152 ++++++++++++++++----
 2 files changed, 311 insertions(+), 89 deletions(-)

diff --git a/gui/mosaic/hybrid_ast_mosaic.py b/gui/mosaic/hybrid_ast_mosaic.py
index a6c3219..f26e204 100644
--- a/gui/mosaic/hybrid_ast_mosaic.py
+++ b/gui/mosaic/hybrid_ast_mosaic.py
@@ -13,6 +13,7 @@ import hashlib
 from dataclasses import dataclass, field
 from typing import List, Dict, Tuple, Optional, Callable
 import numpy as np
+from collections import Counter
 
 # ──────────────────────────────────────────────────────────────────────────────
 # 0) PARAMS / PUBLIC API
@@ -27,6 +28,9 @@ SOFT_LABELS_TAU: float = 0.08  # temperatura sigmoidy dla soft-etykiety
 # sprzężenie Ψ→(α,β) (wpływ Δ na Align)
 KAPPA_AB_DEFAULT: float = 0.35  # siła mieszania α/β z profilem mozaiki
 
+# tryb metadanych dla węzłów AST (deterministyczny domyślnie)
+META_MODE: str = "det"  # "det" | "rng"
+
 __all__ = [
     # dataclasses
     "AstNode", "AstSummary", "Mosaic",
@@ -49,6 +53,8 @@ __all__ = [
     # Example & params
     "EXAMPLE_SRC", "EDGE_THR_DEFAULT", "W_DEFAULT",
     "SOFT_LABELS_DEFAULT", "SOFT_LABELS_TAU", "KAPPA_AB_DEFAULT",
+    # Selektory i meta
+    "SELECTORS", "get_selector", "set_meta_mode", "META_MODE",
 ]
 
 EXAMPLE_SRC = r"""
@@ -100,23 +106,28 @@ class AstSummary:
     labels: List[str]
 
 
+# ── Meta: deterministyczne vs RNG (do testów)
+def set_meta_mode(mode: str) -> None:
+    """Ustaw tryb generacji meta: 'det' (domyślnie) lub 'rng'."""
+    global META_MODE
+    META_MODE = "rng" if str(mode).lower().startswith("rng") else "det"
+
+
 def _rng_for_meta(label: str, depth: int) -> np.random.Generator:
-    """Deterministyczny RNG niezależny od PYTHONHASHSEED (md5(label|depth))."""
+    """Deterministyczne ziarno dla RNG (md5(label|depth)) – tylko dla trybu 'rng'."""
     key = f"{label}|{depth}".encode("utf-8")
     h = hashlib.md5(key).digest()
     seed = int.from_bytes(h[:8], "little", signed=False)
     return np.random.default_rng(seed)
 
 
-def _meta_for(label: str, depth: int) -> np.ndarray:
+def _meta_random(label: str, depth: int) -> np.ndarray:
     rng = _rng_for_meta(label, depth)
     L, S, Sel, Stab, Cau, H = rng.uniform(0.35, 0.85, size=6)
     if label in ("FunctionDef", "ClassDef"):
-        Stab = max(Stab, 0.8);
-        Sel = max(Sel, 0.6)
+        Stab = max(Stab, 0.8); Sel = max(Sel, 0.6)
     if label in ("If", "While", "For", "With", "Try"):
-        Sel = max(Sel, 0.75);
-        Cau = max(Cau, 0.7)
+        Sel = max(Sel, 0.75); Cau = max(Cau, 0.7)
     if label in ("Call", "Expr"):
         L = max(L, 0.6)
     if label in ("Assign",):
@@ -124,62 +135,155 @@ def _meta_for(label: str, depth: int) -> np.ndarray:
     return np.array([L, S, Sel, Stab, Cau, H], dtype=float)
 
 
+def _clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
+    return float(min(hi, max(lo, x)))
+
+
+def _is_ctrl(lbl: str) -> bool:
+    return lbl in ("If", "While", "For", "With", "Try")
+
+
+def _is_def(lbl: str) -> bool:
+    return lbl in ("FunctionDef", "AsyncFunctionDef", "ClassDef")
+
+
+def _is_call(lbl: str) -> bool:
+    return lbl in ("Call", "Expr")
+
+
+def _is_assign(lbl: str) -> bool:
+    return lbl == "Assign"
+
+
+def _meta_deterministic(label: str, depth: int, n_children: int,
+                        subtree_size: int, uniq_labels: int) -> np.ndarray:
+    """
+    Deterministyczne meta z cech strukturalnych:
+    - L (linearity): maleje z rozgałęzieniem i wzrostem głębokości,
+    - S (structural): rośnie z rozmiarem poddrzewa,
+    - Sel (selectivity): wysoka dla węzłów sterujących, średnia dla Call/Expr,
+    - Stab (stability): wysoka dla Def/Assign, lekko maleje z głębokością,
+    - Cau (causality): wysoka dla sterujących i Return/Call,
+    - H (hetero): różnorodność etykiet w poddrzewie.
+    """
+    # L
+    L = 0.85 / (1.0 + 0.7 * n_children) * (1.0 / (1.0 + 0.05 * depth))
+    L = _clamp(0.35 + 0.65 * L)
+
+    # S
+    S = math.log1p(subtree_size) / math.log1p(64.0)
+    S = _clamp(0.35 + 0.65 * S)
+
+    # Sel
+    if _is_ctrl(label):
+        Sel = 0.85
+    elif _is_call(label):
+        Sel = 0.70
+    elif _is_assign(label):
+        Sel = 0.55
+    else:
+        Sel = 0.50
+    Sel = _clamp(Sel - 0.02 * max(0, depth - 8))
+
+    # Stab
+    if _is_def(label) or _is_assign(label):
+        Stab = 0.85
+    else:
+        Stab = 0.55
+    Stab = _clamp(Stab - 0.015 * depth)
+
+    # Cau
+    if _is_ctrl(label):
+        Cau = 0.80
+    elif _is_call(label):
+        Cau = 0.65
+    elif label in ("Return", "Raise",):
+        Cau = 0.75
+    else:
+        Cau = 0.50
+    Cau = _clamp(Cau + 0.03 * min(5, n_children))
+
+    # H (heterogeniczność)
+    if subtree_size <= 1:
+        Hh = 0.40
+    else:
+        div = _clamp(uniq_labels / float(subtree_size), 0.0, 1.0)
+        Hh = 0.40 + 0.5 * div
+    Hh = _clamp(Hh)
+
+    return np.array([L, S, Sel, Stab, Cau, Hh], dtype=float)
+
+
 def ast_deltas(src: str) -> AstSummary:
-    """Parsuje źródło Pythona i liczy przybliżone ΔS/ΔH/ΔZ wg prostych reguł."""
+    """Parsuje źródło Pythona i liczy ΔS/ΔH/ΔZ + meta (deterministyczne)."""
     tree = ast.parse(src)
     nodes: Dict[int, AstNode] = {}
+    labels_all: List[str] = []
     S = H = Z = 0
     maxZ = 0
     nid = 0
 
-    def add(a: ast.AST, depth: int, parent: Optional[int]) -> int:
+    def visit(a: ast.AST, depth: int, parent: Optional[int]) -> Tuple[int, int, Counter]:
+        """
+        Zwraca (node_id, subtree_size, counter_etykiet_subdrzewa).
+        Meta wyznaczamy PO przejściu dzieci (zależność od subtree_size/uniq).
+        """
         nonlocal nid, S, H, Z, maxZ
-        i = nid;
-        nid += 1
+
+        # alokacja węzła
+        my_id = nid; nid += 1
         lab = a.__class__.__name__
-        n = AstNode(i, lab, depth, parent)
-        n.meta = _meta_for(lab, depth)
-        nodes[i] = n
+        node = AstNode(my_id, lab, depth, parent)
+        nodes[my_id] = node
+        labels_all.append(lab)
         if parent is not None:
-            nodes[parent].children.append(i)
+            nodes[parent].children.append(my_id)
 
-        # Δ-reguły (skrót)
+        maxZ = max(maxZ, depth)
+
+        # odwiedź dzieci
+        sub_size = 1
+        counter = Counter([lab])
+        for ch in ast.iter_child_nodes(a):
+            ch_id, ch_size, ch_cnt = visit(ch, depth + 1, my_id)
+            sub_size += ch_size
+            counter.update(ch_cnt)
+
+        # Δ-reguły agregatów (jak wcześniej – zachowujemy stabilność S/H/Z)
         if isinstance(a, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
-            S += 1;
-            H += 1;
-            Z += 1
+            S += 1; H += 1; Z += 1
         elif isinstance(a, (ast.If, ast.For, ast.While, ast.With, ast.Try)):
-            S += 1;
-            Z += 1
+            S += 1; Z += 1
         elif isinstance(a, ast.Assign):
-            S += 1;
-            H += 1
+            S += 1; H += 1
         elif isinstance(a, ast.Call):
-            S += 1;
-            H += 2
+            S += 1; H += 2
         elif isinstance(a, (ast.Import, ast.ImportFrom)):
-            S += 1;
-            H += len(a.names)
+            S += 1; H += len(a.names)
         elif isinstance(a, ast.Name):
             H += 1
 
-        maxZ = max(maxZ, depth)
-
-        for ch in ast.iter_child_nodes(a):
-            add(ch, depth + 1, i)
+        # meta (det lub rng)
+        n_children = len(node.children)
+        if META_MODE == "rng":
+            node.meta = _meta_random(lab, depth)
+        else:
+            node.meta = _meta_deterministic(
+                lab, depth, n_children, sub_size, uniq_labels=len(counter)
+            )
 
+        # domknięcie bloku kontrolnego
         if isinstance(a, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef,
                           ast.If, ast.For, ast.While, ast.With, ast.Try)):
             Z -= 1
-        return i
 
-    add(tree, 0, None)
-    S = int(S);
-    H = int(H);
-    Z = int(max(Z, 0))
+        return my_id, sub_size, counter
+
+    visit(tree, 0, None)
+    S = int(S); H = int(H); Z = int(max(Z, 0))
     tot = max(1, S + H)
     return AstSummary(S, H, Z, maxZ=maxZ, alpha=S / tot, beta=H / tot,
-                      nodes=nodes, labels=[n.label for n in nodes.values()])
+                      nodes=nodes, labels=labels_all)
 
 
 def compress_ast(summary: AstSummary, lam: float) -> AstSummary:
@@ -363,14 +467,14 @@ def D_M(S: List[int], T: List[int], M: Mosaic, thr: float, max_match: int = 12)
 
 
 # ──────────────────────────────────────────────────────────────────────────────
-# 3) Φ / Ψ
+# 3) Φ / Ψ (+ rejestr selektorów)
 # ──────────────────────────────────────────────────────────────────────────────
 
 def phi_region_for(label: str, M: Mosaic, thr: float) -> str:
-    if label in ("Call", "Expr"):                        return "edges"
-    if label in ("Assign",):                             return "~edges"
+    if label in ("Call", "Expr"):                         return "edges"
+    if label in ("Assign",):                              return "~edges"
     if label in ("If", "For", "While", "With", "Return"): return "all"
-    if label in ("FunctionDef", "ClassDef"):             return "roi"
+    if label in ("FunctionDef", "ClassDef"):              return "roi"
     return "~edges"
 
 
@@ -388,7 +492,6 @@ def phi_region_for_balanced(label: str, M: Mosaic, thr: float) -> str:
 
 def phi_region_for_entropy(label: str, M: Mosaic, thr: float) -> str:
     def near_thr(x): return abs(x - thr) <= 0.05
-
     fuzzy = float(np.mean([near_thr(v) for v in M.edge])) > 0.25
     if fuzzy: return "all"
     return phi_region_for(label, M, thr)
@@ -396,6 +499,16 @@ def phi_region_for_entropy(label: str, M: Mosaic, thr: float) -> str:
 
 Selector = Callable[[str, Mosaic, float], str]
 
+SELECTORS: Dict[str, Selector] = {
+    "basic": phi_region_for,
+    "balanced": phi_region_for_balanced,
+    "entropy": phi_region_for_entropy,
+}
+
+def get_selector(name: str) -> Selector:
+    """Pobierz selektor Φ po nazwie (fallback: 'basic')."""
+    return SELECTORS.get(str(name).lower(), phi_region_for)
+
 
 def centroid(ids: List[int], M: Mosaic) -> Tuple[float, float]:
     if not ids:
@@ -436,12 +549,12 @@ def psi_feedback(ast: AstSummary, M: Mosaic, delta: float, thr: float) -> AstSum
         if not ids: continue
         ed = np.array([M.edge[i] for i in ids], float)
         psi = np.array([
-            float(1.0 - ed.mean()),  # L
-            float(0.5 + 0.5 * ed.std()),  # S
-            float(min(1.0, 0.5 + ed.mean())),  # Sel
-            float(1.0 - ed.std()),  # Stab
+            float(1.0 - ed.mean()),           # L
+            float(0.5 + 0.5 * ed.std()),      # S
+            float(min(1.0, 0.5 + ed.mean())), # Sel
+            float(1.0 - ed.std()),            # Stab
             float(min(1.0, 0.3 + 0.7 * ed.mean())),  # Cau
-            float(0.4 + 0.5 * ed.std())  # H
+            float(0.4 + 0.5 * ed.std())       # H
         ], dtype=float)
         n.meta = (1.0 - delta) * n.meta + delta * psi
     S, H, Z = ast.S, ast.H, ast.Z
@@ -516,11 +629,13 @@ def invariants_check(astA: AstSummary, astB: AstSummary, M: Mosaic, thr: float)
 
 def run_once(lam: float, delta: float, rows: int, cols: int, thr: float,
              mosaic_kind: str = "grid",
-             kappa_ab: float = KAPPA_AB_DEFAULT) -> Dict[str, float]:
+             kappa_ab: float = KAPPA_AB_DEFAULT,
+             selector_name: str = "balanced") -> Dict[str, float]:
     ast_raw = ast_deltas(EXAMPLE_SRC)
     ast_l = compress_ast(ast_raw, lam)
     M = build_mosaic(rows, cols, seed=7, kind=mosaic_kind, edge_thr=thr)
-    # Φ – trzy warianty
+    sel = get_selector(selector_name)
+    # Φ – trzy warianty (zachowane dla porównań)
     J1, _ = phi_cost(ast_l, M, thr, selector=phi_region_for)
     J2, _ = phi_cost(ast_l, M, thr, selector=phi_region_for_balanced)
     J3, _ = phi_cost(ast_l, M, thr, selector=phi_region_for_entropy)
@@ -536,13 +651,13 @@ def run_once(lam: float, delta: float, rows: int, cols: int, thr: float,
 
 
 def sweep(rows: int, cols: int, thr: float, mosaic_kind: str = "grid",
-          kappa_ab: float = KAPPA_AB_DEFAULT) -> List[Dict[str, float]]:
+          kappa_ab: float = KAPPA_AB_DEFAULT, selector_name: str = "balanced") -> List[Dict[str, float]]:
     lams = [0.0, 0.25, 0.5, 0.75]
     dels = [0.0, 0.25, 0.5]
     out = []
     for lam in lams:
         for de in dels:
-            r = run_once(lam, de, rows, cols, thr, mosaic_kind, kappa_ab=kappa_ab)
+            r = run_once(lam, de, rows, cols, thr, mosaic_kind, kappa_ab=kappa_ab, selector_name=selector_name)
             r.update(dict(lambda_=lam, delta_=de))
             out.append(r)
     return out
@@ -605,26 +720,25 @@ def _pretty_table(rows: List[Dict[str, float]]) -> str:
 
 
 def cmd_run(args):
-    lam = args.lmbd
-    de = args.delta
-    r = args.rows
-    c = args.cols
-    thr = args.edge_thr
-    kind = args.mosaic
-    res = run_once(lam, de, r, c, thr, mosaic_kind=kind, kappa_ab=args.kappa_ab)
+    set_meta_mode(args.meta_mode)
+    res = run_once(args.lmbd, args.delta, args.rows, args.cols, args.edge_thr,
+                   mosaic_kind=args.mosaic, kappa_ab=args.kappa_ab, selector_name=args.selector)
     print(json.dumps({
-        "lambda": lam,
-        "delta": de,
-        "rows": r,
-        "cols": c,
-        "kind": kind,
-        "edge_thr": thr,
+        "lambda": args.lmbd,
+        "delta": args.delta,
+        "rows": args.rows,
+        "cols": args.cols,
+        "kind": args.mosaic,
+        "edge_thr": args.edge_thr,
+        "selector": args.selector,
         **res
     }, indent=2))
 
 
 def cmd_sweep(args):
-    rows = sweep(args.rows, args.cols, args.edge_thr, mosaic_kind=args.mosaic, kappa_ab=args.kappa_ab)
+    set_meta_mode(args.meta_mode)
+    rows = sweep(args.rows, args.cols, args.edge_thr, mosaic_kind=args.mosaic,
+                 kappa_ab=args.kappa_ab, selector_name=args.selector)
     print(_pretty_table(rows))
     if args.json:
         print("\n[JSON]")
@@ -632,6 +746,7 @@ def cmd_sweep(args):
 
 
 def cmd_test(args):
+    set_meta_mode(args.meta_mode)
     inv_astA = ast_deltas(EXAMPLE_SRC)
     inv_astB = compress_ast(inv_astA, args.lmbd)
     M = build_mosaic(args.rows, args.cols, seed=7, kind=args.mosaic, edge_thr=args.edge_thr)
@@ -652,6 +767,11 @@ def build_cli():
     p.add_argument("--cols", type=int, default=6, help="liczba kolumn mozaiki")
     p.add_argument("--edge-thr", type=float, default=EDGE_THR_DEFAULT, help="próg edge dla regionów")
     p.add_argument("--kappa-ab", type=float, default=KAPPA_AB_DEFAULT, help="siła sprzężenia Ψ→(α,β)")
+    p.add_argument("--selector", choices=list(SELECTORS.keys()), default="balanced",
+                   help="wybór wariantu Φ")
+    p.add_argument("--meta-mode", choices=["det", "rng"], default="det",
+                   help="tryb meta (deterministyczny / RNG do testów)")
+
     sub = p.add_subparsers(dest="cmd", required=True)
 
     q = sub.add_parser("run", help="pojedynczy przebieg (λ, Δ)")
diff --git a/structure.md b/structure.md
index 8afa332..075fc6e 100644
--- a/structure.md
+++ b/structure.md
@@ -1,5 +1,7 @@
 # AST ⇄ Mozaika — „latawce”/płaszczyzny polityk (opis obrazu)
-![Model – schemat](glitchlab/resources/img/model.png)
+
+![Model – schemat](resources/img/model.png)
+
 ## Co widać
 
 * **Zielone punkty** – węzły AST (`AstNode`). Każdy punkt ma etykietę (np. `If`, `Assign`, `Call`, `Return`).
@@ -25,10 +27,10 @@
 ## Skąd biorą się punkty i płaszczyzny
 
 1. **AST + meta**
-   Z kodu przykładowego powstaje AST z meta-wektorami `[L,S,Sel,Stab,Cau,H]` liczonymi deterministycznie ze struktury (głębokość, rozgałęzienie, wielkość poddrzewa, różnorodność). Dla każdego węzła wybieramy **dominantę** (najistotniejszy komponent meta), którą rysujemy na osi Z. 
+   Z kodu przykładowego powstaje AST z meta-wektorami `[L,S,Sel,Stab,Cau,H]` liczonymi deterministycznie ze struktury (głębokość, rozgałęzienie, wielkość poddrzewa, różnorodność). Dla każdego węzła wybieramy **dominantę** (najistotniejszy komponent meta), którą rysujemy na osi Z.
 
 2. **Mozaika heksagonalna**
-   Budowana jako siatka hex (centra, promień `R=1.0`), z polem **edge** (gęstość krawędzi) i **ROI** (środek kadru). Użyty jest **próg** `edge_thr` (domyślnie `0.55`). 
+   Budowana jako siatka hex (centra, promień `R=1.0`), z polem **edge** (gęstość krawędzi) i **ROI** (środek kadru). Użyty jest **próg** `edge_thr` (domyślnie `0.55`).
 
 3. **Selektor Φ (balanced)**
    Dobór regionu **per węzeł** na podstawie etykiety i kwartyli rozkładu edge (`Q25/Q75`):
@@ -37,10 +39,99 @@
    * `Assign` → **~edges**,
    * `FunctionDef/Return` → **roi**,
    * `If/While/For` → **all**.
-     (Wariant „balanced” stabilizuje wybór przy niejednoznacznym rozkładzie.) 
+     Wariant „balanced” stabilizuje wybór przy niejednoznacznym rozkładzie.
 
 4. **„Latawiec” O–A–R**
-   Dla wybranego regionu liczymy **centroid** `(cx,cy)` i średnie `edge`. Trójkąt **O–A–R** jest następnie wypełniony jako półprzezroczysta płaszczyzna – to **modalna polityka** węzła: które kafelki (Φ), w jakim kontekście (meta) i z jaką „materią” (edge) mają dominować. 
+   Dla wybranego regionu liczymy **centroid** `(cx,cy)` i średnie `edge`. Trójkąt **O–A–R** jest następnie wypełniony jako półprzezroczysta płaszczyzna – to **modalna polityka** węzła: które kafelki (Φ), w jakim kontekście (meta) i z jaką „materią” (edge) mają dominować.
+
+---
+
+## Meta-tagi sterujące (pozytywne/negatywne)
+
+> Meta-tag to *deklaracja preferencji* dla komponentów meta `[L,S,Sel,Stab,Cau,H]`, opcjonalnie z parametrami regionu Φ i siłą wpływu. Tag działa jako **priorytet** (miękki) lub **ograniczenie** (twarde) w pętli Φ/Ψ.
+
+### Składnia (propozycja praktyczna)
+
+W komentarzach nad węzłem/funkcją lub w profilu projektu:
+
+```python
+# @meta +Sel>=0.75 in:edges    # pozytywny – promuj selektywność w regionie edges
+# @meta -Stab<0.40 in:edges    # negatywny – unikaj niskiej stabilności w edges
+# @meta prefer:roi weight=0.6  # priorytet wyboru ROI dla tego węzła
+# @meta forbid:edges           # twardy zakaz przypisania do edges
+# @meta goal Align>=0.85       # cel globalny dla zbieżności AST↔Mozaika
+```
+
+**Polaryzacja:**
+
+* **Pozytywny (`+`)** – „ciągnij w górę” wskazaną metrykę/meta; Ψ podbija komponent meta, Φ zwiększa szansę regionu.
+* **Negatywny (`-`)** – „tłum w dół” (demotywuj); Ψ obniża komponent meta; Φ redukuje prawdopodobieństwo regionu.
+
+**Modalność i zakres:**
+
+* **scope=node** (domyślnie) – działa na pojedynczy węzeł (etykieta/linia kodu).
+* **scope=region** – działa na wszystkie węzły trafiące w dany Φ-region.
+* **scope=global** – zmienia nastawy sprzężenia `(α,β)` i wag w `Align`.
+
+### Jak tag zamienia się w działanie algorytmu
+
+* **Na etapie Φ (projekcja):**
+  tag może:
+
+  * **przeważać selektor** (np. `prefer:roi`, `forbid:edges`),
+  * **zmieniać próg** skuteczności regionu (niższy koszt Φ, jeśli zgodność z tagiem).
+
+* **Na etapie Ψ (feedback):**
+  tag mapujemy na **wektor dψ** dodany do aktualizacji meta:
+
+  ```
+  meta_new = (1−δ)·meta_old + δ·ψ(M,region) + λ_tag·dψ(tag)
+  ```
+
+  gdzie `λ_tag` to siła tagu (np. `weight`), a `dψ(+Sel>=0.75)` zwiększa komponent `Sel` i „ciągnie” A(node) w górę osi Z.
+
+* **Na poziomie globalnym:**
+  tagi typu `goal Align>=0.85` lub preferencje regionów wpływają na **kappa_ab** (mieszanie `(α,β)` z profilem mozaiki) oraz na wagi `W_DEFAULT` w mierze `Align`.
+
+### Przykładowe zastosowania
+
+* **„Oddziel I/O od ROI”**
+
+  ```
+  # @meta forbid:roi for:Call,Expr
+  # @meta prefer:edges for:Call,Expr weight=0.7
+  ```
+
+  Efekt: wywołania (I/O) będą wypychane na krawędź (edges), nawet jeśli semantyka kodu skłaniałaby do ROI.
+
+* **„Utrwal stan w tle”**
+
+  ```
+  # @meta +Stab>=0.8 in:~edges for:Assign
+  ```
+
+  Efekt: przypisania dostają Ψ-boost stabilności i Φ woli ~edges.
+
+* **„Eksponuj przyczynowość w ROI”**
+
+  ```
+  # @meta +Cau>=0.7 in:roi for:Return,FunctionDef
+  ```
+
+### Ocena spełnienia tagów (zgodność)
+
+Dla każdego tagu liczony jest **score spełnienia** i **kara naruszenia**:
+
+```
+score_tag = clamp( target − observed, … )     # zależnie od kierunku +/−
+J_meta = Σ (penalty(tag) · (1 − score_tag))
+```
+
+`J_meta` można:
+
+* dopisać do podpisu obrazu,
+* dodać do **średniego kosztu Φ**,
+* użyć jako **constraint** w pętli generacyjnej (wybierz wariant z minimalnym `J_meta`).
 
 ---
 
@@ -51,22 +142,29 @@ Dla węzła `Call(print)` (wysoka **Sel**):
 * **A** wysoko na osi Z (duża selektywność), X≈głębszy poziom, Y≈id węzła.
 * **R** z regionu `edges` (czerwony).
 * Płaszczyzna O–A–R „ciągnie” w stronę kafelków o wysokim edge: **side-effecty/I-O** powinny żyć na „krawędziach” systemu, a nie w rdzeniu ROI.
+* **Tagowe sterowanie:**
+  `@meta prefer:edges for:Call` – zwiększa szansę wyboru edges;
+  `@meta -Sel<0.6 in:roi` – zniechęca do I/O w ROI (demotywuje Sel w ROI).
 
 Dla `Assign(y=...)` (wysoka **Stab**):
 
 * **A** wysoko w **Stab**, region `~edges` (niebieski).
 * Płaszczyzna preferuje **utrwalenie stanu** w stabilnym tle (poza krawędziami).
+* **Tagowe sterowanie:**
+  `@meta +Stab>=0.8 in:~edges for:Assign` – dψ podnosi Stab i utrwala wybór ~edges.
 
 Dla `FunctionDef/Return` (wyższa **Cau**):
 
-* **R = roi** (fiolet).
-* Szkielet przyczynowy powinien być **kotwiczony** w ROI, z ograniczeniem efektów ubocznych.
+* **R = roi** (fiolet). Szkielet przyczynowy kotwiczymy w ROI.
+* **Tagowe sterowanie:**
+  `@meta +Cau>=0.7 in:roi for:Return,FunctionDef`.
 
 Dla `If` (większa **H**):
 
-* **R = all** (pomarańczowy).
-* Decyzja ma **globalne rozproszenie skutków** – plane obejmuje cały kontekst.
-
+* **R = all** (pomarańczowy). Decyzja ma globalne skutki.
+* **Tagowe sterowanie:**
+  `@meta +H>=0.7 for:If` – wzmacnia dyfuzję wpływu;
+  `@meta forbid:edges for:If` – jeśli chcesz unikać zbytniej „nerwowości” na krawędziach.
 
 ---
 
@@ -80,44 +178,48 @@ Dla `If` (większa **H**):
    * `R = centroid(region_ids(M, kind, thr))`,
    * `A = (depth, id, meta_dominant)`,
    * rysujemy płaszczyznę **O–A–R** w kolorze regionu.
-4. **Miękkie etykiety** (sigmoida z `tau=0.08`) są używane w metryce kafelków, ale do **wizualizacji** używamy regionów binarnych zgodnych z legendą.
+4. **Miękkie etykiety** (sigmoida `τ=0.08`) służą w metryce kafelków; do wizualizacji używamy regionów binarnych z legendy.
+5. **Meta-tagi** (jeśli obecne) modulują:
 
+   * selektor Φ (prefer/forbid, zmiana priorytetu),
+   * Ψ-update (dodanie `dψ(tag)`),
+   * wagi globalne `(α,β)` i `W_DEFAULT`.
 
 ---
 
 ## Jak oceniać (miary, które można dopisać w podpisie)
 
 * **Koszt Φ** (per węzeł i średni):
-  `J_φ = D_M(ids_region, ids_kontr, M, thr)`
-  – im **niżej**, tym lepiej (węzeł trafił w „swój” region). `D_M` to symetryczny koszt dopasowania zbiorów kafelków (Earth-Mover-lite) z karą długości i miękkimi etykietami. 
+  `J_φ = D_M(ids_region, ids_kontr, M, thr)` – im **niżej**, tym lepiej (węzeł trafił w „swój” region).
+
+* **Zgodność tagów**:
+  `J_meta = Σ penalty(tag)·(1 − score_tag)` – naruszenia tagów podnoszą koszt; spełnienia go obniżają.
 
 * **Align(AST↔M)** (globalnie):
-  `Align = 1 − min(1, wS·|α−aM| + wH·|β−bM| + wZ·|Z/maxZ − 0|)`
-  – zbieżność udziałów struktury (α=S/(S+H)) i „materii” (β=H/(S+H)) do profilu mozaiki `(aM,bM)`. **Wyższy = lepszy**. 
+  `Align = 1 − min(1, wS·|α−aM| + wH·|β−bM| + wZ·|Z/maxZ − 0|)` – zbieżność udziałów struktury (α) i „materii” (β) do profilu mozaiki `(aM,bM)`.
 
 * **Sprzężenie Ψ→(α,β)**:
-  po projekcji Φ aktualizujemy meta i lekko **blendujemy** (α,β) z profilem mozaiki, ważone `kappa_ab` i niepewnością edge (`std(edge)`). To zmienia „nastawienie” generatora (więcej stabilizacji vs więcej akcji). 
+  po projekcji Φ aktualizujemy meta i lekko **blendujemy** `(α,β)` z profilem mozaiki, ważone `kappa_ab` i niepewnością `std(edge)`.
 
-* **Profil mozaiki** (dla opisu obok obrazka):
-  `edge_thr = 0.55`, `p(edge) = mean(edge > thr)`, `mean(edge|region)` i centroidy `C_edges / C_~edges / C_roi / C_all`. (Te liczby pochodzą bezpośrednio z mozaiki użytej do renderu.) 
+* **Profil mozaiki** (dla podpisu):
+  `edge_thr = 0.55`, `p(edge) = mean(edge > thr)`, `mean(edge|region)` oraz centroidy `C_edges / C_~edges / C_roi / C_all`.
 
 ---
 
 ## Dlaczego to jest **modalne** i „miarodajne”
 
-* **Modalne** – każdy latawiec odpowiada **trybowi działania** węzła (dominancie meta: Sel/Stab/Cau/H) **w danym kontekście** mozaiki (edges/~edges/roi/all). Zmiana trybu/meta lub regionu **natychmiast** zmienia geometrię płaszczyzny (O–A–R), co widać na wykresie.
-* **Miarodajne** – wszystkie decyzje mają **liczbowe** uzasadnienie (dominanty meta, centroidy regionów, `D_M`, `Align`, udział edge powyżej progu). Tymi miarami sterujesz **generacją** (Ψ podbija/obniża komponenty meta, selektor Φ może się przełączyć, a w efekcie generowany AST zmienia kształt). 
+* **Modalne** – każdy latawiec odpowiada **trybowi działania** węzła (dominancie meta: Sel/Stab/Cau/H) **w danym kontekście** mozaiki (edges/~edges/roi/all). Meta-tagi zmieniają *tryb*: przesuwają A(node), zmieniają preferencje Φ i wzmacniają/hamują Ψ.
+* **Miarodajne** – wszystkie decyzje mają **liczbowe** uzasadnienie (meta, centroidy, `D_M`, `Align`, `J_meta`, udział edge powyżej progu). Tymi miarami sterujesz **generacją** i możesz porównywać warianty.
 
 ---
 
-## „o–ro” i sterowanie generacją
+## „0–ro” i sterowanie generacją
 
 * **O** to stała kotwica systemowa (punkt odniesienia).
 * **R/O (ro)** to **relacja** między regionem mozaiki a originem – geometryczna „dźwignia”: im dalej i wyżej `R` (większe `edge`/przeciążenie regionu), tym silniejszy wpływ regionu na aktualizację meta (Ψ) i na dobór kolejnych kroków AST.
-* **Przesunięcia „o–ro”** (zmiana rozkładu edge/ROI) powodują, że **te same** węzły AST generują **inne** konfiguracje (inne latawce), bo Φ wybiera inne regiony, a Ψ inaczej koryguje meta.
+* **Meta-tagi a o–ro:** pozytywne tagi „wydłużają dźwignię” (większe `λ_tag`), negatywne – „skracają” lub blokują połączenie O→R dla wybranych etykiet/regionów.
+* **Przesunięcia „o–ro”** (zmiana rozkładu edge/ROI) powodują, że **te same** węzły AST generują **inne** konfiguracje (inne latawce), bo Φ wybiera inne regiony, Ψ inaczej koryguje meta, a tagi modulują oba efekty.
 
 ---
 
-
-> 3D-wizualizacja pokazuje węzły AST (zielone) oraz ich **polityki** jako płaszczyzny O–A–R (kolory regionów mozaiki), co pozwala **modalnie** sterować generacją kodu: Φ wybiera kontekst kafelków, Ψ koryguje metę, a miary `D_M` i `Align` mówią, czy plan zbiega do danych. 
-
+> **Alt-text / TL;DR:** 3D-wizualizacja pokazuje węzły AST (zielone) oraz ich **polityki** jako płaszczyzny O–A–R (kolory regionów mozaiki). Meta-tagi dodatnie/ujemne modulują Φ (wybór kontekstu) i Ψ (aktualizację meta), a miary `D_M`, `Align` i `J_meta` pozwalają mierzyć, czy generacja zbiega do założonej ontologii.
-- 
2.45.1.windows.1

